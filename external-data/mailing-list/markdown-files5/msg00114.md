---
title: "Re: one-to-very-many link associations"
description: ""
project: community
lastmod: 2010-04-22T06:04:38-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg00114"
mailinglist_parent_id: "msg00111"
author_name: "Eric Gaumer"
project_section: "mailinglistitem"
sent_date: 2010-04-22T06:04:38-07:00
---


Don't fall into the trap of "one size fits all". Riak is an amazing product
that can solve a number of tough problems. I don't think this is one of
them. You need/want a triple store to (correctly) model this sort of
problem. You need flexible schemas, ontologies, and a graph based query
language.

Take a look at: http://www.bigdata.com/

Regards,
-Eric


On Thu, Apr 22, 2010 at 4:23 AM, Orlin Bozhinov  wrote:

&gt; Riak Users,
&gt;
&gt; Thinking about a data modeling pattern that will allow one to not worry
&gt; about how many links can be had with one-to-many (or many-to-many)
&gt; scenarios. This question has come up before in various places. One answer
&gt; I like is Sean's from this thread
&gt; http://riak.markmail.org/thread/6e7ypt5ndjzjk7mr saying: "... at the point
&gt; where you have that many links it becomes necessary to consider other
&gt; options, including intermediary objects or alternative ways of representing
&gt; the relationship". I wonder if an \\_intermediary way\\_ could be baked into
&gt; Ripple (or your client library of choice). This is for the cases when
&gt; one-to-many can become one-to-very-many.
&gt;
&gt; To make it more interesting, let's say we want to add metadata to the
&gt; relationship as described in the pre-last paragraph of
&gt; http://blog.basho.com/2010/03/25/schema-design-in-riak---relationships/.
&gt; Here is what I have in mind: {from}-&gt;{from\\_association}-&gt;{association}-&gt;{to}
&gt; -- the {curlied} are bucket / objects and -&gt; are links. For example if
&gt; {from} = "user"; and {association} = "interest"; and {to} = {whatever} there
&gt; is interest in - e.g. "event", "place", "story", another "user" or even
&gt; self-interest :) But I'm getting ahead of myself. Let's use a recent
&gt; example from Basho's blog where a "user" links {to} = "task". So we get:
&gt; user -has--&gt; user\\_interest -meta--&gt; interest -in--&gt; task.
&gt;
&gt; The "interest" association could imply "ownership" but maybe the
&gt; application allows its "users" to express interest another's "task". Maybe
&gt; it's a collaborative effort... Reverse-linking from the many interests /
&gt; tasks to their respective owners is easy because it's just a single link for
&gt; task -of--&gt; user or interest -of--&gt; user. In the interests bucket I want to
&gt; put all kinds of useful metadata. There I would embed (via Composition as
&gt; Ripple calls it) not only all the "tags", but also "notes", "star", etc.
&gt; Think delicious bookmarks or google reader items and so on. It seems like a
&gt; common pattern. Something that may fit the use case of @botanicus too. One
&gt; could represent all possible links (various associations) between two
&gt; objects as metadata contained in a given "interest". Ownership can be a
&gt; type of interest for the sake of link-walking.
&gt;
&gt; There are three things happening here:
&gt; 1. the "very many" (links through intermediary objects)
&gt; 2. optional metadata (yet another intermediary object) - multiple
&gt; associations between any two objects can be expressed through extra metadata
&gt; rather than extra links
&gt; 3. reusing the "very-many" and / or metadata intermediaries -linking--&gt; to
&gt; objects in different buckets
&gt;
&gt; The real issue (that #1 solves) is not having an easy ability to do "very
&gt; many" links originating from the same object. The #2 metadata object vs a
&gt; few extra links for tags / notes (which are insignificant compared to the
&gt; many interests a user can have) - makes it easier (in my eyes) to put in
&gt; Redis for filtering... Of-course interests (#2) could be specialized
&gt; (different metadata models) with regards to what they are about (#3). On
&gt; delicious that's just bookmarks. I've got close to 6,000 of them. Does
&gt; that approach "very many" in terms of Riak? If "very many" were easier to
&gt; do (with client-library models or otherwise Riak itself) #2 & #3 would be
&gt; indifferent about which intermediary leads to them (an extra link-walk step)
&gt; as they are already possible anyway. How could we step (automagically)
&gt; through an intermediary object (the user\\_interest "very many" enabler
&gt; bucket) - having a specific target object in mind?
&gt;
&gt; I think it may already be possible with current link-walking. Then it's
&gt; all a matter of managing the intermediary bucket / objects. Not exactly
&gt; sure how the max links are calculated. According to one formula from the
&gt; mailing list I may get 1000 headers (limit in mochiweb) \\* 200 links ("around
&gt; 40 chars per link") = 200,000 links max? That seems like "very many", but
&gt; there was also something about performance burden... If we took those 200
&gt; with just a single header, pointing to 200 intermediary objects, each
&gt; pointing to another 200 target objects we would get 40,000 links. That's
&gt; quite a few. Of-course that number could easily get much much bigger
&gt; (square the default limit). What decides how many links per intermediary
&gt; object is ideal? Is it a setting that Basho could recommend a default for?
&gt; Could Ripple automate that? Some link creation logic is needed and if Riak
&gt; doesn't support it, the client libraries that do "associations" are a good
&gt; candidate for the task. Also with link deletion - we'll need to either keep
&gt; track of link count per intermediary or run map-reduce jobs to clean-up once
&gt; in a while...
&gt;
&gt; In either case, link creation should be as simple as knowing which
&gt; intermediary object is the last one and whether we should add the next new
&gt; link through it or through a new intermediary (when a certain link count
&gt; \\_setting\\_ is reached). If this could be automated then it wouldn't matter
&gt; how many the links are. Otherwise Riak would have to be monitored and if
&gt; certain links begin to get "very many" then a model migration is run to make
&gt; the transition from few straight links to very many. If client libraries
&gt; could work with both kinds of links then this transition would mean tweaking
&gt; the model association (and link walking remaining the same). But when using
&gt; Riak's raw interface there would be a difference, which means a switch from
&gt; one-to-many to one-to-very-many will usually take some thinking / effort.
&gt; Any time I'm in doubt, it seems safer to side with the very-many (just in
&gt; case). What is the cost of an extra step of link-walking as compared to
&gt; changing application code?
&gt;
&gt; As another example, if one were to build GitHub with Riak, how would you
&gt; model the watching & following associations? Many users would use few, but
&gt; some would use many, which in a few cases get to be very many, which means
&gt; everybody will watch and follow in very-many style. If the app ui allows
&gt; it, one has to assume it will happen... Here is the following / watching
&gt; example for very many - different words for having interest in something:
&gt;
&gt; \\* separate very-many:
&gt; user -does--&gt; user\\_following -what--&gt; user
&gt; user -does--&gt; user\\_watching -what--&gt; repo (-of--&gt; user)
&gt; \\* combined very-many:
&gt; user -has--&gt; user\\_interest -for--&gt; {whatever}
&gt; \\* combined very-many + metadata:
&gt; user -has--&gt; user\\_interest -meta--&gt; interest -for--&gt; {whatever}
&gt; \\* and if metadata was different, perhaps:
&gt; user -has--&gt; user\\_interest -meta--&gt; interest\\_user -what--&gt; user
&gt; user -has--&gt; user\\_interest -meta--&gt; interest\\_repo -what--&gt; repo
&gt;
&gt; Whatever the pattern, it would be nice to have the best practices defined
&gt; and implemented for reuse (via association-proficient client libs - a la
&gt; Ripple). After all, Riak users like big data, which is another way of
&gt; saying very many items of stuff -- and why not very many hands / links too
&gt; :)
&gt;
&gt; Orlin
&gt;
&gt;
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;
&gt;
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

