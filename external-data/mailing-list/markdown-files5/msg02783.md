---
title: "Re: Easier to use Java Client"
description: ""
project: community
lastmod: 2011-03-29T11:31:21-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg02783"
mailinglist_parent_id: "msg02777"
author_name: "Rexxe"
project_section: "mailinglistitem"
sent_date: 2011-03-29T11:31:21-07:00
---


Yes, my RiakRestClient creates a random client id and also allows the
developer to set one. I did not know, though, that there were special
optimizations for Base64 encoding of a byte[4]. I will change the code to
reflect that. Why would you need a different clientId for each thread
though? Not sure I get that. If this is running in Tomcat, for example,
why can't all threads in Tomcat have the same client id?

The second part is more difficult to tackle and is something I haven't dealt
with yet. I've read this a bunch of times:
http://blog.basho.com/2010/01/29/why-vector-clocks-are-easy/, which helps
make sense of vector clocks. My thought is that on a PUT or DELETE, if the
object doesn't have the same vector clock, the client would throw back an
StaleObjectStateException with the siblings. The developer can then deal
with the object how they need to deal with it. I'm not sure the client
should automatically resolve conflicts, though it could do a merge if it was
able to pull back the object prior to both changes and then do a
comparison. I guess on PUT and DELETE another GET has to be done, though it
would be great if Riak could throw some sort of error back instead on a PUT
or DELETE so another operation on Riak wouldn't have to be done.

--Andrew

On Tue, Mar 29, 2011 at 2:02 AM, Kresten Krab Thorup wrote:

&gt; One thing, which is often missed by newcomers to Riak [I'm not saying you
&gt; missed it], is the importance of managing client IDs, and passing the right
&gt; vector clocks back to the server.
&gt;
&gt; { Basho'ers ... please corret me if I'm wrong }
&gt;
&gt; Kresten
&gt;
&gt;
&gt;
&gt; So, Rule#1 (which has two clauses), which you can always revert to:
&gt;
&gt; 1.a / every client needs a clientID, which is distinct for that client. Be
&gt; sure to always pass it along in all calls (in Java that is done by calling
&gt; setClientID on the RiakClient, at the HTTP-level, it is done by passing the
&gt; X-Riak-ClientId HTTP header).
&gt;
&gt; 1.b / when you send an update (HTTP PUT or DELETE), always pass along the
&gt; X-Riak-Vectorclock from a corresponding GET. \\*If you don't do this, your
&gt; PUT is likely to go to /dev/null, \\*because Riak thinks that it is a replay
&gt; of an old request.
&gt;
&gt; Until you're re really familiar with how Riak works, you should always do
&gt; these two, or you will be severely burned when you realize that it doesn't
&gt; behave as expected. Believe me, I've been there.
&gt;
&gt;
&gt; 1.a / Choosing a good client ID
&gt; ========================
&gt;
&gt; If you don't choose a client ID, Riak will do it for you ... BUT .. it will
&gt; choose a new one for EVERY REQUEST. This has many issues, so Riak should
&gt; really require YOU to come up with one in stead; perhaps it will do so at
&gt; some point in the future.
&gt;
&gt; Riak has some special optimizations if your client ID is the
&gt; Base64-encoding of a byte array of length 4. So, a good, default way to
&gt; choose a client id is thus:
&gt;
&gt; static SecureRandom rnd = new SecureRandom();
&gt;
&gt;
&gt; static ThreadLocal CLIENT\\_ID = new ThreadLocal() {
&gt; protected String initialValue() {
&gt; return randomClientID();
&gt; };
&gt; };
&gt;
&gt;
&gt; public static String getClientID() {
&gt; return CLIENT\\_ID.get();
&gt; }
&gt;
&gt;
&gt; static private String randomClientID() {
&gt; byte[] bytes = new byte[4];
&gt; rnd.nextBytes(bytes);
&gt; return Base64.encode(bytes);;
&gt; }
&gt;
&gt; This makes it so that each thread in your application is assigned a new
&gt; random ClientID, which is often useful if your client is multi-threaded.
&gt;
&gt; The above code is \\*alot\\* better than the default of having the server side
&gt; choose a new client id for every request.
&gt;
&gt; If you have some kind of logical unique, non-concurrent client concept in
&gt; your system, that may be even better. It could e.g. be the IMEI of your
&gt; mobile phone, if your Riak client app is running on a Phone; or it could be
&gt; a userid, if you are sure that only one user is accessing the system at a
&gt; time.
&gt;
&gt;
&gt; 1.b / Passing the VectorClock
&gt; =======================
&gt;
&gt; Secondly, you need to make sure that you pass the vector clock.
&gt;
&gt; You should think of the vector clock as an opaque "optimistic concurrency
&gt; token", that you receive when you do a GET, and have to pass in when you do
&gt; a PUT ... and then you get a new "optimistic concurrency token", that you
&gt; have to use henceforth.
&gt;
&gt; Depending on the configuration of your buckets, using an old vector clock
&gt; will simply cause the PUT request to be ignored (if allow\\_mult=false), or
&gt; cause siblings to be created (if allow\\_mult=true). This is where Riak is
&gt; often "not what you expect", but there is a good reason for this behavior.
&gt;
&gt; IT IS ABSOLUTELY PARAMOUNT TO UNDERSTAND THIS.
&gt;
&gt;
&gt;
&gt; The above two things (1.a and 1.b) are so difficult to understand for
&gt; newcomers, and a bit tricky to get right, so IMHO a new Java client should
&gt; provide some way to avoid doing these mistakes as the default behavior.
&gt;
&gt; - So, it should choose a good client ID fo you if you don't.
&gt; - And it should make it so that you can't do UPDATE/PUT without having
&gt; first GOT'en the riak object.
&gt;
&gt; The last part is especially tricky. Perhaps we should have the API look
&gt; like this to help that ....
&gt;
&gt; interface RiakObject {
&gt; ...
&gt; }
&gt;
&gt; interface UpdateableRiakObject extends RiakObject { ... }
&gt; interface CreateableRiakObject extends RiakObject { ... }
&gt;
&gt; RiakClient {
&gt; UpdateableRiakObject update(UpdateableRiakObject o) throws
&gt; NotModified
&gt; { ... send PUT ... }
&gt;
&gt; UpdateableRiakObject create(CreateableRiakObject o) throws
&gt; AlreadyThere
&gt; { ... send PUT ... }
&gt;
&gt; UpdateableRiakObject get(bucket, key);
&gt;
&gt; CreateableRiakObject fresh(bucket, key);
&gt; }
&gt;
&gt; I.e. NOT EXPOSE constructors for the implementors of RiakObject. The only
&gt; way to get an UpdateableRiakObject is to call RiakClient.get, or as the
&gt; result of calling update/create; you can't just allocate one. Also calling
&gt; update/create should "invalidate" the original object so that it cannot
&gt; accidentally be used again.
&gt;
&gt; I really think we need to have a way to enforce the linear nature of these
&gt; things. Otherwise people get fooled.
&gt;
&gt;
&gt;
&gt; Kresten
&gt;
&gt;
&gt;
&gt;
&gt;
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

