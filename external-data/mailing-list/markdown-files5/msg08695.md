---
title: "Re: data modeling question"
description: ""
project: community
lastmod: 2012-09-25T14:17:31-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg08695"
mailinglist_parent_id: "msg08694"
author_name: "Charlie Bowman"
project_section: "mailinglistitem"
sent_date: 2012-09-25T14:17:31-07:00
---


accidentally hit enter before I finished the last question. The last
sentence was:

Can I load 10 messages in

On Tue, Sep 25, 2012 at 2:16 PM, Charlie Bowman wrote:

&gt; You actually hit on several nuances regarding the app that I left out of
&gt; the original email to keep things simple. I go a little deeper now, and I
&gt; have a question regarding the link walking
&gt;
&gt; "should make PlayerMessage PlayerMessages"
&gt; I agree, I was actually referencing my model name, which I always
&gt; singularize.
&gt;
&gt; "It's going to be some work updating 1M+ PlayerMessages objects when a
&gt; "mass message" is sent."
&gt; You can't actually "send" a message to 1M recipients. What I actually
&gt; is "send" the message to players who match certain criteria. When a player
&gt; logs in, I look to see if they match the criteria for an incoming message.
&gt; If they do I add the message id to their "inbox". That way I'm never
&gt; actually iterating over 1M records to add the id. Very similar to your
&gt; idea actually
&gt;
&gt; "If you need to read PlayerMessage and corresponding Messages in one go,
&gt; you can model the relation from PlayerMessage to Message with Riak Links,
&gt; and avoid a database roundtrip by using link walking."
&gt; If I do this, would I need to keep a second array in the PlayerMessage
&gt; object to then also map which messages have been read? Would link walking
&gt; be much faster? Currently I would need to have a separate query to load
&gt; the message objects? Can I load 10 message objects in
&gt;
&gt;
&gt;
&gt;
&gt;
&gt;
&gt; On Mon, Sep 24, 2012 at 4:17 AM, Rune Skou Larsen  wrote:
&gt;
&gt;&gt; Looks good! A couple of observations:
&gt;&gt;
&gt;&gt; The relation from PlayerMessage to Message introduces the possibility of
&gt;&gt; inconsistency by either dead references to Message or orphan Messages.
&gt;&gt; Thats managable - just an inconvinience.
&gt;&gt; If you need to read PlayerMessage and corresponding Messages in one go,
&gt;&gt; you can model the relation from PlayerMessage to Message with Riak Links,
&gt;&gt; and avoid a database roundtrip by using link walking.
&gt;&gt; The PlayerMessage object could also include refs for sent messages if you
&gt;&gt; need that.
&gt;&gt; You should probably rename "PlayerMessage" -&gt; "PlayerMessages", as it
&gt;&gt; contains an array of messages. Or just "Player".
&gt;&gt; It's going to be some work updating 1M+ PlayerMessages objects when a
&gt;&gt; "mass message" is sent. Consider modelling the mass messages differently,
&gt;&gt; with a recipient group or recipient filter. So when you search for a
&gt;&gt; recipient's messages, you look up separately if there are some mass
&gt;&gt; messages for him. You can still flag when a mass message has been read by a
&gt;&gt; player in his PlayerMessages object.
&gt;&gt;
&gt;&gt; Good luck with the game! Can I ask you, what game you're making?
&gt;&gt;
&gt;&gt; - Rune
&gt;&gt;
&gt;&gt; Trifork
&gt;&gt;
&gt;&gt; --
&gt;&gt;
&gt;&gt; Best regards / Venlig hilsen
&gt;&gt; \\*Rune Skou Larsen\\*
&gt;&gt; Trifork Public A/S / Team Riak
&gt;&gt; Margrethepladsen 4, 8000 Århus C, Denmark
&gt;&gt; Phone: +45 3160 2497 Skype: runeskoularsen twitter: @RuneSkouLarsen
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt; On 21-09-2012 23:37, Charlie Bowman wrote:
&gt;&gt;
&gt;&gt; +riak list
&gt;&gt;
&gt;&gt; My current plan is to use something very similar to your second idea
&gt;&gt; (bulk messages in 1 object). Here's my current idea, I would love to hear
&gt;&gt; your opinion on this! Sometimes a message will be sent to over 1M
&gt;&gt; recipients, so I think I'll store the message contents in its own model.
&gt;&gt; My player objects are stored in a relational db, so I can use their id's
&gt;&gt; in my player\\_message and deleted\\_player\\_message keys for easy lookup.
&gt;&gt;
&gt;&gt; Message (actually have 3 different message types, but they're all
&gt;&gt; fairly similar to this)
&gt;&gt; ---------
&gt;&gt; {
&gt;&gt; :subject =&gt; 'fdsa'
&gt;&gt; :body =&gt; 'fdsa'
&gt;&gt; :sent\\_at =&gt; Time
&gt;&gt; }
&gt;&gt;
&gt;&gt; PlayerMessage (key will include the player id so I can look this model
&gt;&gt; up by player
&gt;&gt; --------------
&gt;&gt; array of:
&gt;&gt; {
&gt;&gt; :id =&gt; message\\_id,
&gt;&gt; :type =&gt; message type
&gt;&gt; :read =&gt; boolean
&gt;&gt; }
&gt;&gt;
&gt;&gt;
&gt;&gt; DeletedPlayerMessage (key will include the player id so I can look this
&gt;&gt; model up by player)
&gt;&gt; --------------
&gt;&gt; array of:
&gt;&gt; {
&gt;&gt; :id =&gt; message\\_id
&gt;&gt; :type =&gt; message\\_type
&gt;&gt; }
&gt;&gt;
&gt;&gt; I'm definitely optimizing for the recipient, I want to be able to load
&gt;&gt; all or just unread messages as fast as possible. I will not need to look
&gt;&gt; up a message and see a list of all recipients.
&gt;&gt;
&gt;&gt;
&gt;&gt; My idea is that when I load the "inbox", I'll load the PlayerMessage
&gt;&gt; object for the given player, then separate the read from the unread emails
&gt;&gt; inside the application. From my quick testing, this works great with
&gt;&gt; relatively small numbers of messages. I'm capping the stored messages at
&gt;&gt; ~1000, and the process is nearly instantaneous. When a user deletes a
&gt;&gt; message, I copy the message hash from the PlayerMessage model to the
&gt;&gt; DeletedMesssage model for storage. There's a business requirement to store
&gt;&gt; all old emails.
&gt;&gt;
&gt;&gt; What do you think?
&gt;&gt;
&gt;&gt; On Fri, Sep 21, 2012 at 5:18 AM, Rune Skou Larsen wrote:
&gt;&gt;
&gt;&gt;&gt; The best data model always depends on the structure of data and the
&gt;&gt;&gt; access pattern. The natural access pattern for your messages is likely
&gt;&gt;&gt; lookup from two sides: sender and receiver. And you might need to support
&gt;&gt;&gt; message expiry too. This means that you need on-disk indeces if you want
&gt;&gt;&gt; more messages than will fit in memory.
&gt;&gt;&gt;
&gt;&gt;&gt; In Riak you can do it quite simply with any of the ordered backends
&gt;&gt;&gt; (leveldb, hanoidb, lowkeydb):
&gt;&gt;&gt;
&gt;&gt;&gt; One message = one Riak object. Example: {sender='321', recipient='123',
&gt;&gt;&gt; timestamp = 1234567, text= 'bla bla'}
&gt;&gt;&gt; Key is timestamp prefixed.
&gt;&gt;&gt; 2i indeces for  and .
&gt;&gt;&gt; Consider using a compound index if you often distinguish between
&gt;&gt;&gt; read/unread messages. For instance: \\_
&gt;&gt;&gt;
&gt;&gt;&gt; Example query returning keys for all unread messages belonging to
&gt;&gt;&gt; recipient with id 123 using compound index:
&gt;&gt;&gt; http://myhost:8098/buckets/messages/index/recipient\\_bin/unread\\_123
&gt;&gt;&gt;
&gt;&gt;&gt; Example query returning keys for all messages older than a year, so you
&gt;&gt;&gt; can delete old messages (not necesary using backends with autoexpiry):
&gt;&gt;&gt; http://myhost:8098/buckets/messages/index/$key/0/2011-09-21
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; Here is an alternative approach: You can choose to optimize for the
&gt;&gt;&gt; recipient side of the access pattern, by bulking all the messages for a
&gt;&gt;&gt; given recipient in one Riak object. This is much faster that retrieving a
&gt;&gt;&gt; large number of messages individually, the price being more difficult
&gt;&gt;&gt; lookup from the sender side:
&gt;&gt;&gt; Key: recipient\\_id
&gt;&gt;&gt; One Riak Object = all messages for a given recipient. Example:
&gt;&gt;&gt; [{sender='321', timestamp = 1234567, text= 'bla bla'},{sender='456',
&gt;&gt;&gt; timestamp = 1234569, text= 'bla bla2'}]
&gt;&gt;&gt; 2i index for s
&gt;&gt;&gt;
&gt;&gt;&gt; Example query returning an object with all messages belonging to
&gt;&gt;&gt; recipient with id 123:
&gt;&gt;&gt; http://myhost:8098/buckets/messages/keys/123
&gt;&gt;&gt;
&gt;&gt;&gt; If you want text search on for instance message content, you should
&gt;&gt;&gt; consider using Riak Search.
&gt;&gt;&gt;
&gt;&gt;&gt; - Rune
&gt;&gt;&gt;
&gt;&gt;&gt; Trifork
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; Best regards / Venlig hilsen
&gt;&gt;&gt; \\*Rune Skou Larsen\\*
&gt;&gt;&gt; Trifork Public A/S / Team Riak
&gt;&gt;&gt; Margrethepladsen 4, 8000 Århus C, Denmark
&gt;&gt;&gt; Phone: +45 3160 2497 Skype: runeskoularsen twitter: @RuneSkouLarsen
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; On 20-09-2012 01:33, Charlie Bowman wrote:
&gt;&gt;&gt;
&gt;&gt;&gt; I'm in the process of designing an in game messaging system that
&gt;&gt;&gt; basically replicates the same functionality of email all within the context
&gt;&gt;&gt; of the application. I do not have a ton of experience with true key/value
&gt;&gt;&gt; db stores so I'm looking to find a good resource for ideas on how to best
&gt;&gt;&gt; model this. I have a first version, but I dont want to reinvent the wheel
&gt;&gt;&gt; if can help it. I've done the requisite googling, but haven't found
&gt;&gt;&gt; anything relevant yet. Are there any guides/tutorials/open source projects
&gt;&gt;&gt; that anyone knows of.
&gt;&gt;&gt;
&gt;&gt;&gt; Thanks!
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt;&gt; riak-users mailing list
&gt;&gt;&gt; riak-users@lists.basho.com
&gt;&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

