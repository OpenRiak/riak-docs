---
title: "Re: Forcing Siblings to Occur"
description: ""
project: community
lastmod: 2013-11-12T14:43:36-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg12964"
mailinglist_parent_id: "msg12963"
author_name: "John Daily"
project_section: "mailinglistitem"
sent_date: 2013-11-12T14:43:36-08:00
---


Jason, I don’t see any inherent problems, given reasonable management of the 
situation as you describe. I’d have to chase the code path to see what overhead 
you’re introducing to Riak’s processing, but if it’s working well for you, then 
who am I to object?

Perhaps someone who’s more familiar with the sibling management code could 
chime in.

-John

On Nov 12, 2013, at 5:10 PM, Jason Campbell  wrote:

&gt; I am currently forcing siblings for time series data. The maximum bucket 
&gt; sizes are very predictable due to the nature of the data. I originally used 
&gt; the get/update/set cycle, but as I approach the end of the interval, reading 
&gt; and writing 1MB+ objects at a high frequency kills network bandwidth. So now, 
&gt; I append siblings, and I have a cron that merges the previous siblings (a 
&gt; simple set union works for me, only entire objects are ever deleted).
&gt; 
&gt; I can see how it can be dangerous to insert siblings, bit if you have some 
&gt; other method of knowing how much data is in one, I don't see size being an 
&gt; issue. I have also considered using a counter to know how large an object is 
&gt; without fetching it, which shouldn't be off by more than a few siblings 
&gt; unless there is a network partition.
&gt; 
&gt; So aside from size issues, which can be roughly predicted or worked around, 
&gt; is there any reason to not create hundreds or thousands of siblings and 
&gt; resolve them later? I realise sets could work well for my use case, but they 
&gt; seem overkill for simple append operations when I don't need delete 
&gt; functionality. Creating your own CRDTs are trivial if you never need to 
&gt; delete.
&gt; 
&gt; Thoughts are welcome,
&gt; Jason
&gt; From: John Daily
&gt; Sent: Wednesday, 13 November 2013 3:10 AM
&gt; To: Olav Frengstad
&gt; Cc: riak-users
&gt; Subject: Re: Forcing Siblings to Occur
&gt; 
&gt; Forcing siblings other than for testing purposes is not typically a good 
&gt; idea; as you indicate, the object size can easily become a problem as all 
&gt; siblings will live inside the same Riak value.
&gt; 
&gt; Your counter-example sounds a lot like a use case for server-side CRDTs; data 
&gt; structures that allow the application to add values without retrieving the 
&gt; server-side content first, and siblings are resolved by Riak.
&gt; 
&gt; These will arrive with Riak 2.0; see 
&gt; https://gist.github.com/russelldb/f92f44bdfb619e089a4d for an overview.
&gt; 
&gt; -John
&gt; 
&gt; On Nov 12, 2013, at 7:13 AM, Olav Frengstad  wrote:
&gt; 
&gt;&gt; Do you consider forcing siblings a good idea? I would like to get some input 
&gt;&gt; on possible use cases and pitfalls.
&gt;&gt; For instance i have considered to force siblings and then merge them on read 
&gt;&gt; instead of fetching an object every time i want to update it (especially 
&gt;&gt; with larger objects).
&gt;&gt; 
&gt;&gt; It's not clear from the docs if there are any limitations, will the maximum 
&gt;&gt; object size be the limitation:?
&gt;&gt; 
&gt;&gt; A section of the docs[1] comees comes to mind:
&gt;&gt; 
&gt;&gt; "Having an enormous object in your node can cause reads of that object to 
&gt;&gt; crash the entire node. Other issues are increased cluster latency as the 
&gt;&gt; object is replicated and out of memory errors."
&gt;&gt; 
&gt;&gt; [1] http://docs.basho.com/riak/latest/theory/concepts/Vector-Clocks/#Siblings
&gt;&gt; 
&gt;&gt; 2013/11/9 Brian Roach 
&gt;&gt; On Fri, Nov 8, 2013 at 11:38 AM, Russell Brown  wrote:
&gt;&gt; 
&gt;&gt; &gt; If you’re using a well behaved client like the Riak-Java-Client, or any 
&gt;&gt; &gt; other that gets a vclock before doing a put, use whatever option stops 
&gt;&gt; &gt; that.
&gt;&gt; 
&gt;&gt; for (int i = 0; i &lt; numReplicasWanted; i++) {
&gt;&gt; bucket.store("key", "value").withoutFetch().execute();
&gt;&gt; }
&gt;&gt; 
&gt;&gt; :)
&gt;&gt; 
&gt;&gt; - Roach
&gt;&gt; 
&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt; 
&gt; 
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

