---
title: "Re: data modeling question"
description: ""
project: community
lastmod: 2012-09-21T14:37:44-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg08640"
mailinglist_parent_id: "msg08621"
author_name: "Charlie Bowman"
project_section: "mailinglistitem"
sent_date: 2012-09-21T14:37:44-07:00
---


+riak list

My current plan is to use something very similar to your second idea (bulk
messages in 1 object). Here's my current idea, I would love to hear your
opinion on this! Sometimes a message will be sent to over 1M recipients, so
I think I'll store the message contents in its own model. My player
objects are stored in a relational db, so I can use their id's in my
player\\_message and deleted\\_player\\_message keys for easy lookup.

Message (actually have 3 different message types, but they're all fairly
similar to this)
---------
{
 :subject =&gt; 'fdsa'
 :body =&gt; 'fdsa'
 :sent\\_at =&gt; Time
}

PlayerMessage (key will include the player id so I can look this model up
by player
--------------
array of:
{
 :id =&gt; message\\_id,
 :type =&gt; message type
 :read =&gt; boolean
}


DeletedPlayerMessage (key will include the player id so I can look this
model up by player)
--------------
array of:
{
 :id =&gt; message\\_id
 :type =&gt; message\\_type
}

I'm definitely optimizing for the recipient, I want to be able to load all
or just unread messages as fast as possible. I will not need to look up a
message and see a list of all recipients.


My idea is that when I load the "inbox", I'll load the PlayerMessage object
for the given player, then separate the read from the unread emails inside
the application. From my quick testing, this works great with relatively
small numbers of messages. I'm capping the stored messages at ~1000, and
the process is nearly instantaneous. When a user deletes a message, I copy
the message hash from the PlayerMessage model to the DeletedMesssage model
for storage. There's a business requirement to store all old emails.

What do you think?

On Fri, Sep 21, 2012 at 5:18 AM, Rune Skou Larsen  wrote:

&gt; The best data model always depends on the structure of data and the
&gt; access pattern. The natural access pattern for your messages is likely
&gt; lookup from two sides: sender and receiver. And you might need to support
&gt; message expiry too. This means that you need on-disk indeces if you want
&gt; more messages than will fit in memory.
&gt;
&gt; In Riak you can do it quite simply with any of the ordered backends
&gt; (leveldb, hanoidb, lowkeydb):
&gt;
&gt; One message = one Riak object. Example: {sender='321', recipient='123',
&gt; timestamp = 1234567, text= 'bla bla'}
&gt; Key is timestamp prefixed.
&gt; 2i indeces for  and .
&gt; Consider using a compound index if you often distinguish between
&gt; read/unread messages. For instance: \\_
&gt;
&gt; Example query returning keys for all unread messages belonging to
&gt; recipient with id 123 using compound index:
&gt; http://myhost:8098/buckets/messages/index/recipient\\_bin/unread\\_123
&gt;
&gt; Example query returning keys for all messages older than a year, so you
&gt; can delete old messages (not necesary using backends with autoexpiry):
&gt; http://myhost:8098/buckets/messages/index/$key/0/2011-09-21
&gt;
&gt;
&gt; Here is an alternative approach: You can choose to optimize for the
&gt; recipient side of the access pattern, by bulking all the messages for a
&gt; given recipient in one Riak object. This is much faster that retrieving a
&gt; large number of messages individually, the price being more difficult
&gt; lookup from the sender side:
&gt; Key: recipient\\_id
&gt; One Riak Object = all messages for a given recipient. Example:
&gt; [{sender='321', timestamp = 1234567, text= 'bla bla'},{sender='456',
&gt; timestamp = 1234569, text= 'bla bla2'}]
&gt; 2i index for s
&gt;
&gt; Example query returning an object with all messages belonging to recipient
&gt; with id 123:
&gt; http://myhost:8098/buckets/messages/keys/123
&gt;
&gt; If you want text search on for instance message content, you should
&gt; consider using Riak Search.
&gt;
&gt; - Rune
&gt;
&gt; Trifork
&gt;
&gt;
&gt; Best regards / Venlig hilsen
&gt; \\*Rune Skou Larsen\\*
&gt; Trifork Public A/S / Team Riak
&gt; Margrethepladsen 4, 8000 Ã…rhus C, Denmark
&gt; Phone: +45 3160 2497 Skype: runeskoularsen twitter: @RuneSkouLarsen
&gt;
&gt;
&gt; On 20-09-2012 01:33, Charlie Bowman wrote:
&gt;
&gt; I'm in the process of designing an in game messaging system that basically
&gt; replicates the same functionality of email all within the context of the
&gt; application. I do not have a ton of experience with true key/value db
&gt; stores so I'm looking to find a good resource for ideas on how to best
&gt; model this. I have a first version, but I dont want to reinvent the wheel
&gt; if can help it. I've done the requisite googling, but haven't found
&gt; anything relevant yet. Are there any guides/tutorials/open source projects
&gt; that anyone knows of.
&gt;
&gt; Thanks!
&gt;
&gt;
&gt;
&gt;
&gt;
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;
&gt;
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

