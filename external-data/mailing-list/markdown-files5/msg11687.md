---
title: "Re: mapreduce timeout"
description: ""
project: community
lastmod: 2013-07-22T09:58:34-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg11687"
mailinglist_parent_id: "msg11526"
author_name: "Deyan Dyankov"
project_section: "mailinglistitem"
sent_date: 2013-07-22T09:58:34-07:00
---


Thanks Christian,

I was able to modify the job code in a similar manner as you suggested and the 
issue is now resolved. However, I'd still like to understand the cause of these 
timeouts and what parameter should be raised, if possible, to mitigate them? 
This particular job was not expected to perform in real time and we were 
willing to wait for it. We may have other such cases in the future..

best regards,
Deyan

On Jul 15, 2013, at 4:49 PM, Christian Dahlqvist  wrote:

&gt; Hi Deyan,
&gt; 
&gt; When running mapreduce jobs, reduce phases often end up being the bottleneck. 
&gt; This is especially true when all input data needs to be gathered on the 
&gt; coordinating node before it can be executed, as is the case if the 
&gt; reduce\\_phase\\_only\\_1 flag is enabled. Having this flag set will cause the 
&gt; mapreduce job to not scale very well.
&gt; 
&gt; Depending on your exact requirements, it may be worthwhile considering 
&gt; gathering the histogram data periodically, e.g. per hour and/or day. These 
&gt; aggregates can then be stored in separate buckets with a key that describes 
&gt; the content, e.g. \\_\\_ . Once this has been done, you can 
&gt; efficiently retrieve a limited number of objects that cover the period you 
&gt; want to get statistics for directly through the descriptive keys, and process 
&gt; these in the application layer. Even though this periodically requires a bit 
&gt; more work, it will most likely be much more efficient at query time and scale 
&gt; better.
&gt; 
&gt; Best regards,
&gt; 
&gt; Christian
&gt; 
&gt; 
&gt; On 14 Jul 2013, at 12:16, Deyan Dyankov  wrote:
&gt; 
&gt;&gt; Hi everyone,
&gt;&gt; 
&gt;&gt; first time here. Thanks in advance.
&gt;&gt; 
&gt;&gt; I am experiencing issues with MapReduce and it seems to timeout after a 
&gt;&gt; certain volume data threshold is reached. The reducer is only one and here 
&gt;&gt; is the mapreduce initiation script:
&gt;&gt; #!/usr/bin/env ruby
&gt;&gt; […]
&gt;&gt; @client = Riak::Client.new(
&gt;&gt; :nodes =&gt; [
&gt;&gt; {:host =&gt; 'db1', :pb\\_port =&gt; 8087, :http\\_port =&gt; 8098},
&gt;&gt; {:host =&gt; 'db2', :pb\\_port =&gt; 8087, :http\\_port =&gt; 8098},
&gt;&gt; {:host =&gt; 'db3', :pb\\_port =&gt; 8087, :http\\_port =&gt; 8098}
&gt;&gt; ],
&gt;&gt; :protocol =&gt; 'pbc'
&gt;&gt; )
&gt;&gt; 
&gt;&gt; start\\_key = "#{cust}:#{setup}:#{start\\_time}"
&gt;&gt; end\\_key = "#{cust}:#{setup}:#{end\\_time}"
&gt;&gt; 
&gt;&gt; result = Riak::MapReduce.new(@client).
&gt;&gt; index(bucket\\_name, index\\_name, start\\_key..end\\_key).
&gt;&gt; map('map95th').
&gt;&gt; reduce('reduce95th', :arg =&gt; { 'reduce\\_phase\\_only\\_1' =&gt; true }, :keep =&gt; 
&gt;&gt; true).
&gt;&gt; run()
&gt;&gt; 
&gt;&gt; puts result
&gt;&gt; 
&gt;&gt; The following is the code for the map95th and reduce95th javascript 
&gt;&gt; functions:
&gt;&gt; function map95th(v, keyData, arg) {
&gt;&gt; var key\\_elements = v['key'].split(':');
&gt;&gt; var cust = key\\_elements[0];
&gt;&gt; var setup = key\\_elements[1];
&gt;&gt; var sid = key\\_elements[2];
&gt;&gt; var ts = key\\_elements[3];
&gt;&gt; 
&gt;&gt; var result\\_key = cust + ':' + setup + ':' + ts;
&gt;&gt; var obj = {}
&gt;&gt; var obj\\_data = Riak.mapValuesJson(v)[0];
&gt;&gt; 
&gt;&gt; obj\\_data['bps'] = (obj\\_data['rx\\_bytes'] + obj\\_data['tx\\_bytes']) / 60;
&gt;&gt; return\\_val = obj\\_data['bps'];
&gt;&gt; return [ return\\_val ];
&gt;&gt; }
&gt;&gt; 
&gt;&gt; // if used, this must be a single reducer! Call from Ruby like this:
&gt;&gt; // reduce('reduce95th', :arg =&gt; { 'reduce\\_phase\\_only\\_1' =&gt; true }, :keep =&gt; 
&gt;&gt; true).
&gt;&gt; function reduce95th(values) {
&gt;&gt; var sorted = values.sort(function(a,b) { return a - b; });
&gt;&gt; var pct = sorted.length / 100;
&gt;&gt; var element\\_95th = pct \\* 95;
&gt;&gt; element\\_95th = parseInt(element\\_95th, 10) + 1;
&gt;&gt; 
&gt;&gt; return [ sorted[element\\_95th] ];
&gt;&gt; }
&gt;&gt; 
&gt;&gt; 
&gt;&gt; 
&gt;&gt; Now here is the interesting part. The MR goes through one record per minute. 
&gt;&gt; If I run it for a period of less than ~20 days, it executes. Otherwise, it 
&gt;&gt; times out:
&gt;&gt; [deyandyankov@azobook ~/repos/loshko/mapreduce/ruby (master)]$
&gt;&gt; [deyandyankov@azobook ~/repos/loshko/mapreduce/ruby (master)]$ ./95h.rb 
&gt;&gt; yellingtone default $((`date +%s` - 20 \\* 86400)) `date +%s`
&gt;&gt; 125581.51666666666
&gt;&gt; [deyandyankov@azobook ~/repos/loshko/mapreduce/ruby (master)]$ ./95h.rb 
&gt;&gt; yellingtone default $((`date +%s` - 30 \\* 86400)) `date +%s`
&gt;&gt; /Users/deyandyankov/.rvm/gems/ruby-1.9.3-p392/gems/riak-client-1.1.1/lib/riak/client/beefcake\\_protobuffs\\_backend.rb:182:in
&gt;&gt; `decode\\_response': Expected success from Riak but received 0. 
&gt;&gt; {"phase":1,"error":"timeout","input":null,"type":null,"stack":null} 
&gt;&gt; (Riak::ProtobuffsFailedRequest)
&gt;&gt; from 
&gt;&gt; /Users/deyandyankov/.rvm/gems/ruby-1.9.3-p392/gems/riak-client-1.1.1/lib/riak/client/beefcake\\_protobuffs\\_backend.rb:116:in
&gt;&gt; `mapred'
&gt;&gt; from 
&gt;&gt; /Users/deyandyankov/.rvm/gems/ruby-1.9.3-p392/gems/riak-client-1.1.1/lib/riak/client.rb:325:in
&gt;&gt; `block in mapred'
&gt;&gt; from 
&gt;&gt; /Users/deyandyankov/.rvm/gems/ruby-1.9.3-p392/gems/riak-client-1.1.1/lib/riak/client.rb:435:in
&gt;&gt; `block in recover\\_from'
&gt;&gt; from 
&gt;&gt; /Users/deyandyankov/.rvm/gems/ruby-1.9.3-p392/gems/innertube-1.0.2/lib/innertube.rb:127:in
&gt;&gt; `take'
&gt;&gt; from 
&gt;&gt; /Users/deyandyankov/.rvm/gems/ruby-1.9.3-p392/gems/riak-client-1.1.1/lib/riak/client.rb:433:in
&gt;&gt; `recover\\_from'
&gt;&gt; from 
&gt;&gt; /Users/deyandyankov/.rvm/gems/ruby-1.9.3-p392/gems/riak-client-1.1.1/lib/riak/client.rb:379:in
&gt;&gt; `protobuffs'
&gt;&gt; from 
&gt;&gt; /Users/deyandyankov/.rvm/gems/ruby-1.9.3-p392/gems/riak-client-1.1.1/lib/riak/client.rb:133:in
&gt;&gt; `backend'
&gt;&gt; from 
&gt;&gt; /Users/deyandyankov/.rvm/gems/ruby-1.9.3-p392/gems/riak-client-1.1.1/lib/riak/client.rb:324:in
&gt;&gt; `mapred'
&gt;&gt; from 
&gt;&gt; /Users/deyandyankov/.rvm/gems/ruby-1.9.3-p392/gems/riak-client-1.1.1/lib/riak/map\\_reduce.rb:217:in
&gt;&gt; `run'
&gt;&gt; from ./95h.rb:29:in `'
&gt;&gt; [deyandyankov@azobook ~/repos/loshko/mapreduce/ruby (master)]$
&gt;&gt; 
&gt;&gt; The records being processed look lie this:
&gt;&gt; {"rx\\_bytes":3485395.0,"tx\\_bytes":1658479.0}
&gt;&gt; 
&gt;&gt; When running the script with more than 20 days worth of data (two records 
&gt;&gt; per minute are processed, which amounts to 2 \\* 60 \\* 24 \\* 20 = more than 
&gt;&gt; 57,600 processed), the script times out and here are some things from the 
&gt;&gt; logs:
&gt;&gt; ==&gt; /var/log/riak/erlang.log.1 &lt;==
&gt;&gt; Erlang has closed
&gt;&gt; 
&gt;&gt; ==&gt; /var/log/riak/error.log &lt;==
&gt;&gt; 2013-07-14 13:03:51.580 [error] &lt;0.709.0&gt;@riak\\_pipe\\_vnode:new\\_worker:768 
&gt;&gt; Pipe worker startup failed:fitting was gone before startup
&gt;&gt; 
&gt;&gt; ==&gt; /var/log/riak/console.log &lt;==
&gt;&gt; 2013-07-14 13:03:51.584 [error] &lt;0.22049.4326&gt; gen\\_fsm &lt;0.22049.4326&gt; in 
&gt;&gt; state wait\\_for\\_input terminated with reason: timeout
&gt;&gt; 
&gt;&gt; ==&gt; /var/log/riak/error.log &lt;==
&gt;&gt; 2013-07-14 13:03:51.584 [error] &lt;0.22049.4326&gt; gen\\_fsm &lt;0.22049.4326&gt; in 
&gt;&gt; state wait\\_for\\_input terminated with reason: timeout
&gt;&gt; 
&gt;&gt; ==&gt; /var/log/riak/console.log &lt;==
&gt;&gt; 2013-07-14 13:03:51.940 [error] &lt;0.22049.4326&gt; CRASH REPORT Process 
&gt;&gt; &lt;0.22049.4326&gt; with 0 neighbours exited with reason: timeout in 
&gt;&gt; gen\\_fsm:terminate/7 line 611
&gt;&gt; 
&gt;&gt; ==&gt; /var/log/riak/crash.log &lt;==
&gt;&gt; 2013-07-14 13:03:51 =CRASH REPORT====
&gt;&gt; crasher:
&gt;&gt; initial call: riak\\_pipe\\_vnode\\_worker:init/1
&gt;&gt; pid: &lt;0.22049.4326&gt;
&gt;&gt; registered\\_name: []
&gt;&gt; exception exit: 
&gt;&gt; {timeout,[{gen\\_fsm,terminate,7,[{file,"gen\\_fsm.erl"},{line,611}]},{proc\\_lib,init\\_p\\_do\\_apply,3,[{file,"proc\\_lib.erl"},{line,227}]}]}
&gt;&gt; ancestors: 
&gt;&gt; [&lt;0.710.0&gt;,&lt;0.709.0&gt;,riak\\_core\\_vnode\\_sup,riak\\_core\\_sup,&lt;0.129.0&gt;]
&gt;&gt; messages: []
&gt;&gt; links: [&lt;0.710.0&gt;,&lt;0.709.0&gt;]
&gt;&gt; dictionary: 
&gt;&gt; [{eunit,[{module,riak\\_pipe\\_vnode\\_worker},{partition,388211372416021087647853783690262677096107081728},{&lt;0.709.0&gt;,&lt;0.709.0&gt;},{details,{fitting\\_details,{fitting,&lt;18125.23420.4566&gt;,#Ref&lt;18125.0.5432.50467&gt;,&lt;&lt;"C�������������������"&gt;&gt;,1},1,riak\\_kv\\_w\\_reduce,{rct,#Fun,{struct,[{&lt;&lt;"reduce\\_phase\\_only\\_1"&gt;&gt;,true}]}},{fitting,&lt;18125.23418.4566&gt;,#Ref&lt;18125.0.5432.50467&gt;,sink,undefined},[{log,sink},{trace,[error]},{sink,{fitting,&lt;18125.23418.4566&gt;,#Ref&lt;18125.0.5432.50467&gt;,sink,undefined}},{sink\\_type,{fsm,10,infinity}}],64}}]}]
&gt;&gt; trap\\_exit: false
&gt;&gt; status: running
&gt;&gt; heap\\_size: 832040
&gt;&gt; stack\\_size: 24
&gt;&gt; reductions: 1456611
&gt;&gt; neighbours:
&gt;&gt; 
&gt;&gt; ==&gt; /var/log/riak/error.log &lt;==
&gt;&gt; 2013-07-14 13:03:51.940 [error] &lt;0.22049.4326&gt; CRASH REPORT Process 
&gt;&gt; &lt;0.22049.4326&gt; with 0 neighbours exited with reason: timeout in 
&gt;&gt; gen\\_fsm:terminate/7 line 611
&gt;&gt; 
&gt;&gt; ==&gt; /var/log/riak/crash.log &lt;==
&gt;&gt; 2013-07-14 13:03:52 =SUPERVISOR REPORT====
&gt;&gt; Supervisor: {&lt;0.710.0&gt;,riak\\_pipe\\_vnode\\_worker\\_sup}
&gt;&gt; Context: child\\_terminated
&gt;&gt; Reason: timeout
&gt;&gt; Offender: 
&gt;&gt; [{pid,&lt;0.22049.4326&gt;},{name,undefined},{mfargs,{riak\\_pipe\\_vnode\\_worker,start\\_link,undefined}},{restart\\_type,temporary},{shutdown,2000},{child\\_type,worker}]
&gt;&gt; 
&gt;&gt; 
&gt;&gt; ==&gt; /var/log/riak/console.log &lt;==
&gt;&gt; 2013-07-14 13:03:52.059 [error] &lt;0.710.0&gt; Supervisor 
&gt;&gt; riak\\_pipe\\_vnode\\_worker\\_sup had child undefined started with 
&gt;&gt; {riak\\_pipe\\_vnode\\_worker,start\\_link,undefined} at &lt;0.22049.4326&gt; exit with 
&gt;&gt; reason timeout in context child\\_terminated
&gt;&gt; 
&gt;&gt; ==&gt; /var/log/riak/error.log &lt;==
&gt;&gt; 2013-07-14 13:03:52.059 [error] &lt;0.710.0&gt; Supervisor 
&gt;&gt; riak\\_pipe\\_vnode\\_worker\\_sup had child undefined started with 
&gt;&gt; {riak\\_pipe\\_vnode\\_worker,start\\_link,undefined} at &lt;0.22049.4326&gt; exit with 
&gt;&gt; reason timeout in context child\\_terminated
&gt;&gt; 
&gt;&gt; 
&gt;&gt; The data is in leveldb and is accessed through secondary indexes. 
&gt;&gt; This is a 3 node cluster with 32GB ram, current usage is about 12G per node. 
&gt;&gt; n\\_val=3. The same issues occurs on a similar 2 node cluster with 8GB of ram 
&gt;&gt; (usage is ~6G).
&gt;&gt; 
&gt;&gt; The following is my app.config:
&gt;&gt; [
&gt;&gt; {riak\\_api, [
&gt;&gt; {pb\\_ip, "0.0.0.0" },
&gt;&gt; {pb\\_port, 8087 },
&gt;&gt; {pb\\_backlog, 100 }
&gt;&gt; ]},
&gt;&gt; {riak\\_core, [
&gt;&gt; {default\\_bucket\\_props, [
&gt;&gt; {n\\_val, 3},
&gt;&gt; {last\\_write\\_wins, true}
&gt;&gt; ]},
&gt;&gt; {ring\\_state\\_dir, "/storage/riak/ring"},
&gt;&gt; {ring\\_creation\\_size, 256},
&gt;&gt; {http, [ {"0.0.0.0", 8098 } ]},
&gt;&gt; {https, [{ "0.0.0.0", 8069 }]},
&gt;&gt; {ssl, [
&gt;&gt; {certfile, "/etc/ssl/riak/server.crt"},
&gt;&gt; {cacertfile, "/etc/ssl/riak/root.crt"},
&gt;&gt; {keyfile, "/etc/ssl/riak/server.key"}
&gt;&gt; ]},
&gt;&gt; {handoff\\_port, 8099 },
&gt;&gt; {dtrace\\_support, false},
&gt;&gt; {enable\\_health\\_checks, true},
&gt;&gt; {platform\\_bin\\_dir, "/usr/sbin"},
&gt;&gt; {platform\\_data\\_dir, "/storage/riak"},
&gt;&gt; {platform\\_etc\\_dir, "/etc/riak"},
&gt;&gt; {platform\\_lib\\_dir, "/usr/lib/riak/lib"},
&gt;&gt; {platform\\_log\\_dir, "/var/log/riak"}
&gt;&gt; ]},
&gt;&gt; {riak\\_kv, [
&gt;&gt; {storage\\_backend, riak\\_kv\\_eleveldb\\_backend},
&gt;&gt; {anti\\_entropy, {on, []}},
&gt;&gt; {anti\\_entropy\\_build\\_limit, {1, 3600000}},
&gt;&gt; {anti\\_entropy\\_expire, 604800000},
&gt;&gt; {anti\\_entropy\\_concurrency, 2},
&gt;&gt; {anti\\_entropy\\_tick, 15000},
&gt;&gt; {anti\\_entropy\\_data\\_dir, "/storage/riak/anti\\_entropy"},
&gt;&gt; {anti\\_entropy\\_leveldb\\_opts, [{write\\_buffer\\_size, 4194304},
&gt;&gt; {max\\_open\\_files, 20}]},
&gt;&gt; 
&gt;&gt; {mapred\\_name, "mapred"},
&gt;&gt; {mapred\\_2i\\_pipe, true},
&gt;&gt; {map\\_js\\_vm\\_count, 16 },
&gt;&gt; {reduce\\_js\\_vm\\_count, 12 },
&gt;&gt; {hook\\_js\\_vm\\_count, 20 },
&gt;&gt; {js\\_max\\_vm\\_mem, 8},
&gt;&gt; {js\\_thread\\_stack, 16},
&gt;&gt; {js\\_source\\_dir, "/etc/riak/mapreduce/js\\_source"},
&gt;&gt; {http\\_url\\_encoding, on},
&gt;&gt; {vnode\\_vclocks, true},
&gt;&gt; {listkeys\\_backpressure, true},
&gt;&gt; {vnode\\_mailbox\\_limit, {1, 5000}}
&gt;&gt; ]},
&gt;&gt; 
&gt;&gt; {riak\\_search, [
&gt;&gt; {enabled, true}
&gt;&gt; ]},
&gt;&gt; 
&gt;&gt; {merge\\_index, [
&gt;&gt; {data\\_root, "/storage/riak/merge\\_index"},
&gt;&gt; {buffer\\_rollover\\_size, 1048576},
&gt;&gt; {max\\_compact\\_segments, 20}
&gt;&gt; ]},
&gt;&gt; 
&gt;&gt; {bitcask, [
&gt;&gt; {data\\_root, "/storage/riak/bitcask"}
&gt;&gt; ]},
&gt;&gt; 
&gt;&gt; {eleveldb, [
&gt;&gt; {cache\\_size, 1024},
&gt;&gt; {max\\_open\\_files, 64},
&gt;&gt; {data\\_root, "/storage/riak/leveldb"}
&gt;&gt; ]},
&gt;&gt; 
&gt;&gt; {lager, [
&gt;&gt; {handlers, [
&gt;&gt; {lager\\_file\\_backend, [
&gt;&gt; {"/var/log/riak/error.log", error, 10485760, 
&gt;&gt; "$D0", 5},
&gt;&gt; {"/var/log/riak/console.log", info, 10485760, 
&gt;&gt; "$D0", 5}
&gt;&gt; ]}
&gt;&gt; ] },
&gt;&gt; 
&gt;&gt; {crash\\_log, "/var/log/riak/crash.log"},
&gt;&gt; {crash\\_log\\_msg\\_size, 65536},
&gt;&gt; {crash\\_log\\_size, 10485760},
&gt;&gt; {crash\\_log\\_date, "$D0"},
&gt;&gt; {crash\\_log\\_count, 5},
&gt;&gt; {error\\_logger\\_redirect, true}
&gt;&gt; ]},
&gt;&gt; 
&gt;&gt; {riak\\_sysmon, [
&gt;&gt; {process\\_limit, 30},
&gt;&gt; {port\\_limit, 2},
&gt;&gt; {gc\\_ms\\_limit, 0},
&gt;&gt; {heap\\_word\\_limit, 40111000},
&gt;&gt; {busy\\_port, true},
&gt;&gt; {busy\\_dist\\_port, true}
&gt;&gt; ]},
&gt;&gt; 
&gt;&gt; {sasl, [
&gt;&gt; {sasl\\_error\\_logger, false}
&gt;&gt; ]},
&gt;&gt; 
&gt;&gt; Sorry to bug you with such a long e-mail but I wanted to be as thorough as 
&gt;&gt; possible. I tried raising a few options but it didn't help: map\\_js\\_vm\\_count, 
&gt;&gt; reduce\\_js\\_vm\\_count, js\\_max\\_vm\\_mem
&gt;&gt; I also tried adding a timeout argument to the map reduce caller code but 
&gt;&gt; even if I set it to 60,000 or more (this is milliseconds), the script is 
&gt;&gt; terminating with timeout error after 10-12 secs. The same behaviour is 
&gt;&gt; observed if I use http instead of pbc.
&gt;&gt; 
&gt;&gt; What seems to be the problem? Is this a matter of configuration? I am 
&gt;&gt; surprised about the fact that the job runs with 20-25 days of data and not 
&gt;&gt; more.
&gt;&gt; 
&gt;&gt; thank you for your efforts,
&gt;&gt; Deyan
&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt; 

\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

