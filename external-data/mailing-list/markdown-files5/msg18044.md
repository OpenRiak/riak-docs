---
title: "Re: Leveled - Another Erlang Key-Value store"
description: ""
project: community
lastmod: 2017-02-28T09:29:52-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg18044"
mailinglist_parent_id: "msg18043"
author_name: "Martin Sumner"
project_section: "mailinglistitem"
sent_date: 2017-02-28T09:29:52-08:00
---


For original testing in isolation I used this:

https://github.com/martinsumner/leveled/blob/master/test/volume/single\\_node/src/basho\\_bench\\_driver\\_eleveleddb.erl

But I've focused on testing since within Riak using the standard
basho\\_bench/examples/riakc\\_pb.config test

Testing of secondary indexing is one of the next big things for me,
definitely going to do this in March. From a development perspective doing
clones/snapshots was a lot easier than it presumably is in C++. I'm unsure
about how performance will compare, as 2i terms do end up clumped together
on disk in leveldb and I know MVM has done a lot of optimisation work in
that area.

Some things that may help leveled are: there's no overlapping files in
level 1; the levels don't increase in depth as rapidly. However, there are
some issues (https://github.com/martinsumner/leveled/issues/34) that I may
still need to contend with.

I think there may be some interesting possibilities with Map functions
based on HEAD not GET requests. So perhaps as a developer I could add a
bitmap index to my object metadata, and roll across those bitmaps
efficiently through a Map function now that I wouldn't need to pull the
whole object off disk to achieve that. So the concept of division between
Metadata and Value may open up efficient query ideas beyond 2i


On 28 February 2017 at 17:14, DeadZen  wrote:

&gt; Yup I get it, I like the concept and the fun naming of inkers, pencillers
&gt; and clerks as well. Is there a basho bench configuration? This reminds me a
&gt; bit if fractal trees but with a focus on NoSQL operational semantics, how
&gt; else do you see this adding improvements? It seems index requests could be
&gt; cheaper with this backend configuration.
&gt;
&gt; On Tue, Feb 28, 2017 at 12:07 PM Martin Sumner &lt;
&gt; martin.sum...@adaptip.co.uk&gt; wrote:
&gt;
&gt;&gt; Have a look in https://github.com/martinsumner/leveled/blob/
&gt;&gt; master/docs/FUTURE.md and the "Riak Features Implemented"
&gt;&gt;
&gt;&gt; I'm trying to avoid the need for Riak to Get n times for every request
&gt;&gt; (both a KV GET and a KV PUT), when really it only needs the body once, and
&gt;&gt; the n-1 times it doesn't need the body if the HEAD response confirms that
&gt;&gt; the vector clock is at the expected state. As values get larger there's a
&gt;&gt; lot of unnecessary disk activity in those GETs.
&gt;&gt;
&gt;&gt; To understand all the Journal/Inker stuff have a look at
&gt;&gt; https://github.com/martinsumner/leveled/blob/master/docs/DESIGN.md
&gt;&gt;
&gt;&gt; The Inker is an actor that controls the Journal - the Journal is a
&gt;&gt; transaction log where all the values are stored permanently, made up of a
&gt;&gt; series of CDB files where everything is ordered by sequence number. The
&gt;&gt; Keys and Metadata are stored in a merge tree called the Ledger - and the
&gt;&gt; Ledger is controlled by an actor called the Penciller. So the HEAD request
&gt;&gt; should just need to check in the Ledger via the Penciller. A GET request
&gt;&gt; must follow that same path, and then once it has the metadata, it has the
&gt;&gt; sequence number and so can use that to fetch the value from the Journal via
&gt;&gt; the Inker.
&gt;&gt;
&gt;&gt; Does this make sense?
&gt;&gt;
&gt;&gt; My apologies, as the naming may not be helpful. Perhaps one of the
&gt;&gt; drawbacks of working in isolation on this.
&gt;&gt;
&gt;&gt; Thanks
&gt;&gt;
&gt;&gt; Martin
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt; On 28 February 2017 at 16:51, DeadZen  wrote:
&gt;&gt;
&gt;&gt; Cheers indeed!
&gt;&gt; You added HEAD requests so a full GET wouldn't always be required?
&gt;&gt; Did I read that right? \\*dives into code\\*
&gt;&gt; %% GET requests first follow the path of a HEAD request, and if an object
&gt;&gt; is
&gt;&gt; %% found, then fetch the value from the Journal via the Inker.
&gt;&gt; ... WHAT?
&gt;&gt;
&gt;&gt; Very nice work, will be more than happy to provide feedback and patches
&gt;&gt; on this.
&gt;&gt;
&gt;&gt; On Tue, Feb 28, 2017 at 9:04 AM, Martin Sumner
&gt;&gt;  wrote:
&gt;&gt; &gt;
&gt;&gt; &gt; Over the past few months I've been working on an alternative pure-Erlang
&gt;&gt; &gt; Key/Value store to act as a backend to Riak KV. This is now open
&gt;&gt; source and
&gt;&gt; &gt; available at
&gt;&gt; &gt;
&gt;&gt; &gt; https://github.com/martinsumner/leveled
&gt;&gt; &gt;
&gt;&gt; &gt; The store is a work-in-progress prototype, originally started to better
&gt;&gt; &gt; understand the impact of different trade-offs in LSM-Tree design. The
&gt;&gt; aim
&gt;&gt; &gt; is to:
&gt;&gt; &gt;
&gt;&gt; &gt; - provide a fully-featured Riak backend (e.g. secondary index, object
&gt;&gt; expiry
&gt;&gt; &gt; support etc)
&gt;&gt; &gt; - provide stable throughput with larger object sizes (&gt; 4KB)
&gt;&gt; &gt; - provide a simpler and more flexible path to making Riak KV changes
&gt;&gt; &gt; end-to-end
&gt;&gt; &gt;
&gt;&gt; &gt; The prime change in the store when compared to HanoiDB or eleveldb is
&gt;&gt; that
&gt;&gt; &gt; storage is split with only Keys & Metadata being placed in the merge
&gt;&gt; tree,
&gt;&gt; &gt; and the full object living to the side in a series of CDB-based
&gt;&gt; journals.
&gt;&gt; &gt; The intention of this is to:
&gt;&gt; &gt;
&gt;&gt; &gt; - reduce write amplification and ease page-cache pollution issues on
&gt;&gt; &gt; scanning events.
&gt;&gt; &gt; - support faster HEAD requests than GET requests, and in parallel an
&gt;&gt; &gt; alternative Riak KV branch has been produced to move from an n-GET
&gt;&gt; model to
&gt;&gt; &gt; a n-HEAD 1-GET model of fetching data for both KV GET and KV PUT
&gt;&gt; operations
&gt;&gt; &gt;
&gt;&gt; &gt; The impact of this has been to improve throughput for larger object
&gt;&gt; sizes
&gt;&gt; &gt; where disk I/O and not CPU is the current limit on throughput. The
&gt;&gt; &gt; advantage increases the greater the object size, and the tighter the
&gt;&gt; &gt; constraint on disk.
&gt;&gt; &gt;
&gt;&gt; &gt; Please visit the github page, I've tried to write up as much about the
&gt;&gt; &gt; project as I can. There's the results of various volume tests,
&gt;&gt; information
&gt;&gt; &gt; on the research which prompted the design, an overview of the design
&gt;&gt; itself
&gt;&gt; &gt; and some hints as to what I expect to try next with leveled.
&gt;&gt; &gt;
&gt;&gt; &gt; Any feedback, please mail me, raise an issue on github, or ping me
&gt;&gt; @masleeds
&gt;&gt; &gt;
&gt;&gt; &gt; Cheers
&gt;&gt; &gt;
&gt;&gt; &gt; Martin
&gt;&gt; &gt;
&gt;&gt; &gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt; &gt; riak-users mailing list
&gt;&gt; &gt; riak-users@lists.basho.com
&gt;&gt; &gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt; &gt;
&gt;&gt;
&gt;&gt;
&gt;&gt;
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

