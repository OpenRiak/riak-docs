---
title: "Re: How to increase Riak write performance for sequential	alpha-numeric keys"
description: ""
project: community
lastmod: 2016-05-05T17:00:45-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg17302"
mailinglist_parent_id: "msg17296"
author_name: "Matthew Von-Maszewski"
project_section: "mailinglistitem"
sent_date: 2016-05-05T17:00:45-07:00
---


Alex,

I am making a guess. I would be better able to support this guess with data 
from leveldb LOG files of one server.

The performance difference between the sequential keys and the reverse of the 
sequential keys is informative. The reverse ordered keys essentially become 
more like "random keys" within the leveldb key space. Overtime, they disperse 
to different .sst table files scattering the "focal point" of the 
read-before-write operations. The sequential keys are keeping all newly 
written data within the same .sst table file, i.e. the same "focal point".

And there is a new tuning called "timed grooming" in the Riak 2.1.3 and 2.1.4 
releases that has a bug. The bug can cause more frequent compaction cycles 
than intended for 2.1.3 and 2.1.4 under some work loads. Your particular 
sequential keys might be such a load. This is what the LOG files would 
indicate. The biggest impact of more frequent compaction cycles is that the 
Linux page cache and leveldb block caches get invalidated more often causing 
longer read cycles to determine "nothing is there" in the read-before-write 
operation of Riak.

Your higher ring size is likely not helping, but there is math that can prove 
or disprove this assumption. And again, the base numbers are within the LOG 
files.

We do have an eleveldb patch release available. You would have to manual 
install it on each of the nodes. The patch disables the timed grooming and 
contains some critical bug fixes that lead to the Riak 2.1.4 release. You 
would need to tell me which operating system package you originally download 
for Riak, then I can send an appropriate link.

Matthew


&gt; On May 5, 2016, at 10:11 AM, alexc155  wrote:
&gt; 
&gt; Hi,
&gt; 
&gt; Thanks for your reply.
&gt; 
&gt; I don't think that write\\_once is going to work for us as we have to
&gt; periodically update the data (although if we remove the data before
&gt; re-inserting it, would that work?)
&gt; 
&gt; Why does read-before-write slow down new writes so much?
&gt; 
&gt; Some new information we've found - it seems that if we write the data and
&gt; then update it, we get fast speeds too. It's just the initial write of the
&gt; data that is slow.
&gt; 
&gt; So why is writing sequential keys so much slower than updating them or
&gt; writing non-sequential keys?
&gt; 
&gt; 
&gt; 
&gt; --
&gt; View this message in context: 
&gt; http://riak-users.197444.n3.nabble.com/How-to-increase-Riak-write-performance-for-sequential-alpha-numeric-keys-tp4034219p4034225.html
&gt; Sent from the Riak Users mailing list archive at Nabble.com.
&gt; 
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com


\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

