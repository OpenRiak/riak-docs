---
title: "Re: Leveled - Another Erlang Key-Value store"
description: ""
project: community
lastmod: 2017-02-28T09:15:56-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg18043"
mailinglist_parent_id: "msg18042"
author_name: "DeadZen"
project_section: "mailinglistitem"
sent_date: 2017-02-28T09:15:56-08:00
---


Yup I get it, I like the concept and the fun naming of inkers, pencillers
and clerks as well. Is there a basho bench configuration? This reminds me a
bit if fractal trees but with a focus on NoSQL operational semantics, how
else do you see this adding improvements? It seems index requests could be
cheaper with this backend configuration.

On Tue, Feb 28, 2017 at 12:07 PM Martin Sumner 
wrote:

&gt; Have a look in
&gt; https://github.com/martinsumner/leveled/blob/master/docs/FUTURE.md and
&gt; the "Riak Features Implemented"
&gt;
&gt; I'm trying to avoid the need for Riak to Get n times for every request
&gt; (both a KV GET and a KV PUT), when really it only needs the body once, and
&gt; the n-1 times it doesn't need the body if the HEAD response confirms that
&gt; the vector clock is at the expected state. As values get larger there's a
&gt; lot of unnecessary disk activity in those GETs.
&gt;
&gt; To understand all the Journal/Inker stuff have a look at
&gt; https://github.com/martinsumner/leveled/blob/master/docs/DESIGN.md
&gt;
&gt; The Inker is an actor that controls the Journal - the Journal is a
&gt; transaction log where all the values are stored permanently, made up of a
&gt; series of CDB files where everything is ordered by sequence number. The
&gt; Keys and Metadata are stored in a merge tree called the Ledger - and the
&gt; Ledger is controlled by an actor called the Penciller. So the HEAD request
&gt; should just need to check in the Ledger via the Penciller. A GET request
&gt; must follow that same path, and then once it has the metadata, it has the
&gt; sequence number and so can use that to fetch the value from the Journal via
&gt; the Inker.
&gt;
&gt; Does this make sense?
&gt;
&gt; My apologies, as the naming may not be helpful. Perhaps one of the
&gt; drawbacks of working in isolation on this.
&gt;
&gt; Thanks
&gt;
&gt; Martin
&gt;
&gt;
&gt;
&gt;
&gt; On 28 February 2017 at 16:51, DeadZen  wrote:
&gt;
&gt; Cheers indeed!
&gt; You added HEAD requests so a full GET wouldn't always be required?
&gt; Did I read that right? \\*dives into code\\*
&gt; %% GET requests first follow the path of a HEAD request, and if an object
&gt; is
&gt; %% found, then fetch the value from the Journal via the Inker.
&gt; ... WHAT?
&gt;
&gt; Very nice work, will be more than happy to provide feedback and patches on
&gt; this.
&gt;
&gt; On Tue, Feb 28, 2017 at 9:04 AM, Martin Sumner
&gt;  wrote:
&gt; &gt;
&gt; &gt; Over the past few months I've been working on an alternative pure-Erlang
&gt; &gt; Key/Value store to act as a backend to Riak KV. This is now open source
&gt; and
&gt; &gt; available at
&gt; &gt;
&gt; &gt; https://github.com/martinsumner/leveled
&gt; &gt;
&gt; &gt; The store is a work-in-progress prototype, originally started to better
&gt; &gt; understand the impact of different trade-offs in LSM-Tree design. The
&gt; aim
&gt; &gt; is to:
&gt; &gt;
&gt; &gt; - provide a fully-featured Riak backend (e.g. secondary index, object
&gt; expiry
&gt; &gt; support etc)
&gt; &gt; - provide stable throughput with larger object sizes (&gt; 4KB)
&gt; &gt; - provide a simpler and more flexible path to making Riak KV changes
&gt; &gt; end-to-end
&gt; &gt;
&gt; &gt; The prime change in the store when compared to HanoiDB or eleveldb is
&gt; that
&gt; &gt; storage is split with only Keys & Metadata being placed in the merge
&gt; tree,
&gt; &gt; and the full object living to the side in a series of CDB-based journals.
&gt; &gt; The intention of this is to:
&gt; &gt;
&gt; &gt; - reduce write amplification and ease page-cache pollution issues on
&gt; &gt; scanning events.
&gt; &gt; - support faster HEAD requests than GET requests, and in parallel an
&gt; &gt; alternative Riak KV branch has been produced to move from an n-GET model
&gt; to
&gt; &gt; a n-HEAD 1-GET model of fetching data for both KV GET and KV PUT
&gt; operations
&gt; &gt;
&gt; &gt; The impact of this has been to improve throughput for larger object sizes
&gt; &gt; where disk I/O and not CPU is the current limit on throughput. The
&gt; &gt; advantage increases the greater the object size, and the tighter the
&gt; &gt; constraint on disk.
&gt; &gt;
&gt; &gt; Please visit the github page, I've tried to write up as much about the
&gt; &gt; project as I can. There's the results of various volume tests,
&gt; information
&gt; &gt; on the research which prompted the design, an overview of the design
&gt; itself
&gt; &gt; and some hints as to what I expect to try next with leveled.
&gt; &gt;
&gt; &gt; Any feedback, please mail me, raise an issue on github, or ping me
&gt; @masleeds
&gt; &gt;
&gt; &gt; Cheers
&gt; &gt;
&gt; &gt; Martin
&gt; &gt;
&gt; &gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; &gt; riak-users mailing list
&gt; &gt; riak-users@lists.basho.com
&gt; &gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt; &gt;
&gt;
&gt;
&gt;
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

