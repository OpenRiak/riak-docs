---
title: "Atomicity of if_not_modified?"
description: ""
project: community
lastmod: 2012-12-28T04:04:12-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg09690"
author_name: "qaspar"
project_section: "mailinglistitem"
sent_date: 2012-12-28T04:04:12-08:00
---


Hello,

Say I have N=3, R=2 and W=2, and two clients are simultaneously trying to
update the same object with if\\_not\\_modified=true. Is there a possible
scenario where both clients can succeed? If not and if at most one client
succeeds then setting if\\_not\\_modified=true would be a way to atomically lock
an object, right?

If this is correct then there's an additional problem: Assume the following
happens when three processes try to update the same object simultaneously,
with A/B/C being our three primary nodes for the object:
1. Process P1 updates A
2. Process P2 updates B
3. Process P3 updates C

Now any attempt for any of the processes to write to a second primary node
(W=2) will fail because the node has been modified (as
if\\_not\\_modified=true). Therefore, all three process will fail, which is fair
enough. But the problem is now that we have three different 'stale' copies
of the object already written to A, B and C. The next time a process wants
to read the object (with R=2) Riak will find three different objects (or
rather, three different vector clocks), so the read will fail, thus
rendering the object 'unreadable', so I can't even use read-repair. Is my
interpretation correct, and how can I work around this?

Kaspar




--
View this message in context: 
http://riak-users.197444.n3.nabble.com/Atomicity-of-if-not-modified-tp4026430.html
Sent from the Riak Users mailing list archive at Nabble.com.

\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

