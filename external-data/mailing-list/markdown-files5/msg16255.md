---
title: "Bitcask expiration issue"
description: ""
project: community
lastmod: 2015-06-19T04:42:31-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg16255"
mailinglist_parent_id: "msg16249"
author_name: "Damien Krotkine"
project_section: "mailinglistitem"
sent_date: 2015-06-19T04:42:31-07:00
---


Hi,

[ this is a possible duplicate, but it seems that messages sent by my
other email account (damien.krotk...@booking.com don't reach list
recipients - if I'm wrong, let me know - so I'm sending it again with
this address ]

I'm seeing strange things with bitcask expiration: When a new node joins 
a Ring, it gets data from the other nodes to rebalance. It seems that 
the starting date to count expiration of this data is the time when they 
were copied to the new node, \\*not\\* the date they were originally created 
in the Ring

For instance, on a Ring with 2 weeks expiration:
I write 1 key at T=0 in a Ring with 3 nodes.
At T+7days I add a new node 4. This node gets the ownership of the key.
It seems that this key will expire on node 4 only at T+21 instead of
T+14

That's annoying because we have a lot of data that is constantly being 
written and that \\*must\\* be expired at proper time.
Here is a graph (warning, it shows the free disk space, not the disk 
space used) of data expiration when adding new nodes.

https://www.dropbox.com/s/1od5xo5wxsvk11j/render\\_1.png?dl=0

Is it a wrong configuration ? Here is my bitcask expiration
configuration:

multi\\_backend.bitcask\\_mult\\_events.storage\\_backend = bitcask
multi\\_backend.bitcask\\_mult\\_events.bitcask.data\\_root = 
/var/lib/riak/bitcask\\_mult\\_events
multi\\_backend.bitcask\\_mult\\_events.bitcask.expiry = 8d
multi\\_backend.bitcask\\_mult\\_events.bitcask.expiry.grace\\_time = 1d
multi\\_backend.bitcask\\_mult\\_events.bitcask.io\\_mode = erlang
multi\\_backend.bitcask\\_mult\\_events.bitcask.max\\_file\\_size = 4GB
multi\\_backend.bitcask\\_mult\\_events.bitcask.merge.policy = always
multi\\_backend.bitcask\\_mult\\_events.bitcask.merge.thresholds.dead\\_bytes =
4GB
multi\\_backend.bitcask\\_mult\\_events.bitcask.merge.thresholds.fragmentation 
= 100
multi\\_backend.bitcask\\_mult\\_events.bitcask.merge.triggers.dead\\_bytes =
4GB
multi\\_backend.bitcask\\_mult\\_events.bitcask.merge.triggers.fragmentation =
100

Maybe the configuration is not right, let me know if you think so. What 
I try to do here is to limit disk usage by compacting a file only if it 
contains only expired keys. Our data is pure readonly.

EDIT: on IRC I got this reply from EvilEngel:

EvilEngel&gt; Hey dams. Unfortunately that is how Bitcask expiry works. the
timestamp is internal and not part of the object, so re-writing it
restarts the TTL.

This is worrying: it implies that any new node added to a cluster should
have enough disk space to be able to store \\*twice\\* the amount of
expirable data it is supposed to store. This is ( in my opinion ) an
important fact that should be stressed in the documentation at least,
and if possible, fixed. One way would be to have handoffs transfer
transmit the original timestamp in addition to the data, so that it's
properly set on the target node.



Thanks,
dams.

\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

