---
title: "Re: Riak Adoption - What can we do better?"
description: ""
project: community
lastmod: 2012-04-20T22:56:51-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg07273"
mailinglist_parent_id: "msg07270"
author_name: "Zheng Zhibin"
project_section: "mailinglistitem"
sent_date: 2012-04-20T22:56:51-07:00
---


Witeman

在 2012-4-21，上午6:00，Kyle Kingsbury  写道：

&gt; On 04/20/2012 02:47 PM, Paul Gross wrote:
&gt;&gt; Conceptually, a bucket is a list of documents. So you could handle lists
&gt;&gt; and sets in a similar fashion during a network partition. Each side
&gt;&gt; would see its own list, be able to add and remove. When the network was
&gt;&gt; restored, it could merge the lists (with deletes). There are definitely
&gt;&gt; intricacies to work through, but I think it's possible.
&gt; 
&gt; Any deletes issued during this time would be lost.
&gt; 
&gt; Case 1: Duplicate delivery/deletion on both sides of the partition.
&gt; Case 2: Deletion on one side only, restored by read repair after partition 
&gt; resolved, delivered \\*again\\*.
&gt; 
&gt; It gets weirder when you start considering deleted versioned tombstones.
&gt; 
&gt; This is the classic shared-nothing queue conundrum: you can guarantee 
&gt; at-most-once delivery, or at-least-once-delivery, but not both.
&gt; 
&gt; OK, you say: so we apply CRDTs, and use an observed-removed set across a 
&gt; bucket. That's doable, right? Both sides flag a given value as removed, and 
&gt; reconcile cleanly. Well yes, but now you require unbounded space, and 
&gt; surprise, we have a very disappointing proof that garbage-collecting this 
&gt; class of CRDT requires total coordination among participants. Well shit.
&gt; 
&gt; OK, so how about Statebox? We use timestamps to ameliorate the GC problem so 
&gt; long as a given time window. Our hosts are running NTP so it's all cool, ya? 
&gt; Wrong. One of your hosts is not running NTP. Clock desync issues are fucking 
&gt; \\*ubiquitous\\*, sadly, and you have to be willing to accept, say, losing all 
&gt; conflicting writes from a client under some clock skew circumstances. Since 
&gt; you're talking about a queue, conflicts are \\*almost always guaranteed\\*.
how about use one box for one or some buckets？then in these buckets timestamp 
are meaningful. If we want another backup box for this then just NTP within 
them. Once the main box down, the backup up, since they are always NTP, so the 
time discrepancy between them should be compensated by the period time between 
down and up.
&gt; 
&gt; Seriously, if you or anyone has a good distributed HA queue, please let me 
&gt; know. Better yet, write a paper, found a startup, and become insanely fucking 
&gt; rich. Everyone needs this, but it's a very hard problem. I mean, +1 for Basho 
&gt; solving it and all, but it's not exactly trivial.
&gt; 
&gt;&gt;&gt;&gt; MongoDB also has capped collections which keep a fixed number of
&gt;&gt;&gt;&gt; documents.
&gt;&gt;&gt; 
&gt;&gt;&gt; Strictly speaking, they don't.
&gt;&gt;&gt; 
&gt;&gt; Can you please elaborate?
&gt; 
&gt; Capped collections will delete records when they are out of space. Don't get 
&gt; me started on Mongo's behavior around replicas during partitions.
&gt; 
&gt; --Kyle
&gt; 
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

