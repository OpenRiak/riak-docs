---
title: "Re: Race condition reading objects"
description: ""
project: community
lastmod: 2011-10-31T22:49:23-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg05404"
mailinglist_parent_id: "msg05403"
author_name: "Elias Levy"
project_section: "mailinglistitem"
sent_date: 2011-10-31T22:49:23-07:00
---


On Mon, Oct 31, 2011 at 11:14 PM, Elias Levy wrote:

&gt; On Mon, Oct 31, 2011 at 2:01 PM, Rusty Klophaus  wrote:
&gt;
&gt;&gt; Thanks for your excellent description of the problem. We haven't seen
&gt;&gt; this before to my knowledge, and this isn't expected behavior.
&gt;&gt; Also, if you can share your code, or if you have a small script that can
&gt;&gt; reproduce the failure, that would be extremely helpful.
&gt;&gt;
&gt;
&gt; I created a small test script that reliable reproduces the issue, but I
&gt; created another version that creates truly independent clients (distinct
&gt; processes) and I could not reproduce it. So there issue must lie somewhere
&gt; in my Fiber based client software stack. Somewhere within em-synchrony or
&gt; EventMachine some shared state must be getting clobbered at high processing
&gt; rates, or the high rate is causing EventMachine to return a short read
&gt; under some circumstances.
&gt;

Figured it is a false implementation of read in em-synchrony's TCPSocket.
 It implements recv's behavior, returning partial results, instead of
read's behavior of waiting for enough data or an EOF. Logged at
https://github.com/igrigorik/em-synchrony/issues/77.
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

