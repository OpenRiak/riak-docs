---
title: "Re: MapReduce scalability"
description: ""
project: community
lastmod: 2013-02-26T18:19:58-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg10266"
mailinglist_parent_id: "msg10241"
author_name: "Boris Okner"
project_section: "mailinglistitem"
sent_date: 2013-02-26T18:19:58-08:00
---


Thanks Christian,

The problem I'm trying to solve is to find the way to retrieve values for
limited number of keys with the best possible latency (or maybe with decent
latency which is balanced with decent throughput). Let's say we have keys
stored in some cache
on top of Riak, and want to retrieve values, 20 at the time, to be able to
implement pagination. Another alternative to mapreduce would to send
multiple asynchronous gets, but then we'd have to worry about connection
pool being exhausted if there's too many such "page" requests. So what
would be the proper way to deal with the situation when we need to emulate
multiple key retrieval?

On Tue, Feb 26, 2013 at 1:57 AM, Christian Dahlqvist wrote:

&gt; Hi Boris,
&gt;
&gt; MapReduce is a very flexible and powerful way of querying Riak and allows
&gt; processing to be performed locally where the data resides, which allows for
&gt; efficient processing of larger data sets. A result of this is that every
&gt; mapreduce job requires a covering set of vnodes (all vnodes that hold the
&gt; data required for processing) to participate, meaning that it puts
&gt; considerable more load on the system compared to straight K/V access and
&gt; therefore does not scale quite as well. It is primarily designed for batch
&gt; type processing over reasonably large amounts of data and scales well with
&gt; increased data volumes as new nodes are added. We do however usually not
&gt; recommended using it as an interface for realtime queries where low and
&gt; predictable latencies are required and the concurrency level, and therefore
&gt; load level on the cluster, can not be controlled.
&gt;
&gt; I am not sure I understand what you mean by the performance degrading with
&gt; the number of nodes, unless you are strictly measuring latency rather than
&gt; throughput. As the number of nodes increase, it gets more and more likely
&gt; that multiple physical nodes will be involved in the job, which will add to
&gt; the amount of communication and coordination required between the nodes,
&gt; thereby increasing latency. Could you please explain in more detail what
&gt; you are trying to achieve?
&gt;
&gt; Best regards,
&gt;
&gt; Christian
&gt;
&gt;
&gt; On 25 Feb 2013, at 16:41, Boris Okner  wrote:
&gt;
&gt; Hello,
&gt;
&gt; I'm experimenting with 2 Riak 1.3.0 nodes (both are "bare metal"), and it
&gt; looks like mapreduce performs better when one of the nodes is down. The
&gt; mapreduce requests are running on 20-key blocks. So am I doing something
&gt; wrong, or is it an expected behaviour, i.e. mapreduce degrades with the the
&gt; number of nodes increased? If the former, could
&gt; you give me some pointers on how to set up it to get advantage of multiple
&gt; nodes?
&gt;
&gt; Thanks in advance for your help,
&gt; Boris
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;
&gt;
&gt;
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

