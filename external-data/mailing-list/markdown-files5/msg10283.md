---
title: "Re: MapReduce scalability"
description: ""
project: community
lastmod: 2013-02-28T01:33:36-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg10283"
mailinglist_parent_id: "msg10266"
author_name: "Christian Dahlqvist"
project_section: "mailinglistitem"
sent_date: 2013-02-28T01:33:36-08:00
---


Hi Boris,

Apart from not scaling quite as well as straight K/V access, emulating multiGET 
through MapReduce also has another significant drawback. MapReduce has no 
concept of quorum reads, and only work on a single copy of the data, which can 
be thought of basically as a read with R=1 that does not trigger read-repair. 
It is therefore possible that it can give inconsistent or incorrect results if 
all replicas do not have the same data. It is worth noting that MapReduce was 
designed as a way to efficiently spread compute work across the cluster, and 
re-appropriating it for use with data collection is not its designed purpose.

The recommended way to implement efficient multiget is to perform normal GET 
operations in parallel. If you are retrieving 20 objects, you don't necessarily 
need to do all 20 GETs in parallel, but could set it up to use perhaps 3 or 4 
connections. If you then pair this with a connection pool that can grow and 
shrink in size (perhaps between a minimum and a maximum value) as load 
requires, you should be able to retrieve the objects in a reasonable time 
without overloading the cluster.

Best regards,

Christian


On 27 Feb 2013, at 02:18, Boris Okner  wrote:

&gt; Thanks Christian,
&gt; 
&gt; The problem I'm trying to solve is to find the way to retrieve values for 
&gt; limited number of keys with the best possible latency (or maybe with decent 
&gt; latency which is balanced with decent throughput). Let's say we have keys 
&gt; stored in some cache 
&gt; on top of Riak, and want to retrieve values, 20 at the time, to be able to 
&gt; implement pagination. Another alternative to mapreduce would to send multiple 
&gt; asynchronous gets, but then we'd have to worry about connection pool being 
&gt; exhausted if there's too many such "page" requests. So what would be the 
&gt; proper way to deal with the situation when we need to emulate multiple key 
&gt; retrieval?
&gt; 
&gt; On Tue, Feb 26, 2013 at 1:57 AM, Christian Dahlqvist  
&gt; wrote:
&gt; Hi Boris,
&gt; 
&gt; MapReduce is a very flexible and powerful way of querying Riak and allows 
&gt; processing to be performed locally where the data resides, which allows for 
&gt; efficient processing of larger data sets. A result of this is that every 
&gt; mapreduce job requires a covering set of vnodes (all vnodes that hold the 
&gt; data required for processing) to participate, meaning that it puts 
&gt; considerable more load on the system compared to straight K/V access and 
&gt; therefore does not scale quite as well. It is primarily designed for batch 
&gt; type processing over reasonably large amounts of data and scales well with 
&gt; increased data volumes as new nodes are added. We do however usually not 
&gt; recommended using it as an interface for realtime queries where low and 
&gt; predictable latencies are required and the concurrency level, and therefore 
&gt; load level on the cluster, can not be controlled.
&gt; 
&gt; I am not sure I understand what you mean by the performance degrading with 
&gt; the number of nodes, unless you are strictly measuring latency rather than 
&gt; throughput. As the number of nodes increase, it gets more and more likely 
&gt; that multiple physical nodes will be involved in the job, which will add to 
&gt; the amount of communication and coordination required between the nodes, 
&gt; thereby increasing latency. Could you please explain in more detail what you 
&gt; are trying to achieve?
&gt; 
&gt; Best regards,
&gt; 
&gt; Christian 
&gt; 
&gt; 
&gt; On 25 Feb 2013, at 16:41, Boris Okner  wrote:
&gt; 
&gt;&gt; Hello,
&gt;&gt; 
&gt;&gt; I'm experimenting with 2 Riak 1.3.0 nodes (both are "bare metal"), and it 
&gt;&gt; looks like mapreduce performs better when one of the nodes is down. The 
&gt;&gt; mapreduce requests are running on 20-key blocks. So am I doing something 
&gt;&gt; wrong, or is it an expected behaviour, i.e. mapreduce degrades with the the 
&gt;&gt; number of nodes increased? If the former, could 
&gt;&gt; you give me some pointers on how to set up it to get advantage of multiple 
&gt;&gt; nodes?
&gt;&gt; 
&gt;&gt; Thanks in advance for your help,
&gt;&gt; Boris
&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt; 
&gt; 
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

