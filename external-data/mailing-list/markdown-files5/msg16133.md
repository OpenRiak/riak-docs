---
title: "Re: Clarifying withoutFetch() with LevelDB and"
description: ""
project: community
lastmod: 2015-05-13T09:37:02-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg16133"
mailinglist_parent_id: "msg16132"
author_name: "Alex Moore"
project_section: "mailinglistitem"
sent_date: 2015-05-13T09:37:02-07:00
---


Hey Daniel,

I wanted to know a little bit more about using withoutFetch() option when
&gt; used with levelDB.
&gt; I'm trying to write to a single key as fast as I can with n=3.
&gt; I deliberately create siblings by writing with stale vclock.
&gt; ...
&gt; During the test I see activity on the on disk via iostat and it's between
&gt; 20-30 MB/s on each node.
&gt; Even taking into account multiple copies and overhead of Riak (vclocks etc)
&gt; this seems to be pretty high rate.
&gt; I don't see any read activity which suggest withoutFetch() works as
&gt; expected.
&gt; After 2 mins of tests leveldb on each node is 250MB is size, before test
&gt; (11MB)
&gt; Am I using it incorrectly?

Is writing in this way to a single key a good idea or will I be bitten by
&gt; something?
&gt; How to explain high number of MB written to disks?


We call this problem a "hot key".

When you write with a stale vclock, it will generate a new sibling every
time.
For example the first time you store your object it's just "{v1}", the next
time it will get a sibling: "{v1, v2}", eventually it's "{v1,...v1000}"
since the siblings are never resolved. That data is read, updated, old
version tombstoned, and the new data written with every PUT. Based on your
info I would see about 250MB raw data there if LevelDB hasn't compacted the
tombstones away.

RiakObject.withoutFetch() tells your java client to store data without
fetching the most current value first. During that fetch, it would resolve
siblings before writing the value back. You may get better throughput by
resolving your siblings (less writes overall), or by rethinking your data
model so you're not always writing to the same key repeatedly. Is this
just a benchmark or are you modeling something in your application?

Thanks,
Alex


On Wed, May 13, 2015 at 11:03 AM, Daniel Iwan  wrote:

&gt; We are using Java client 1.1.4.
&gt; We haven't moved to newer version of Riak as as for the moment we don't
&gt; need
&gt; any new features.
&gt; Also roll out of the new version may be complicated since we have multiple
&gt; clusters.
&gt;
&gt; As with regards to object size its ~250-300 bytes per write. We store
&gt; simple
&gt; JSON structures.
&gt;
&gt; Is there anything in new versions that would limit size of data going to
&gt; the
&gt; disk?
&gt; And more importantly is there a way of determining why levelDB grows so
&gt; big?
&gt;
&gt; I'm using ring size 128 which is probably too high at the moment, but after
&gt; switching to 64 not much has changed.
&gt; I also disabled 2i indexes that I thought may matter (four 16 bytes fields)
&gt; and that did not made any difference, still 25-38MB/s write to level db per
&gt; node.
&gt;
&gt; D.
&gt;
&gt;
&gt;
&gt; --
&gt; View this message in context:
&gt; http://riak-users.197444.n3.nabble.com/Clarifying-withoutFetch-with-LevelDB-and-tp4033051p4033053.html
&gt; Sent from the Riak Users mailing list archive at Nabble.com.
&gt;
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

