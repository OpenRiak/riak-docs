---
title: "Re: multi-get (yet again)"
description: ""
project: community
lastmod: 2012-08-09T02:11:16-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg08236"
mailinglist_parent_id: "msg08234"
author_name: "Kresten Krab Thorup"
project_section: "mailinglistitem"
sent_date: 2012-08-09T02:11:16-07:00
---


The only issue with this approach is AFAIK that M/R effectively runs with R=1, 
i.e. it doesn't ensure that a value is consistent across replicas. 

IMHO riak\\_kv\\_mapreduce should have a map\\_get\\_object\\_value, which does a proper 
RiakClient:get, i.e. something like this: [will be slower, but will honour the 
bucket's default R value].

map\\_get\\_object\\_value({error, notfound}=NF, KD, Action) -&gt; 
 
 notfound\\_map\\_action(NF, KD, Action); 
 
map\\_get\\_object\\_value(RO, KD, Action) -&gt; 
 
 {ok, RiakClient} = riak:local\\_client(), 
 
 case RiakClient:get(riak\\_object:bucket(RO),riak\\_object:bucket(RO)) of 
 
 {error, notfound}=NF -&gt; 
 
 notfound\\_map\\_action(NF, KD, Action); 
 
 {ok, RiakObject} -&gt; 
 
 [riak\\_object:get\\_value(RiakObject)] 
 
 end. 
 
 
 
 
 


Kresten


On Aug 9, 2012, at 10:46 AM, Parnell Springmeyer  wrote:

&gt; Jeremy,
&gt; 
&gt; I was looking for something similar and first built an extra handler onto an 
&gt; internal erlang cowboy API server that used maelstrom (my own worker pool OTP 
&gt; application).
&gt; 
&gt; It was used to make a simple POST with a string of the {bucket, key} pairs 
&gt; and the server would concurrently GET and combine the results and send it 
&gt; back. This was very fast (thousands of keys GET in ms).
&gt; 
&gt; Since that seemed gross, I then decided (based on some input from someone 
&gt; else on the list) to try using a simple Map/Reduce phase that did not use 
&gt; javascript but the erlang functions (since those are going to be really fast 
&gt; and take advantage Erlang's concurrency better than the javascript VM's).
&gt; 
&gt; In python, you can do this to run that type of M/R phase without knowing any 
&gt; Erlang code:
&gt; 
&gt; client = riak.RiakClient()
&gt; 
&gt; # Add your KNOWN bucket and key pairs (you can do this in a loop)
&gt; query = client.add(bucket, key)
&gt; query.add(bucket, key)
&gt; query.add(bucket, key)
&gt; etcâ€¦ (as many as you like)
&gt; 
&gt; # Now tell the map and reduce phases to use Erlang module "riak\\_kv\\_mapreduce" 
&gt; and its given function 
&gt; # "map\\_object\\_value" and "reduce\\_set\\_union".
&gt; results = client.map(["riak\\_kv\\_mapreduce", "map\\_object\\_value"]) \\
&gt; .reduce(["riak\\_kv\\_mapreduce", "reduce\\_set\\_union"]) \\
&gt; .run()
&gt; 
&gt; The above returns results faster for me, than the brokered multi-get approach 
&gt; I used (I guarantee my brokered multi-get is faster than anything you can do 
&gt; with python + gevent, if that's the case, the M/R phase is definitely the 
&gt; route you want to go).
&gt; 
&gt; So IMHO, it is very fast as long as you know the buckets and keys you want to 
&gt; get.
&gt; 
&gt; On Aug 9, 2012, at 12:11 AM, Jeremy Dunck wrote:
&gt; 
&gt;&gt; I'm new to riak and need multi-get (that is, getting the value and/or
&gt;&gt; existence of keys in a single network-trip latency).
&gt;&gt; 
&gt;&gt; I was wondering what the latency of the map-reduce approach is?
&gt;&gt; http://lists.basho.com/pipermail/riak-users\\_lists.basho.com/2011-February/003229.html
&gt;&gt; 
&gt;&gt; Alternatively, has anyone tried scaling concurrent gets (perhaps with
&gt;&gt; evented io) to do many concurrent requests and combining results on
&gt;&gt; the client?
&gt;&gt; 
&gt;&gt; I am toying with a python+gevent multiget function. If the stance is
&gt;&gt; still that a multiget operation doesn't belong in core, I'm a little
&gt;&gt; surprised that there doesn't seem to at least be a nice client-lib API
&gt;&gt; func to do it. It sure seems useful...
&gt;&gt; 
&gt;&gt; In my use-case, the immediate need is to know whether a db insert
&gt;&gt; needs to be done. We're handling too many keys to want to store in
&gt;&gt; memory (so no redis, etc), and we don't want to go to the db more than
&gt;&gt; we need to, so it seems riak would be good here. But we're getting
&gt;&gt; 1000s of potential insert keys and want to whittle down all those to a
&gt;&gt; relative few db inserts.
&gt;&gt; 
&gt;&gt; So I was thinking riak key-per-id, and insert to the db iff the riak
&gt;&gt; key doesn't exist, then add the riak key. We'll get some race
&gt;&gt; conditions on the insert, but that's OK in our case.
&gt;&gt; 
&gt;&gt; We do need low latency on the riak check, though, hence either
&gt;&gt; multiplexing w/ eventing or map-reduce (if that latency is actually
&gt;&gt; good).
&gt;&gt; 
&gt;&gt; Am I doing it wrong?
&gt;&gt; 
&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt; 
&gt; 
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com



Mobile: + 45 2343 4626 | Skype: krestenkrabthorup | Twitter: @drkrab
Trifork A/S | Margrethepladsen 4 | DK- 8000 Aarhus C | Phone : +45 8732 
8787 | www.trifork.com
 




\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

