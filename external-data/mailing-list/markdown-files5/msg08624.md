---
title: "Re: links vs 2i"
description: ""
project: community
lastmod: 2012-09-21T08:20:17-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg08624"
mailinglist_parent_id: "msg08620"
author_name: "Jeremiah Peschka"
project_section: "mailinglistitem"
sent_date: 2012-09-21T08:20:17-07:00
---


Another consideration of links is that links will be returned in the HTTP 
headers. If you have too many links, then you can blow away the max size limits 
on an HTTP header and bad things will happen.

There's MR functionality to link walk[1], but link walking may or may not be 
quick depending on your client library, links, phase of the moon, etc. Maybe 
one of the Ripple devs can comment on how things work over there.

What's the big picture problem that you're trying to solve? Are you try to 
determine the fastest way to traverse a rigid hierarchy in your data?

The sample MR query you provided looks like you're effectively trying to 
accomplish something like:

SELECT d.\\*
FROM countries co
JOIN states s ON co.country\\_id = s.country\\_id
JOIN cities ci on s.state\\_id = ci.state\\_id
JOIN streets st ON ci.city\\_id = st.city\\_id
JOIN devices d ON st.street\\_id = d.street\\_id
WHERE co.name = 'USA';

If that's the case, why not store the intermediate data as secondary indexes on 
the device itself? Then you can simply run a query to determine which devices 
are in the US rather than walk across multiple buckets. With sufficient 
secondary indexes at your intermediate levels, you should be able to easily 
recompute your various roll ups for reporting as the underlying data changes 
and still get quick reporting without having to traverse the existing buckets. 

[1]: http://basho.com/blog/technical/2010/02/24/link-walking-by-example/
--- 
Jeremiah Peschka - Managing Director, Brent Ozar PLF, LLC
Microsoft SQL Server MVP

On Sep 21, 2012, at 2:46 AM, Christian Dahlqvist  
wrote:

&gt; Hello Timo,
&gt; 
&gt; I recently played around with using secondary indexes instead of links, and 
&gt; since I did not find any mapreduce functions that allowed me to follow 21 
&gt; "links", I wrote a couple myself. These are available on my GitHub account 
&gt; and I also submitted them to Basho Contrib yesterday for review.
&gt; 
&gt; Using secondary indexes to represent relationships will require the mapreduce 
&gt; function to execute an index query, which will most likely be slower than 
&gt; link walking, although it will as you stated be easier to maintain due to the 
&gt; reduced number of records that need to be modified. As you seem to have a 
&gt; quite deep hierarchy, maybe a mixture of links (for records and relationships 
&gt; not changing often) and 2i "links" may work?
&gt; 
&gt; Best regards,
&gt; 
&gt; Christian 
&gt; 
&gt; 
&gt; 
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

