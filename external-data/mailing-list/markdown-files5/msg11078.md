---
title: "Re: On siblings"
description: ""
project: community
lastmod: 2013-05-15T10:39:05-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg11078"
mailinglist_parent_id: "msg11075"
author_name: "Jeremy Ong"
project_section: "mailinglistitem"
sent_date: 2013-05-15T10:39:05-07:00
---


Thanks all for your help. To perform my workflow properly, the
`return\\_head` option was precisely what I needed. Now I can do something
like

X = Initial Object
{ok, X1} = riakc\\_pb\\_socket(Pid, X, [return\\_head]).
X2 = riakc\\_obj:update\\_value(X1, NextValue).
{ok, X3} = riakc\\_pb\\_socket(Pid, X2, [return\\_head]).

And the above will generate no siblings. I was concerned more about
efficiency if using `return\\_body` but this works just fine.

Cheers,
Jeremy


On Wed, May 15, 2013 at 7:41 AM, Brian Roach  wrote:

&gt; Jeremy -
&gt;
&gt; As noted in the other replies, yes, you need to use 'return\\_body' to
&gt; get the new vector clock in order to avoid creating a sibling on a
&gt; subsequent write of the same key.
&gt;
&gt; That said, you can supply the param 'return\\_head` in the proplist
&gt; along with `return\\_body` which will eliminate having the value
&gt; returned to you and get the vclock you need.
&gt;
&gt; - Roach
&gt;
&gt; On Wed, May 15, 2013 at 8:23 AM, John Daily  wrote:
&gt; &gt; Thanks for the kind words, Jeremiah.
&gt; &gt;
&gt; &gt; Jeremy, if you find anything that's wrong with that description of
&gt; sibling
&gt; &gt; behavior, please let me know. It's always possible I missed something
&gt; &gt; important.
&gt; &gt;
&gt; &gt; -John
&gt; &gt;
&gt; &gt;
&gt; &gt; On Wednesday, May 15, 2013, Jeremiah Peschka wrote:
&gt; &gt;&gt;
&gt; &gt;&gt; John Daily (@macintux) wrote a great blog post that covers sibling
&gt; &gt;&gt; behavior [1]
&gt; &gt;&gt;
&gt; &gt;&gt; In short, though, because you're supplying an older vector clock, and
&gt; you
&gt; &gt;&gt; have allow\\_mult turned on, Riak makes the decision that since a vector
&gt; clock
&gt; &gt;&gt; is present that conflicts with what's already on disk a sibling should
&gt; be
&gt; &gt;&gt; created.
&gt; &gt;&gt;
&gt; &gt;&gt; As I understand it, the only way to write into Riak and not get siblings
&gt; &gt;&gt; is to set allow\\_mult to false - even leaving out vector clocks will
&gt; lead to
&gt; &gt;&gt; siblings if allow\\_mult is true. Or so John Daily's chart claims.
&gt; &gt;&gt;
&gt; &gt;&gt; [1]: http://basho.com/riaks-config-behaviors-part-2/
&gt; &gt;&gt;
&gt; &gt;&gt; ---
&gt; &gt;&gt; Jeremiah Peschka - Founder, Brent Ozar Unlimited
&gt; &gt;&gt; MCITP: SQL Server 2008, MVP
&gt; &gt;&gt; Cloudera Certified Developer for Apache Hadoop
&gt; &gt;&gt;
&gt; &gt;&gt;
&gt; &gt;&gt; On Tue, May 14, 2013 at 10:48 PM, Jeremy Ong 
&gt; &gt;&gt; wrote:
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt; To clarify, I am using the erlang client. From the looks of it, the
&gt; &gt;&gt;&gt; vector clock transition to the new value is opaque to the client so
&gt; the only
&gt; &gt;&gt;&gt; way to streamline this use case is to pass the `return\\_body` option
&gt; (My use
&gt; &gt;&gt;&gt; case is one read, many subsequent writes while updating in memory).
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt; In this case however, I already have the value in memory, so it seems
&gt; &gt;&gt;&gt; inefficient to have to get the entire riakc\\_obj back when I really
&gt; just need
&gt; &gt;&gt;&gt; the metadata to construct the new object. Is this correct?
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt; On Tue, May 14, 2013 at 9:06 PM, Jeremy Ong 
&gt; &gt;&gt;&gt; wrote:
&gt; &gt;&gt;&gt;&gt;
&gt; &gt;&gt;&gt;&gt; Suppose I have an object X.
&gt; &gt;&gt;&gt;&gt;
&gt; &gt;&gt;&gt;&gt; I make an update to X and store it as X1. I perform a put operation
&gt; &gt;&gt;&gt;&gt; using X1.
&gt; &gt;&gt;&gt;&gt;
&gt; &gt;&gt;&gt;&gt; The same client then makes a modification to X1 and stores it as X2.
&gt; &gt;&gt;&gt;&gt; Then, I perform a put operation using X2.
&gt; &gt;&gt;&gt;&gt;
&gt; &gt;&gt;&gt;&gt; This will create two siblings X1 and X2 if allow\\_mult is true. Is
&gt; there
&gt; &gt;&gt;&gt;&gt; any way I can avoid this? To me, the vector clock should have
&gt; incremented
&gt; &gt;&gt;&gt;&gt; once when transitioning from X to X1, then once more when
&gt; transitioning from
&gt; &gt;&gt;&gt;&gt; X1 to X2. This way, I shouldn't need to issue a get before I have to
&gt; perform
&gt; &gt;&gt;&gt;&gt; another write since my data is already in memory.
&gt; &gt;&gt;&gt;&gt;
&gt; &gt;&gt;&gt;&gt; I probably am misunderstanding something about vector clocks. Does
&gt; &gt;&gt;&gt;&gt; anybody care to clarify this?
&gt; &gt;&gt;&gt;&gt;
&gt; &gt;&gt;&gt;&gt; Thanks,
&gt; &gt;&gt;&gt;&gt; Jeremy
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; &gt;&gt;&gt; riak-users mailing list
&gt; &gt;&gt;&gt; riak-users@lists.basho.com
&gt; &gt;&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;
&gt; &gt;
&gt; &gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; &gt; riak-users mailing list
&gt; &gt; riak-users@lists.basho.com
&gt; &gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt; &gt;
&gt;
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

