---
title: "Re: Locking"
description: ""
project: community
lastmod: 2011-08-02T08:29:06-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg04178"
mailinglist_parent_id: "msg04176"
author_name: "Jon Meredith"
project_section: "mailinglistitem"
sent_date: 2011-08-02T08:29:06-07:00
---


Thanks for the info.

I haven't analyzed mongo's replication model and only did a quick scan of
the doc. It isn't clear how would you use the atomic test and set operation
you mentioned with sharding and replication to implement locks.

Does the atomic test and set coordinate with all members in a replica set to
ensure a consistent update. If not, would you restrict yourself to a single
node in each shard to do the locking? Then you have to deal with failover
(client 1 discovers the locking node somehow, acquires a lock, the locking
node dies before the other members of the replica set are updated, client 2
somehow discovers the replacement locking node and as the update didn't make
it out of the original lock server it also grants a lock).

I can see how it could work with a chain replication scheme like Hibari
uses, but I'm not sure that's what mongo is doing. You take a performance
hit to do so.

BR,
Jon

On Tue, Aug 2, 2011 at 9:04 AM, Jeffrey Kesselman  wrote:

&gt; Mongo does its clustering a bit differently then Riak.
&gt;
&gt; It clusters in two dimensions. It shards for scalability,
&gt; and replicates for reliability. In any group of shards, only one shard has
&gt; a given piece of data. But that shard can be replicated in a master/slave
&gt; ,manner for failover.
&gt;
&gt; See:
&gt;
&gt; http://www.mongodb.org/display/DOCS/Sharding+Introduction#ShardingIntroduction-ShardinginaNutshell
&gt;
&gt;
&gt; On Tue, Aug 2, 2011 at 10:50 AM, Jon Meredith  wrote:
&gt;
&gt;&gt; Hi Jeffrey,
&gt;&gt;
&gt;&gt; Do you know if Mongo provides locks that can be used on clusters of
&gt;&gt; machines and in the presence of network partitions/failures? Riak could
&gt;&gt; probably get close if you created a cluster with a single node and performed
&gt;&gt; all accesses with N=R=W=1 as updating a single vnode is atomic, it's only
&gt;&gt; when the order of vnode requests can be interleaved that you get problems.
&gt;&gt; Of course you'd have a single point of failure....
&gt;&gt;
&gt;&gt; Soren: It may be worth looking at a separate lock service along the lines
&gt;&gt; of Zookeeper - you could take a look at the work Joe Blomstedt did on
&gt;&gt; riak\\_zab https://github.com/jtuple/riak\\_zab but as the FAQ suggests do
&gt;&gt; not use it in production.
&gt;&gt;
&gt;&gt; BR,
&gt;&gt; Jon.
&gt;&gt;
&gt;&gt;
&gt;&gt; On Tue, Aug 2, 2011 at 8:40 AM, Jeffrey Kesselman wrote:
&gt;&gt;
&gt;&gt;&gt; jon gave a much better and more detailed description,
&gt;&gt;&gt; but fundamentally no true lock is possible without an atomic test and
&gt;&gt;&gt; set operation.
&gt;&gt;&gt;
&gt;&gt;&gt; So far, of all the No Sql DBs I've looked at, only Mongo has that
&gt;&gt;&gt; capability.
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; On Sun, Jul 31, 2011 at 4:55 PM, Soren Hansen  wrote:
&gt;&gt;&gt;
&gt;&gt;&gt;&gt; I've seen a couple of posts here and there on the subject of a locking
&gt;&gt;&gt;&gt; mechanism for Riak, most notably:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; http://riak-users.197444.n3.nabble.com/Riak-and-Locks-td1866960.html
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; While it would only serve as an advisory locking mechanism, wouldn't a
&gt;&gt;&gt;&gt; bucket with a reasonably high n, w and dw set equal to n, a
&gt;&gt;&gt;&gt; deterministic naming scheme for the object being locked, and a locking
&gt;&gt;&gt;&gt; algorithm such as:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; 1. PUT /locks/object\\_id
&gt;&gt;&gt;&gt; If-None-Match: \\*
&gt;&gt;&gt;&gt; Body: 
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; 1a. If this fails, wait for a while, then try again.
&gt;&gt;&gt;&gt; 1b. If it succeeds, proceed to 2.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; 2. The doc for If-None-Match says "this does not prevent concurrent
&gt;&gt;&gt;&gt; writes; it is possible for the condition to evaluate to true for
&gt;&gt;&gt;&gt; multiple requests if the requests occur at the same time." I'm not
&gt;&gt;&gt;&gt; completely sure if n=w=dw protects me from concurrent writes (I'm not
&gt;&gt;&gt;&gt; familiar with the locking semantics of a single riak instance).
&gt;&gt;&gt;&gt; Anyway, if I'm in fact not protected, the next step is to read the
&gt;&gt;&gt;&gt; value back to make sure we're actually the ones holding the key. If
&gt;&gt;&gt;&gt; not, go back to step 1. If yes, proceed as planned.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; 3. Once you're done with the lock, just DELETE it.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; If this were really that simple, someone would have suggested it. So,
&gt;&gt;&gt;&gt; what is this Riak rookie (i.e. I) missing?
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; --
&gt;&gt;&gt;&gt; Soren Hansen | http://linux2go.dk/
&gt;&gt;&gt;&gt; Ubuntu Developer | http://www.ubuntu.com/
&gt;&gt;&gt;&gt; OpenStack Developer | http://www.openstack.org/
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt;&gt;&gt; riak-users mailing list
&gt;&gt;&gt;&gt; riak-users@lists.basho.com
&gt;&gt;&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt;&gt; riak-users mailing list
&gt;&gt;&gt; riak-users@lists.basho.com
&gt;&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;
&gt;
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

