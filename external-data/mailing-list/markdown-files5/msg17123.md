---
title: "Re: Continuous HTTP POSTs to Riak"
description: ""
project: community
lastmod: 2016-03-06T08:45:12-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg17123"
mailinglist_parent_id: "msg17108"
author_name: "Qiang Cao"
project_section: "mailinglistitem"
sent_date: 2016-03-06T08:45:12-08:00
---


Thanks for sending this explanation, Vitaly! This helps for sure. Thank you
all, guys!

-Qiang

On Sun, Mar 6, 2016 at 3:24 AM, Vitaly E &lt;13vitam...@gmail.com&gt; wrote:

&gt; Hi Qiang,
&gt;
&gt; You mentioned that my suggestion to synchronize the clocks of your Riak
&gt; nodes had solved the problem. Let me explain why -- it may clear things up
&gt; for you.
&gt;
&gt; Riak uses vector clocks / version vectors
&gt; 
&gt; to keep track of the sequence of updates to a particular key. These are
&gt; "logical clocks" as opposed to physical clocks that usually can't be relied
&gt; upon in a distributed system like Riak. Fetching the vector clock of a key
&gt; and passing it back on write (along with a new value), helps Riak decide
&gt; which modification is the "latest" one. Keep in mind that "concurrent
&gt; modification" does not necessary means simultaneous, but can happen due to
&gt; a network partition, for example.
&gt;
&gt; Normally, when a concurrent update is detected (based on vector clocks),
&gt; Riak returns siblings and lets a client decide which version should be
&gt; used. Since you're running with allow\\_mult = false, you've actually told
&gt; Riak to resolve conflicts for you. In this case Riak still uses vector
&gt; clocks when possible, and then time-stamps if there's still a conflict.
&gt; Obviously, if you don't pass vector clocks, only time-stamps will be used.
&gt; Moreover, without vector clocks any update is considered concurrent, Riak
&gt; just doesn't expose it with allow\\_mult = false (remember, you opted for
&gt; automatic conflict resolution?).
&gt;
&gt; Keep in mind that a time-stamp is assigned by the first Riak node a
&gt; request hits. The node then forwards the request based on the key this
&gt; request is trying to write
&gt; .
&gt;
&gt; Now, imagine that a write to a key passes through node X, and within 30
&gt; sec another update to the same key passes through node Y, which is 2 min
&gt; behind node X. Since time-stamps are being used to resolve conflicts, the
&gt; second update will be considered older than the first one, and eventually
&gt; discarded.
&gt;
&gt; So, if this kind of conflict resolution is good enough for you, make sure
&gt; your Riak's clocks are in sync (NTP?). I would also suggest to pass vector
&gt; clocks anyway.
&gt;
&gt; Hope this helps. Everyone is welcome to correct/clarify.
&gt;
&gt; Vitaly
&gt;
&gt;
&gt; On Mar 5, 2016 11:07 PM, "Qiang Cao"  wrote:
&gt;
&gt;&gt; Thanks, Russell. I'm just curious. My application handles that. Maybe
&gt;&gt; that's just because of the vclock.
&gt;&gt;
&gt;&gt; -Qiang
&gt;&gt;
&gt;&gt; On Sat, Mar 5, 2016 at 2:09 PM, Russell Brown 
&gt;&gt; wrote:
&gt;&gt;
&gt;&gt;&gt; And you pass the vclock back after a GET with the next POST? Unless we
&gt;&gt;&gt; get a look at the vclocks then it's hard to say why or where you have
&gt;&gt;&gt; concurrency. But since concurrency is ultimately unavoidable using riak,
&gt;&gt;&gt; why the concern? Can your application/data model handle it is the main
&gt;&gt;&gt; question?
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; On 5 Mar 2016, at 19:04, Qiang Cao  wrote:
&gt;&gt;&gt;
&gt;&gt;&gt; Thanks, Russell! I do a GET immediately after a POST is done. I use
&gt;&gt;&gt; apache httpclient, which handles requests synchronously. On the client,
&gt;&gt;&gt; POSTs and GETs are sent out sequentially.
&gt;&gt;&gt;
&gt;&gt;&gt; On Sat, Mar 5, 2016 at 1:57 PM, Russell Brown 
&gt;&gt;&gt; wrote:
&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; On 5 Mar 2016, at 18:43, Qiang Cao  wrote:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; &gt; Just curious. The POSTs are sent out sequentially and a quorum is set
&gt;&gt;&gt;&gt; up on Riak. I wonder how would it happen that Riak still considers the POST
&gt;&gt;&gt;&gt; requests concurrent?
&gt;&gt;&gt;&gt; Did you read the result of POST 1 before sending POST 2? If not, and
&gt;&gt;&gt;&gt; you donâ€™t send the causal context, Riak has to view them as concurrent.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; How does the quorum work here?
&gt;&gt;&gt;
&gt;&gt;&gt; Thanks,
&gt;&gt;&gt; Qiang
&gt;&gt;&gt;
&gt;&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt;&gt; riak-users mailing list
&gt;&gt;&gt; riak-users@lists.basho.com
&gt;&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;
&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt;
&gt;&gt;
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

