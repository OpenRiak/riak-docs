---
title: "Re: Java client - conflict resolver on both fetch() and store()?"
description: ""
project: community
lastmod: 2013-08-11T03:32:18-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg11961"
mailinglist_parent_id: "msg11960"
author_name: "Matt Painter"
project_section: "mailinglistitem"
sent_date: 2013-08-11T03:32:18-07:00
---


PS (cont.) Or is the idea with the mutators that you have a mutator per
POJO operation (add this, remove that), a corresponding conflict resolver
per operation, and tailored stores accordingly? Currently I have a single
persistence method for my record and a single increasingly bloated resolver
which deals with all operations, so I can see how this approach isn't that
scalable.

I'll stop having conversations with myself now... ;)


On 11 August 2013 20:42, Matt Painter  wrote:

&gt; PS. I presume the advantage of the mutator approach is that it reduces the
&gt; likelihood of sibling conflict resolution having to take place? Or, at
&gt; least the likelihood of unresolveable conflicts? Would my the resolver and
&gt; main POJO be the same using this approach?
&gt;
&gt; Currently in my POJO, I'm maintaining a Map containing references to
&gt; things that have changed (key being the operation, value being identifiers
&gt; and data appropriate to the key) and am using this in my resolver for
&gt; things which need unravelling.
&gt;
&gt;
&gt; On 11 August 2013 14:43, Matt Painter  wrote:
&gt;
&gt;&gt; Thanks Sean. I understand that the fetch-modify-write is the approach
&gt;&gt; that I'm \\*not\\* taking in this case, as I am using withoutFetch() and
&gt;&gt; setting a @RiakVClock in my POJO.
&gt;&gt;
&gt;&gt; I just need to weigh up whether the ideal way is sufficiently better to
&gt;&gt; rejig bits of my code - but I think that's a different issue :)
&gt;&gt;
&gt;&gt; M
&gt;&gt;
&gt;&gt;
&gt;&gt; On 11 August 2013 14:32, Sean Cribbs  wrote:
&gt;&gt;
&gt;&gt;&gt; I'm sure Roach will correct me if I'm off-base, but I believe the store
&gt;&gt;&gt; operation does a fetch and resolve before writing. I think the ideal way to
&gt;&gt;&gt; do that is to create a Mutation (T being your POJO) as well, in which
&gt;&gt;&gt; case it's less of a "store" and more of a "fetch-modify-write". The way to
&gt;&gt;&gt; skip the fetch/modify is to use the withoutFetch() option on the operation
&gt;&gt;&gt; builder.
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; On Sat, Aug 10, 2013 at 6:50 PM, Matt Painter  wrote:
&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Hi,
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; I've just rolled up my sleeves and have started to make my application
&gt;&gt;&gt;&gt; more robust with conflict resolution.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; I am currently using a @RiakVClock in my POJO (I need to think more
&gt;&gt;&gt;&gt; about whether the read/modify/write approach is preferable or whether I'd
&gt;&gt;&gt;&gt; have to rearchitect things).
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; I read in the Riak Handbook the recommendation that conflicts are best
&gt;&gt;&gt;&gt; resolved on read - not write - however the example App.java snipping
&gt;&gt;&gt;&gt; on the Storing data in 
&gt;&gt;&gt;&gt; Riak
&gt;&gt;&gt;&gt; page
&gt;&gt;&gt;&gt; in the Java client's doco uses a resolver on both the store() and
&gt;&gt;&gt;&gt; fetch() operations.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Indeed, if I don't specify my conflict resolver in my store(), things
&gt;&gt;&gt;&gt; blow up (in my unit test, mind - I'm still getting my head around the whole
&gt;&gt;&gt;&gt; area so my test may be a bit contrived).
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; However when I use it in both places, my conflicts are being resolved
&gt;&gt;&gt;&gt; twice. Is this anticipated?
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; My store is:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; bucket.store(record).returnBody(true).
&gt;&gt;&gt;&gt; withoutFetch().withResolver(myConflictResolver);
&gt;&gt;&gt;&gt; and my fetch is:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; bucket.fetch(id, Record.class).withResolver(myConflictResolver
&gt;&gt;&gt;&gt; ).execute();
&gt;&gt;&gt;&gt; The order of operations in my test is:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; 1. Store new record
&gt;&gt;&gt;&gt; 2. Fetch the record as firstRecord
&gt;&gt;&gt;&gt; 3. Fetch the record as secondRecord
&gt;&gt;&gt;&gt; 4. Modify a field on firstRecord and secondRecord
&gt;&gt;&gt;&gt; 5. Save firstRecord
&gt;&gt;&gt;&gt; 6. Save secondRecord - this invokes my resolver with two siblings
&gt;&gt;&gt;&gt; 7. Read record - this also invokes my resolver with the two siblings
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Am I missing something? Or is this what's supposed to happen? I'm not
&gt;&gt;&gt;&gt; too worried - the double-handling is hardly that intensive - but I'm keen
&gt;&gt;&gt;&gt; to get it right.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Thanks in advance,
&gt;&gt;&gt;&gt; Matt
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt;&gt;&gt; riak-users mailing list
&gt;&gt;&gt;&gt; riak-users@lists.basho.com
&gt;&gt;&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; --
&gt;&gt;&gt; Sean Cribbs 
&gt;&gt;&gt; Software Engineer
&gt;&gt;&gt; Basho Technologies, Inc.
&gt;&gt;&gt; http://basho.com/
&gt;&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt; --
&gt;&gt; Matt Painter
&gt;&gt; m...@deity.co.nz
&gt;&gt; +64 21 115 9378
&gt;&gt;
&gt;
&gt;
&gt;
&gt; --
&gt; Matt Painter
&gt; m...@deity.co.nz
&gt; +64 21 115 9378
&gt;



-- 
Matt Painter
m...@deity.co.nz
+64 21 115 9378
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

