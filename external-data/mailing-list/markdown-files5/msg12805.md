---
title: "ANN: Riak C Client *alpha*"
description: ""
project: community
lastmod: 2013-10-30T11:00:09-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg12805"
author_name: "Dave Parfitt"
project_section: "mailinglistitem"
sent_date: 2013-10-30T11:00:09-07:00
---


Hello -

 We would like to take a moment to announce an \\*\\*\\*alpha\\*\\*\\* version of the
official Basho Riak C Client [0]. Under the hood, the new C client has a
protobuffs only interface and uses libevent [1] for both synchronous and
asynchronous communications with Riak. Basho is planning on the addition of
Yokozuna and CRDT support to complement the future Riak 2.0 release, but we
still have to finish up 1.4 message implementation (such as M/R & 2i). Our
goal is to make this client rock-solid and threads-safe, as it can possibly
be used as the basis for C++, PHP and other clients.

As an \\*alpha\\* release, expect things to be broken, changes to the API, and
untested features. DO \\*NOT\\* USE THIS IN PRODUCTION.

Currently, the client supports many of the Riak 1.4.x messages:

- get
- put
- delete
- ping
- server info
- list buckets
- list keys
- get/set client id
- get/set/reset bucket properties

Here's what it looks like:

```
riak\\_context \\*ctx;
riak\\_object \\*obj;

riak\\_error err = riak\\_context\\_new\\_default(&ctx);
err = riak\\_context\\_add\\_default\\_connection(ctx, riakhost, riakpbport);
err = riak\\_context\\_add\\_logging(ctx, NULL);

obj = riak\\_object\\_new(ctx);
if (obj == NULL) {
 riak\\_log\\_fatal(rev, "%s","Could not allocate a Riak Object");
 return 1;
}

// the binaries created below need to be freed eventually
// however, this is just a sample
riak\\_object\\_set\\_bucket(obj, riak\\_binary\\_new\\_from\\_string(ctx, "mybucket"));
riak\\_object\\_set\\_key(obj, riak\\_binary\\_new\\_from\\_string(ctx, "mykey"));
riak\\_object\\_set\\_value(obj, riak\\_binary\\_new\\_from\\_string(ctx, "myvalue"));

// setup put options
riak\\_put\\_options \\*put\\_options = riak\\_put\\_options\\_new(ctx);
riak\\_put\\_options\\_set\\_return\\_head(put\\_options, RIAK\\_FALSE);
riak\\_put\\_options\\_set\\_return\\_body(put\\_options, RIAK\\_FALSE);

// perform the PUT
riak\\_put\\_response \\*put\\_response;
err = riak\\_put(ctx, obj, put\\_options, &put\\_response);
// check the response and print it
if (err != ERIAK\\_OK) {
 riak\\_print\\_put\\_response(put\\_response, output, sizeof(output));
 printf("%s\\n", output);
}

// clean up
riak\\_free\\_put\\_response(ctx, &put\\_response);
riak\\_object\\_free(ctx, &obj);

```

We're sending this announcement out now because a) we're excited to get this
project up and running, and b) we would like your feedback, testing, pull
requests, and/or rotten tomatoes. If you would like to contribue or submit
a bug report, please check the issues list first [2].

Cheers -
Brett [3] and Dave [4]

[0] https://github.com/basho/riak-c-client
[1] https://github.com/basho/riak-c-client/issues
[2] http://libevent.org/
[3] https://github.com/javajolt
[4] https://github.com/metadave
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

