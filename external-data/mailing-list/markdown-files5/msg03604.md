---
title: "Re: Correct way to use pbc/mapreduce to do multiget where keys and	bucket names are binary values?"
description: ""
project: community
lastmod: 2011-06-07T18:13:17-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg03604"
mailinglist_parent_id: "msg03556"
author_name: "Jacques"
project_section: "mailinglistitem"
sent_date: 2011-06-07T18:13:17-07:00
---


I've been working on this. I have it working with an anonymous javascript
function. I was hoping to move it to using the "map\\_object\\_value" built-in
erlang function. However, when I attempt to use this function, I get
failures if any of my keys don't exist. Is there a way to construct my map
phase so that it gracefully handles not founds and just returns what it
finds?

Also, using this function, is there a way to return the bucket and key
names? Or can one assume the response order is identical to the order of
inputs?

I have my current constructions below.

Thanks for any help.

Jacques



\\*Working Function Definition (including not founds)\\*
 private static final OtpErlangAtom FUNCTION\\_TYPE = new
OtpErlangAtom("jsanon");
 private static final OtpErlangBinary FUNCTION\\_VALUE = new
OtpErlangBinary("function(v){ return [v]; }".getBytes());
 private static final OtpErlangTuple MAP\\_REDUCE\\_FUNCTION = new
OtpErlangTuple(new OtpErlangObject[] { FUNCTION\\_TYPE, FUNCTION\\_VALUE });

\\*Non-working Function Definition (works fine if all input list exists.
 Fails on not founds.)\\*
 private static final OtpErlangAtom FUNCTION\\_TYPE = new
OtpErlangAtom("modfun");
 private static final OtpErlangAtom FUNCTION\\_MODULE = new
OtpErlangAtom("riak\\_kv\\_mapreduce");
 private static final OtpErlangAtom FUNCTION\\_NAME = new
OtpErlangAtom("map\\_object\\_value");
 private static final OtpErlangTuple MAP\\_REDUCE\\_FUNCTION = new
OtpErlangTuple(new OtpErlangObject[] { FUNCTION\\_TYPE, FUNCTION\\_MODULE,
FUNCTION\\_NAME });


\\*Final construction of Query object for submission (using either of above).\\*
 private static final OtpErlangTuple MAP\\_REDUCE\\_PHASE = new
OtpErlangTuple(new OtpErlangObject[]{ATOM\\_MAP, MAP\\_REDUCE\\_FUNCTION,
ATOM\\_NONE, KEEP\\_TRUE});
 private static final OtpErlangList MAP\\_REDUCE\\_PHASES = new
OtpErlangList(new OtpErlangTuple[]{MAP\\_REDUCE\\_PHASE});
 private static final OtpErlangTuple FULL\\_QUERY = new OtpErlangTuple(new
OtpErlangObject[] { ATOM\\_QUERY, MAP\\_REDUCE\\_PHASES });



On Tue, Jun 7, 2011 at 7:57 AM, Russell Brown  wrote:

&gt;
&gt; On 7 Jun 2011, at 15:29, Jacques wrote:
&gt;
&gt; Have you had any success with reading the server response?
&gt;
&gt;
&gt; Yes. Sorry I didn't post a reply.
&gt;
&gt; It was trivial (but fraught, see below), I just used the OtpInputStream to
&gt; deserialize the byte array returned from pbc.MapReduceResponse.
&gt;
&gt; Like:
&gt;
&gt; ByteString bs = resp.getContent();
&gt; OtpInputStream is = new OtpInputStream(bs.toByteArray());
&gt; OtpErlangObject result = is.read\\_any();
&gt; // and then all sorts of looping, sniffing types, unpacking etc
&gt;
&gt;
&gt; Caveats:
&gt;
&gt; You have a pain unpacking any reasonably complex result.
&gt; The ETF specification drops this doozy about "strings":
&gt; http://www.erlang.org/doc/apps/erts/erl\\_ext\\_dist.html#id85596.
&gt; My first test actually returned a list of [0,1,2,3...200] and Jinterface
&gt; helpfully turned that into a string for me.
&gt;
&gt; That aside it is certainly feasible to use Jinterface to
&gt; serialize/deserialize Map/Reduce jobs/results.
&gt;
&gt; Cheers
&gt;
&gt; Russell
&gt;
&gt;
&gt; Thanks,
&gt; Jacques
&gt;
&gt; On Sat, Jun 4, 2011 at 1:19 PM, Russell Brown wrote:
&gt;
&gt;&gt;
&gt;&gt; On 4 Jun 2011, at 18:22, Jacques wrote:
&gt;&gt;
&gt;&gt; I like the sound of option 3 also. I'll have a look at it this weekend
&gt;&gt;&gt; and get back to you.
&gt;&gt;&gt;
&gt;&gt;
&gt;&gt; Awesome! Thanks. If you can give me a point in the right direction
&gt;&gt; regarding the correct typing approach and what not, I'm up for giving it a
&gt;&gt; shot as well.
&gt;&gt;
&gt;&gt;
&gt;&gt; Ok, I have a half working hack. It isn't pretty 'cos the Jinterface API is
&gt;&gt; verbose. I've hacked the pbc.MapReduceBuilder to encode the job as
&gt;&gt; "application/x-erlang-binary" and submit that, but really this code should
&gt;&gt; be in a separate class, maybe using the output from
&gt;&gt; MapReduceBuilder.getJSON() as input. That way you can get the feature
&gt;&gt; without patching the client.
&gt;&gt;
&gt;&gt; What I haven't done is decode the response from Riak yet. If you want a
&gt;&gt; pointer here is a gist of the (unclean) hack. It could use a lot of work,
&gt;&gt; but it proves the concept:
&gt;&gt;
&gt;&gt; https://gist.github.com/1008293
&gt;&gt;
&gt;&gt; The gist is just the diff so you can apply it as a patch
&gt;&gt; to src/main/java/com/basho/riak/pbc/mapreduce/MapReduceBuilder.java if you
&gt;&gt; want to play with it.
&gt;&gt;
&gt;&gt; You'll have to add Jinterface to your pom too.
&gt;&gt;
&gt;&gt; 
&gt;&gt; 
&gt;&gt; org.erlang.otp
&gt;&gt; jinterface
&gt;&gt; 1.5.4
&gt;&gt; 
&gt;&gt;
&gt;&gt; I think it is best to put the result decoding outside the library too. I'm
&gt;&gt; going to hack up a poc for that now, but I thought I'd post what I have thus
&gt;&gt; far.
&gt;&gt;
&gt;&gt; Cheers
&gt;&gt;
&gt;&gt; Russell
&gt;&gt;
&gt;&gt;
&gt;&gt; Thanks again,
&gt;&gt; Jacques
&gt;&gt;
&gt;&gt;
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;
&gt;
&gt;
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

