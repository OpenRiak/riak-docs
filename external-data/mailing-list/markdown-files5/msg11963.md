---
title: "Re: Java client - conflict resolver on both fetch() and store()?"
description: ""
project: community
lastmod: 2013-08-11T10:13:22-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg11963"
mailinglist_parent_id: "msg11962"
author_name: "Brian Roach"
project_section: "mailinglistitem"
sent_date: 2013-08-11T10:13:22-07:00
---


Matt,

The original design of StoreObject (which is what Bucket.store()
returns) was that it would encapsulate the entire read/modify/write
cycle in a very Java-y / enterprise-y way. This is why it takes a
Resolver and a Mutator; it does a fetch, resolves conflicts, passes
the resolved object to the Mutator, then stores the result of the
mutation to Riak.

Several users put in requests to make the fetch/resolve portion of
that optional as they had a workflow where that wasn't ideal and
didn't wanted to store a previously fetched value without fetching it
again. This is why the 'withoutFetch()' method was introduced along
with the @RiakVClock annotation.

When using withoutFetch() no fetch is performed, and no conflict
resolution occurs. Any ConflictResolver you pass in is simply not used
/ ignored ... except possibly if you're using returnBody()

Your code here:

bucket.store(record).returnBody(true).withoutFetch().withResolver(myConflictResolver);

is not doing a fetch or conflict resolution before storing your data.
It's just storing `record` in Riak. If that POJO has a vclock from a
previous fetch available via a @RiakVClock annotated field it will be
used. Otherwise, you're doing a store without a vclock.

I suspect where your confusion is stemming from is that you've also
specified 'returnBody()' and you're creating a sibling in that store
operation. When that's the case the "body" is going to be multiple
objects (all the siblings) which require resolution as
StoreObject.execute() only returns a single object back to the caller.
The same Resolver used if you had done the pre-fetch is employed. If
you haven't passed in a Resolver then the DefaultResolver is used
which ... isn't really a "resolver" - it simply passes through an
object if there's only one, or throws an exception if there's multiple
(siblings) present.

Thanks,
- Roach




On Sun, Aug 11, 2013 at 5:41 AM, Guido Medina  wrote:
&gt; Hi Matt,
&gt;
&gt; Like Sean said, you should have a mutator if you are dealing with conflict
&gt; resolution in domain objects; a good side effect of using a mutator is that
&gt; Riak Java client will fetch-modify-write so your conflict resolver will be
&gt; called once(?), if you don't use mutators, you get the effect you are
&gt; describing(?) or in other words, you have to treat the operations as
&gt; non-atomic and do things twice.
&gt;
&gt; There are two interfaces for mutations: Mutation and
&gt; ConditionalStoreMutation, the 2nd interface will write only if the object
&gt; was actually mutated, you must return true or false to state if it was
&gt; mutated or not, which can be helpful if you are "mutating" an object and you
&gt; discover the change you are requesting to make was already in place, then to
&gt; save I/O, siblings creation and all implied on a write operation you decide
&gt; not to write back.
&gt;
&gt; Mutation and conflict resolution are two separate concerns, but if you
&gt; specify a mutator and a conflict resolver, conflict resolution will happen
&gt; after the object is fetched and it is ready to be modified, which will
&gt; emulate an atomic operation if you use a domain object.
&gt;
&gt; If you use a raw RiakObject, you must fetch, resolve the conflicts and on
&gt; the write operation pass the VClock which is not a trivial nor easy to
&gt; understand in code.
&gt;
&gt; HTH,
&gt;
&gt; Guido.
&gt;
&gt;
&gt;
&gt; On 11/08/13 03:32, Sean Cribbs wrote:
&gt;
&gt; I'm sure Roach will correct me if I'm off-base, but I believe the store
&gt; operation does a fetch and resolve before writing. I think the ideal way to
&gt; do that is to create a Mutation (T being your POJO) as well, in which
&gt; case it's less of a "store" and more of a "fetch-modify-write". The way to
&gt; skip the fetch/modify is to use the withoutFetch() option on the operation
&gt; builder.
&gt;
&gt;
&gt; On Sat, Aug 10, 2013 at 6:50 PM, Matt Painter  wrote:
&gt;&gt;
&gt;&gt; Hi,
&gt;&gt;
&gt;&gt; I've just rolled up my sleeves and have started to make my application
&gt;&gt; more robust with conflict resolution.
&gt;&gt;
&gt;&gt; I am currently using a @RiakVClock in my POJO (I need to think more about
&gt;&gt; whether the read/modify/write approach is preferable or whether I'd have to
&gt;&gt; rearchitect things).
&gt;&gt;
&gt;&gt; I read in the Riak Handbook the recommendation that conflicts are best
&gt;&gt; resolved on read - not write - however the example App.java snipping on the
&gt;&gt; Storing data in Riak page in the Java client's doco uses a resolver on both
&gt;&gt; the store() and fetch() operations.
&gt;&gt;
&gt;&gt; Indeed, if I don't specify my conflict resolver in my store(), things blow
&gt;&gt; up (in my unit test, mind - I'm still getting my head around the whole area
&gt;&gt; so my test may be a bit contrived).
&gt;&gt;
&gt;&gt; However when I use it in both places, my conflicts are being resolved
&gt;&gt; twice. Is this anticipated?
&gt;&gt;
&gt;&gt; My store is:
&gt;&gt;
&gt;&gt;
&gt;&gt; bucket.store(record).returnBody(true).withoutFetch().withResolver(myConflictResolver);
&gt;&gt;
&gt;&gt; and my fetch is:
&gt;&gt;
&gt;&gt; bucket.fetch(id, Record.class).withResolver(myConflictResolver).execute();
&gt;&gt;
&gt;&gt; The order of operations in my test is:
&gt;&gt;
&gt;&gt; Store new record
&gt;&gt; Fetch the record as firstRecord
&gt;&gt; Fetch the record as secondRecord
&gt;&gt; Modify a field on firstRecord and secondRecord
&gt;&gt; Save firstRecord
&gt;&gt; Save secondRecord - this invokes my resolver with two siblings
&gt;&gt; Read record - this also invokes my resolver with the two siblings
&gt;&gt;
&gt;&gt; Am I missing something? Or is this what's supposed to happen? I'm not too
&gt;&gt; worried - the double-handling is hardly that intensive - but I'm keen to get
&gt;&gt; it right.
&gt;&gt;
&gt;&gt; Thanks in advance,
&gt;&gt; Matt
&gt;&gt;
&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt;
&gt;
&gt;
&gt;
&gt; --
&gt; Sean Cribbs 
&gt; Software Engineer
&gt; Basho Technologies, Inc.
&gt; http://basho.com/
&gt;
&gt;
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;
&gt;
&gt;
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;

\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

