---
title: "Re: Default values vs non-existing keys for CRDTs"
description: ""
project: community
lastmod: 2015-08-20T10:54:12-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg16443"
mailinglist_parent_id: "msg16435"
author_name: "Timur Fayruzov"
project_section: "mailinglistitem"
sent_date: 2015-08-20T10:54:12-07:00
---


Forgot to include the list in the initial response.

Thanks, Dmitri. I'm writing in Scala so I use riak java client. That seem
to make the trick:

val fetchOp = new
FetchValue.Builder(key.location).withOption(FetchValue.Option.HEAD,
java.lang.Boolean.TRUE).build()
val res = module.client.execute(fetchOp)
res.isNotFound should equal(true)

But also means that I need to issue a separate (albeit lightweight) request
to check whether the key exists before fetching a CRDT value. I'm also not
entirely sure whether it is compatible with CRDT, based on the Russel's
comment below.

On Wed, Aug 19, 2015 at 8:48 PM, Dmitri Zagidulin 
wrote:

&gt; From what I understand, this is a limitation of that particular client
&gt; (what language is that, by the way?). Feel free to open an issue on Github
&gt; for it.
&gt;
&gt; The HTTP API, at least, does distinguish between a non-existent counter
&gt; and a counter whose value happens to be 0.
&gt;
&gt; For example, here's the result of trying to access an existing key (with a
&gt; value set to 0):
&gt;
&gt; curl
&gt; http://localhost:8098/types/counters/buckets/room\\_occupancy/datatypes/room-215
&gt; {"type":"counter","value":0}
&gt;
&gt; And here's the result of retrieving the value of a non-existent key:
&gt;
&gt; curl
&gt; http://localhost:8098/types/counters/buckets/room\\_occupancy/datatypes/non-existent-room
&gt; {"type":"counter","error":"notfound"}
&gt;
&gt; There's a workaround you can do with your existing client, however (until
&gt; the issue with the FetchCounter request gets fixed).
&gt;
&gt; You can issue a regular Fetch Object operation (preferably setting the
&gt; 'HEAD only' option to true) for that counter. A Riak counter (or any other
&gt; data type) still exists as a regular object, and you can issue a HEAD
&gt; request to it (as opposed to a Fetch Counter or whatever), and it'll return
&gt; a 404 as expected.
&gt;
&gt; On Wed, Aug 19, 2015 at 8:59 PM, Timur Fayruzov 
&gt; wrote:
&gt;
&gt;&gt; Hello,
&gt;&gt;
&gt;&gt; It seems that Riak Datatype API does not allow to distinguish between
&gt;&gt; non-existing keys and default values. For example, if I query for
&gt;&gt; non-existing key as follows:
&gt;&gt;
&gt;&gt; val fetchOp = new FetchCounter.Builder(key).build()
&gt;&gt; val c = client.execute(fetchOp).getDatatype
&gt;&gt;
&gt;&gt; I'll get a counter that holds 0. Now, if I put counter with value 0 at
&gt;&gt; this key and run the query, I get the same result. Is there any way to
&gt;&gt; distinguish between these two different states?
&gt;&gt;
&gt;&gt; Note: when working with sets there is a context that I can check. If I
&gt;&gt; fetch a set and the context is null, it means that the set does not exist
&gt;&gt; under this key. This trick does not work for counters though, as they do
&gt;&gt; not maintain context. Is it a valid trick to use though?
&gt;&gt;
&gt;&gt; I posted this to StackOverflow a while ago, but no luck:
&gt;&gt; http://stackoverflow.com/questions/31845164/riak-dataypes-default-values-vs-non-existing-keys
&gt;&gt;
&gt;&gt; Thanks,
&gt;&gt;
&gt;&gt; Timur
&gt;&gt;
&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt;
&gt;&gt;
&gt;
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

