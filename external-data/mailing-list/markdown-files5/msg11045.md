---
title: "Re: Riak 1.3.1 and w=1 performance change"
description: ""
project: community
lastmod: 2013-05-08T20:13:15-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg11045"
mailinglist_parent_id: "msg11043"
author_name: "Alexander Sicular"
project_section: "mailinglistitem"
sent_date: 2013-05-08T20:13:15-07:00
---


Thanks for the breakdown. Is this true in cases where the coordinating node 
servicing the request is itself not part of the covering set of nodes that will 
own the key in question? Assume a 5 node cluster. Node 1 receives the request 
but the key ultimately belongs to nodes 2,3,4. Will node 1 write the key to its 
disk and return to client (w/dw=1)?

Thank you,
Alexander

@siculars
http://siculars.posterous.com

Sent from my iRotaryPhone

On May 8, 2013, at 18:29, John Daily  wrote:

&gt; As you may have noticed, this week on the blog I've been tackling the deeper 
&gt; meanings of various behavioral configuration parameters, ranging from ye olde 
&gt; r/w parameters to the much more obscure basic\\_quorum.
&gt; 
&gt; After posting today's missive, the esteemed Andrew Thompson noticed that 
&gt; something I documented was no longer true in v1.3.1, and after some 
&gt; discussions we realized that this change had implications that needed to be 
&gt; shared with the community.
&gt; 
&gt; For those unfamiliar: dw is short for durable write, so setting dw values for 
&gt; a bucket or request indicates how many nodes should have the data saved to 
&gt; the backend (typically bitcask or leveldb) before the client is sent a 
&gt; response.
&gt; 
&gt; 
&gt; tl;dr
&gt; ==
&gt; If you set w=1 for performance reasons, make sure you also set dw=1.
&gt; 
&gt; 
&gt; Slightly longer version
&gt; ==
&gt; Until 1.3.1, dw (durable write) would be implicitly demoted to have the same 
&gt; value as w when w was smaller. This is a reasonable optimization for the w=1 
&gt; case (dw defaults to quorum, despite what you may have read on 
&gt; docs.basho.com) but a very unreasonable behavior when someone explicitly 
&gt; asked for dw=3 without also asking for w=3.
&gt; 
&gt; Now in 1.3.1 dw will be 1 (at a minimum), 2 (by default), and 3 (if 
&gt; requested) no matter what value is set for w.
&gt; 
&gt; 
&gt; Cross-referenced version
&gt; ==
&gt; Read http://basho.com/understanding-riaks-configurable-behaviors-part-1/ and 
&gt; http://basho.com/riaks-config-behaviors-part-2/; the latter should be updated 
&gt; today to reflect the 1.3.1 behavior.
&gt; 
&gt; Also check back on the blog (http://basho.com/blog) later this week for 2 
&gt; more posts in the series. I think you'll enjoy them.
&gt; 
&gt; 
&gt; The really long version
&gt; ==
&gt; (Actually, this is somewhat tangential to the original point and shorter than 
&gt; my blog posts, so it's really the longish pedantic version.)
&gt; 
&gt; This explanation assumes default behaviors, such as vnode\\_vclocks=true and 
&gt; n\\_val=3. Vnode-based vector clocks are the defining behavioral characteristic 
&gt; that makes this flow what it is.
&gt; 
&gt; 
&gt; When a write request arrives at the coordinating node, contrary to what one 
&gt; might expect it is not immediately sent to the other 2 nodes with 
&gt; responsibility over the key.
&gt; 
&gt; Instead, the request is handed to the local vnode mapped to that key, and 
&gt; until the vnode replies back with a new vector clock, nothing else happens.
&gt; 
&gt; So, the approximate sequence of events:
&gt; 
&gt; 1 Coordinating node receives request
&gt; 2 Request is forwarded to local vnode
&gt; 3 Local vnode replies with "w" message to the coordinating node indicating 
&gt; it has received the request
&gt; 4 Local vnode creates a new vector clock based on the vclock received with 
&gt; the request, if any, and possibly impacted by any existing object with the 
&gt; same key
&gt; 5 Local vnode sends the new object to the backend
&gt; 6 Local vnode replies with "dw" message and new object to the coordinating 
&gt; node
&gt; 7 If w=1 and dw=1, /now/ the coordinating node replies to the client, with 
&gt; the new vclock if requested by the client
&gt; 8 The coordinating node sends the new object with new vclock to the remote 
&gt; vnodes that also own the key
&gt; 9 Each vnode will reply with a "w" message upon receipt
&gt; 10 Each vnode will reply with a "dw" message upon sending the object to its 
&gt; backend
&gt; 11 If w&gt;1 or dw&gt;1, the coordinating node replies to the client once it has 
&gt; received enough successful replies from the remote vnodes to meet those values
&gt; 
&gt; (This is why it's not meaningful, with vnode\\_vclocks=true, to set dw=0. It 
&gt; has a minimum effective value of 1, regardless of what the client or operator 
&gt; wishes, because the first vnode must construct a new vector clock and store 
&gt; the object to disk before the client can ever receive a response.)
&gt; 
&gt; And as you can see, all activity before the reply to the client is local to 
&gt; the coordinating node when w=1 and dw=1, and the response can be sent back to 
&gt; the client before the request is forwarded to other nodes.
&gt; 
&gt; Prior to 1.3.1, dw would be effectively 1 if w was set to 1. Now, with 1.3.1, 
&gt; both w and dw must be set to 1 before that optimal response time can be 
&gt; achieved.
&gt; 
&gt; -John
&gt; 
&gt; 
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

