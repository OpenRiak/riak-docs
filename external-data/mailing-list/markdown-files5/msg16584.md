---
title: "Re: Problem with Vector Clocks - inconsistencies encountered in	cluster with shifted real local clocks"
description: ""
project: community
lastmod: 2015-10-01T05:19:51-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg16584"
author_name: "Russell Brown"
project_section: "mailinglistitem"
sent_date: 2015-10-01T05:19:51-07:00
---


I need more time to examine the diagram, but this all looks as expected so far.

If a client sends no context then it’s write will be a sibling of whatever is 
stored at the coordinator, as you rightly point out riak treats an incoming 
clock that is less than a local clock as a sibling.
If the coordinator is configured to not store siblings then the sibling value 
with the highest timestamp is stored, I recommend you run riak in either 
allow\\_mult=true or LWW=true, allow\\_mult=false, in my view, should not be 
default.
If two riak nodes do the above, and then replicate their values, the single 
value with the highest value is stored. Isn’t this what you are seeing? If you 
depend on time to pick the latest, and nodes’ clocks are out of sync this is 
the price.

Is this what you are seeing? Are you seeing results you didn’t expect, or 
non-deterministic results? Or both?

Regards

Russell

On 1 Oct 2015, at 12:58, Zuzana Zatrochova  wrote:

&gt; Hi,
&gt; 
&gt; 
&gt; 
&gt; We are researching the client-centric consistency features of Riak database. 
&gt; We encountered a problem with vector clocks implementation. The vector clocks 
&gt; do not seem to work locally on a machine as expected. We would like you to 
&gt; confirm if the behavior is desired. First I will describe the environment of 
&gt; our experiments and then the problem will be presented.
&gt; 
&gt; 
&gt; 
&gt; Environment:
&gt; 
&gt; 
&gt; • Our environment consists of six virtual machines
&gt; • five machines in Riak cluster, each represent a single Riak 
&gt; node with Riak database
&gt; • one machine with java application that simulates multiple 
&gt; clients communicating with Riak database
&gt; • Machines are Virtualized VMs by VMware software and have slightly 
&gt; shifted time to each other (no more than 1 second)
&gt; • We made experiments with versions riak-1.4.8 and riak-2.1.1. In 
&gt; riak-1.4.8 app\\_config contains vnode\\_vclocks = true (default setting that 
&gt; was there when downloaded) in riak-2.1.1 we could not locate configuration 
&gt; for vnode vclocks either in advanced configurations in documentation or 
&gt; riak.conf so we assumed it also defaults to true and is no longer enabled to 
&gt; change
&gt; • For each experiment we have 500 clients concurrently sending requests 
&gt; to random node from the cluster. There are 20000 requests per minute 
&gt; operating only on 20 different keys (load on single key is 16 requests per 
&gt; second (read:write ration = 50:50).
&gt; • For referenced issue we used quorums R = 1, W = 3; R = 2, W = 2 and R 
&gt; =3 W = 1
&gt; • All riak settings are default apart from IP settings and quorum 
&gt; settings. We added interceptors from riak\\_test module that don’t change the 
&gt; code and are implemented only for logging purposes (information about states 
&gt; of nodes), error.log is empty
&gt; 
&gt; Problem:
&gt; 
&gt; 
&gt; • It seems that Riak does not use vector clocks locally, only on global 
&gt; scale. When a data object is created on client side and sent to Riak database 
&gt; it does not have any vector clocks assigned (more precisely the function 
&gt; riak\\_object:vclock(UpdObj) = [] and local object: 
&gt; riak\\_object:vclock(LocalObj) returns the local VC for the local object. 
&gt; Therefore the function (in 2.1.1 but similar behavior is in 1.4.8) 
&gt; vclock:descends(NewObject, LocalObject) returns false for all my experiments 
&gt; with different quorums (Empty vector clocks cannot descend non empty vector 
&gt; clocks). The behavior leads to merge of contents = creation of siblings (or 
&gt; resolving the value according to the timestamp not vector clocks when 
&gt; siblings are not allowed – our configuration)
&gt; • In our experiments when time on VMs is not synchronized up to 500 
&gt; milliseconds the situation from picture issue.png sent in attachment arises. 
&gt; Due to the fact that two objects with the same key are sent to two different 
&gt; coordinators and coordinators clocks are shifted the later object is assigned 
&gt; earlier timestamp as the object that was sent before. As the result of the 
&gt; vector clocks implementation in Riak, the later object is lost due to the 
&gt; merge of contents where later timestamp (wrong because of local clock shift) 
&gt; is evaluated as the latest.
&gt; 
&gt; The question:
&gt; 
&gt; 
&gt; 
&gt; Is this the Riak intended behavior? The problem is that even when quorum is 
&gt; set to prefer consistency and there are no partitions in the cluster there 
&gt; are still inconsistent requests seen from client perspective = any read must 
&gt; return the value of the latest finished write or later unfinished write 
&gt; request. (We did not use the strong\\_consistency feature of riak-2.1.1 
&gt; version).
&gt; 
&gt; 
&gt; 
&gt; Thank you,
&gt; 
&gt; Zuzana
&gt; 
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com


\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

