---
title: "Re: Quickly deleting + recreating item in Riak deletes new item"
description: ""
project: community
lastmod: 2013-07-19T18:50:28-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg11648"
mailinglist_parent_id: "msg11562"
author_name: "Kelly McLaughlin"
project_section: "mailinglistitem"
sent_date: 2013-07-19T18:50:28-07:00
---


Matthew,

I did some testing with your code and I was able to reproduce what you were
seeing. I would occasionally see an error similar to the following:

 Failed to fetch item 460 err Object not found

This behavior is a result of the trade-offs of using an eventually
consistent database like Riak. It is not the case that your inserts are
failing to write or the data is being lost, but what is actually happening
is that the quick read after writing with the default request options does
not provide any guarantee that you will read your writes. So basically when
you make the read, the replicas that are responding to your request have
not seen the latest value yet and so you end up with "Not Found" as the
response. If you did another read attempt for one of those objects reported
missing, it would succeed because Riak's read-repair would have kicked in
to make sure each replica has the value. To increase the likelihood of
reading your writes you should set the optional request parameters pr and
pw to ensure that all of the primary replicas are available prior to
performing a read or write request. I altered your code to use those
options and put the updates in a gist [1] (it's my first stab at Go so my
changes may not be very idiomatic). Additionally I changed to riak driver
so that NotFoundOk was false instead of true. With these changes I was able
to run the test 50 times in a row with no errors where previously I would
see at least one error every 10 iterations or so. Hope that helps.

[1] : https://gist.github.com/kellymclaughlin/6041109

Kelly


On Wed, Jul 17, 2013 at 4:07 PM, Matthew Dawson wrote:

&gt; On July 17, 2013 08:45:01 AM Kelly McLaughlin wrote:
&gt; &gt; Matthew,
&gt; &gt;
&gt; &gt; I find it really surprising that you don't see any difference in behavior
&gt; &gt; when you set delete\\_mode to keep. I think it would be helpful if you
&gt; could
&gt; &gt; outline your specific setup and give the steps to reproduce what you're
&gt; &gt; seeing to be able to make a determination if this represents a bug or
&gt; not.
&gt; &gt; Thanks.
&gt; &gt;
&gt; &gt; Kelly
&gt; Hi Kelly,
&gt;
&gt; Sure, no problem. Hardware wise, I have:
&gt; - An AMD Phenom II X6 Desktop with 16G memory, and a HDD with an SSD
&gt; cache.
&gt; - An Intel Ivy Bridge Dual Core (+HT) Laptop with 16G memory and SSD.
&gt; Both have lots of free memory + disk space for running my tests, and my
&gt; Desktop never seems to be IO bound. Both machines are connected over
&gt; Ethernet
&gt; on the same LAN.
&gt;
&gt; On top of that hardware, both are running two instances of Riak each, all
&gt; forming one 4 node cluster. I'm using the default ring size of 64. I've
&gt; also
&gt; upgraded all the nodes to the latest release, 1.4, using the 1.4 tag from
&gt; Git.
&gt; I'm not using this to seriously benchmark Riak, so I don't think this setup
&gt; should cause any issues. I'm also going to setup a really cluster for
&gt; production use, so ring size is not a concern.
&gt; Each Riak instance uses LevelDB as the datastore, Riak Search is disabled.
&gt; I'm using Riak's PB API for access, and I've bumped up the backlog
&gt; parameter
&gt; to 1024 for now. Originally my program would connect to a single node, but
&gt; recently I've been playing with HAProxy locally, and now I use that to
&gt; connect
&gt; to all four instances. The problem existed before I implemented HAProxy.
&gt; Riak Control is also enabled on one node per computer.
&gt;
&gt; For my application, it effectively stores in Riak two pieces of
&gt; information.
&gt; First it stores a list of keys associated with an object, and then stores
&gt; an
&gt; individual item at each key. I limit the number of keys to 10000 per
&gt; object.
&gt;
&gt; For my test suite, I automatically clean up after each test by listing all
&gt; the
&gt; keys associated with a bucket, and then delete each key individually. I
&gt; only
&gt; store items in two buckets, so this cleans the slate before each run.
&gt;
&gt; The test that has the high chance of failing is testing how the system
&gt; deals
&gt; with inserting 10000 items against one object. The key list remains below
&gt; 1M.
&gt; Occasionally I see other tests fail, but I think this one fails more often
&gt; as
&gt; it stresses the entire system the most. If I stop the automatic cleanup,
&gt; the
&gt; not found key is also not findable by Curl either.
&gt;
&gt; Before posting, I would delete and insert keys, without using a vclock. I
&gt; had
&gt; figured this was safe as I ran with allow\\_mult=true on both buckets, and I
&gt; implemented conflict resolution first. As suggested on this list, I now
&gt; have
&gt; the 10000 item test suite use vclocks from start to finish. However, I
&gt; still
&gt; see this behaviour.
&gt;
&gt; I've attached a program (written in go as that is what I'm using) to this
&gt; email which triggers the behaviour. As far as I understand Riak, it is
&gt; properly fetching vclocks whenever possible. The library I'm using
&gt; (located
&gt; at: github.com/tpjg/goriakpbc ) was just recently updated to ensure that
&gt; vclocks are fetched, even if the item is deleted. I am using an up to date
&gt; version of the library. The program is acts similarly to my app, but
&gt; paired
&gt; down as far as possible. Note that this behaviour is unpredictable, and
&gt; this
&gt; program will sometimes execute fine.
&gt; I only tested this program against the default delete\\_mode setting. Also,
&gt; using HAProxy seems to trigger the issue far more readily, but it happens
&gt; fine
&gt; without it.
&gt;
&gt;
&gt; If there is any other information I can provide to help, let me know.
&gt;
&gt; Thanks,
&gt; --
&gt; Matthew
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;
&gt;
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

