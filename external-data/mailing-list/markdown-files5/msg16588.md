---
title: "Re: Problem with Vector Clocks - inconsistencies encountered in	cluster with shifted real local clocks"
description: ""
project: community
lastmod: 2015-10-01T07:53:11-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg16588"
mailinglist_parent_id: "msg16587"
author_name: "Russell Brown"
project_section: "mailinglistitem"
sent_date: 2015-10-01T07:53:11-07:00
---



On 1 Oct 2015, at 15:45, Zuzana Zatrochova  wrote:

&gt; Thank you for fast reply,
&gt; 
&gt; Could you please specify what do you mean by context sent by client?

When a client reads a value it gets an opaque context too, it must return this 
to riak when it performs an update. In the absence of a context an empty 
context is assumed.

&gt; Do you mean update on the existing object in database?

Yes.

&gt; 
&gt; I see exactly that when allow\\_mult=false, only the highest timestamp value is 
&gt; stored. 
&gt; 
&gt; For me the results are unexpected because the client sees inconsistent values 
&gt; (not from the last write) but there are no partitions and quorum is set to 
&gt; the strongest consistency configurations. In the diagram, it is showed more 
&gt; clearly how shifted clocks generate inconsistent result. 

Inconsistent as in non-deterministic, or just not what you expected?

&gt; 
&gt; Thanks,
&gt; Zuzana
&gt; 
&gt; On 1 October 2015 at 14:18, Russell Brown  wrote:
&gt; I need more time to examine the diagram, but this all looks as expected so 
&gt; far.
&gt; 
&gt; If a client sends no context then it’s write will be a sibling of whatever is 
&gt; stored at the coordinator, as you rightly point out riak treats an incoming 
&gt; clock that is less than a local clock as a sibling.
&gt; If the coordinator is configured to not store siblings then the sibling value 
&gt; with the highest timestamp is stored, I recommend you run riak in either 
&gt; allow\\_mult=true or LWW=true, allow\\_mult=false, in my view, should not be 
&gt; default.
&gt; If two riak nodes do the above, and then replicate their values, the single 
&gt; value with the highest value is stored. Isn’t this what you are seeing? If 
&gt; you depend on time to pick the latest, and nodes’ clocks are out of sync this 
&gt; is the price.
&gt; 
&gt; Is this what you are seeing? Are you seeing results you didn’t expect, or 
&gt; non-deterministic results? Or both?
&gt; 
&gt; Regards
&gt; 
&gt; Russell
&gt; 
&gt; On 1 Oct 2015, at 12:58, Zuzana Zatrochova  wrote:
&gt; 
&gt; &gt; Hi,
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt; We are researching the client-centric consistency features of Riak 
&gt; &gt; database. We encountered a problem with vector clocks implementation. The 
&gt; &gt; vector clocks do not seem to work locally on a machine as expected. We 
&gt; &gt; would like you to confirm if the behavior is desired. First I will describe 
&gt; &gt; the environment of our experiments and then the problem will be presented.
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt; Environment:
&gt; &gt;
&gt; &gt;
&gt; &gt; • Our environment consists of six virtual machines
&gt; &gt; • five machines in Riak cluster, each represent a single Riak 
&gt; &gt; node with Riak database
&gt; &gt; • one machine with java application that simulates multiple 
&gt; &gt; clients communicating with Riak database
&gt; &gt; • Machines are Virtualized VMs by VMware software and have slightly 
&gt; &gt; shifted time to each other (no more than 1 second)
&gt; &gt; • We made experiments with versions riak-1.4.8 and riak-2.1.1. In 
&gt; &gt; riak-1.4.8 app\\_config contains vnode\\_vclocks = true (default setting that 
&gt; &gt; was there when downloaded) in riak-2.1.1 we could not locate configuration 
&gt; &gt; for vnode vclocks either in advanced configurations in documentation or 
&gt; &gt; riak.conf so we assumed it also defaults to true and is no longer enabled 
&gt; &gt; to change
&gt; &gt; • For each experiment we have 500 clients concurrently sending 
&gt; &gt; requests to random node from the cluster. There are 20000 requests per 
&gt; &gt; minute operating only on 20 different keys (load on single key is 16 
&gt; &gt; requests per second (read:write ration = 50:50).
&gt; &gt; • For referenced issue we used quorums R = 1, W = 3; R = 2, W = 2 and 
&gt; &gt; R =3 W = 1
&gt; &gt; • All riak settings are default apart from IP settings and quorum 
&gt; &gt; settings. We added interceptors from riak\\_test module that don’t change the 
&gt; &gt; code and are implemented only for logging purposes (information about 
&gt; &gt; states of nodes), error.log is empty
&gt; &gt;
&gt; &gt; Problem:
&gt; &gt;
&gt; &gt;
&gt; &gt; • It seems that Riak does not use vector clocks locally, only on 
&gt; &gt; global scale. When a data object is created on client side and sent to Riak 
&gt; &gt; database it does not have any vector clocks assigned (more precisely the 
&gt; &gt; function riak\\_object:vclock(UpdObj) = [] and local object: 
&gt; &gt; riak\\_object:vclock(LocalObj) returns the local VC for the local object. 
&gt; &gt; Therefore the function (in 2.1.1 but similar behavior is in 1.4.8) 
&gt; &gt; vclock:descends(NewObject, LocalObject) returns false for all my 
&gt; &gt; experiments with different quorums (Empty vector clocks cannot descend non 
&gt; &gt; empty vector clocks). The behavior leads to merge of contents = creation of 
&gt; &gt; siblings (or resolving the value according to the timestamp not vector 
&gt; &gt; clocks when siblings are not allowed – our configuration)
&gt; &gt; • In our experiments when time on VMs is not synchronized up to 500 
&gt; &gt; milliseconds the situation from picture issue.png sent in attachment 
&gt; &gt; arises. Due to the fact that two objects with the same key are sent to two 
&gt; &gt; different coordinators and coordinators clocks are shifted the later object 
&gt; &gt; is assigned earlier timestamp as the object that was sent before. As the 
&gt; &gt; result of the vector clocks implementation in Riak, the later object is 
&gt; &gt; lost due to the merge of contents where later timestamp (wrong because of 
&gt; &gt; local clock shift) is evaluated as the latest.
&gt; &gt;
&gt; &gt; The question:
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt; Is this the Riak intended behavior? The problem is that even when quorum is 
&gt; &gt; set to prefer consistency and there are no partitions in the cluster there 
&gt; &gt; are still inconsistent requests seen from client perspective = any read 
&gt; &gt; must return the value of the latest finished write or later unfinished 
&gt; &gt; write request. (We did not use the strong\\_consistency feature of riak-2.1.1 
&gt; &gt; version).
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt; Thank you,
&gt; &gt;
&gt; &gt; Zuzana
&gt; &gt;
&gt; &gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; &gt; riak-users mailing list
&gt; &gt; riak-users@lists.basho.com
&gt; &gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt; 
&gt; 


\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

