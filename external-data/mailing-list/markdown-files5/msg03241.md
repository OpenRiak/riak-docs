---
title: "Re: 'not found' after join"
description: ""
project: community
lastmod: 2011-05-05T14:07:49-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg03241"
mailinglist_parent_id: "msg03233"
author_name: "Ben Tilly"
project_section: "mailinglistitem"
sent_date: 2011-05-05T14:07:49-07:00
---


There are solutions to that consistency issue. You can set
allow\\_multi true, have each object have a link to a change history,
and have each change have a record of what changed. The change
history could be done as a singly linked list, where each change is
inserted into a bucket with a randomly generated key.

And then on reading an object, if you find siblings, you can go look
at the change histories, merge them, and come up with a resolved
object.

This is a \\*lot\\* of application logic, but it should be doable.

On Thu, May 5, 2011 at 1:14 PM, Greg Nelson  wrote:
&gt; The future I'd like to see is basically what I initially expected.  That is,
&gt; I can add a single node to an online cluster and clients should not even see
&gt; any effects of this or need to know that it's even happening -- except of
&gt; course the side effects like the added load on the cluster incurred by
&gt; gossiping new ring state, handing off data, etc.  But if no data has
&gt; actually been lost, I don't believe data should ever be unavailable,
&gt; temporarily or not.  And I'd like to be able to, as someone else mentioned,
&gt; add a node and throttle the handoffs and let it trickle over hours or even
&gt; days.
&gt;
&gt; Waving hands and saying that eventually the data will make it is true in
&gt; principle, but in practice if you are following a read/modify/write pattern
&gt; for some objects, you could easily lose data.  e.g., my application writes
&gt; JSON arrays to certain objects, and when it wishes to append something to
&gt; the array, it will read/append/write back.  If that initial read returns
&gt; 404, then a new empty array is created.  This is normal operation.  But if
&gt; that 404 is not a "normal" 404, it will happily create a new empty array,
&gt; append, and write back a single-element array to that key.  Of course there
&gt; could have been a 100 element array in Riak that was just unavailable at the
&gt; time which is now effectively lost.
&gt;
&gt; Anyhow, I do understand the importance of knowing what will happen when
&gt; doing something operationally like adding a node, and I understand that one
&gt; can't naively expect everything to just work like magic.  But the current
&gt; behavior is pretty poorly documented and surprising.  I don't think it was
&gt; even mentioned in the operations webinar!  (Ok, I'll stop beating a dead
&gt; horse.  :))
&gt;
&gt; On Thursday, May 5, 2011 at 12:22 PM, Alexander Sicular wrote:
&gt;
&gt; I'm really loving this thread. Generating great ideas for the way
&gt; things should be... in the future. It seems to me that "the ring
&gt; changes immediately" is actually the problem as Ryan astutely
&gt; mentions. One way the future could look is :
&gt;
&gt; - a new node comes online
&gt; - introductions are made
&gt; - candidate vnodes are selected for migration (&lt;- insert pixie dust magic
&gt; here)
&gt; - the number of simultaneous migrations are configurable, fewer for
&gt; limited interruption or more for quicker completion
&gt; - vnodes are migrated
&gt; - once migration is completed, ownership is claimed
&gt;
&gt; Selecting vnodes for migration is where the unicorn cavalry attack the
&gt; dragons den. If done right(er) the algorithm could be swappable to
&gt; optimize for different strategies. Don't ask me how to implement it,
&gt; I'm only a yellow belt in erlang-fu.
&gt;
&gt; Cheers,
&gt; Alexander
&gt;
&gt; On Thu, May 5, 2011 at 13:33, Ryan Zezeski  wrote:
&gt;
&gt; John,
&gt; All great points.  The problem is that the ring changes immediately when a
&gt; node is added.  So now, all the sudden, the preflist is potentially pointing
&gt; to nodes that don't have the data and they won't have that data until
&gt; handoff occurs.  The faster that data gets transferred, the less time your
&gt; clients have to hit 'notfound'.
&gt; However, I agree completely with what you're saying.  This is just a side
&gt; effect of how the system currently works.  In a perfect world we wouldn't
&gt; care how long handoff takes and we would also do some sort of automatic
&gt; congestion control akin to TCP Reno or something.  The preflist would still
&gt; point to the "old" partitions until all data has been successfully handed
&gt; off, and then and only then would we flip the switch for that vnode.  I'm
&gt; pretty sure that's where we are heading (I say "pretty sure" b/c I just
&gt; joined the team and haven't been heavily involved in these specific talks
&gt; yet).
&gt; It's all coming down the pipe...
&gt; As for your specific I/O question re handoff\\_concurrecy, you might be right.
&gt;  I would think it depends on hardware/platform/etc.  I was offering it as a
&gt; possible stopgap to minimize Greg's pain.  It's certainly a cure to a
&gt; symptom, not the problem itself.
&gt; -Ryan
&gt;
&gt; On Thu, May 5, 2011 at 1:10 PM, John D. Rowell  wrote:
&gt;
&gt; Hi Ryan, Greg,
&gt;
&gt; 2011/5/5 Ryan Zezeski 
&gt;
&gt; 1. For example, riak\\_core has a `handoff\\_concurrency` setting that
&gt; determines how many vnodes can concurrently handoff on a given node.  By
&gt; default this is set to 4.  That's going to take a while with your 2048
&gt; vnodes and all :)
&gt;
&gt; Won't that make the handoff situation potentially worse? From the thread I
&gt; understood that the main problem was that the cluster was shuffling too much
&gt; data around and thus becoming unresponsive and/or returning unexpected
&gt; results (like "not founds"). I'm attributing the concerns more to an
&gt; excessive I/O situation than to how long the handoff takes. If the handoff
&gt; can be made transparent (no or little side effects) I don't think most
&gt; people will really care (e.g. the "fix the cluster tomorrow" anecdote).
&gt;
&gt; How about using a percentage of available I/O to throttle the vnode
&gt; handoff concurrency? Start with 1, and monitor the node's I/O (kinda like
&gt; 'atop' does, collection CPU, disk and network metrics), if it is below the
&gt; expected usage, then increase the vnode handoff concurrency, and vice-versa.
&gt;
&gt; I for one would be perfectly happy if the handoff took several hours (even
&gt; days) if we could maintain the core riak\\_kv characteristics intact during
&gt; those events. We've all seen looooong RAID rebuild times, and it's usually
&gt; better to just sit tight and keep the rebuild speed low (slower I/O) while
&gt; keeping all of the dependent systems running smoothly.
&gt;
&gt; cheers
&gt; -jd
&gt;
&gt;
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;
&gt;
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;
&gt;

\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

