---
title: "Re: Using withoutFetch with DomainBucket"
description: ""
project: community
lastmod: 2013-03-12T11:06:13-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg10380"
mailinglist_parent_id: "msg10379"
author_name: "Brian Roach"
project_section: "mailinglistitem"
sent_date: 2013-03-12T11:06:13-07:00
---


Daniel -

Nothing detects whether there is a vclock or not. If there isn't one
provided (the value is `null` in Java), then one isn't sent to Riak -
it is not a requirement for a store operation for it to be present. If
an object exists when such a store is performed and allow\\_multi=true
for the bucket, then a sibling is created.

The .withoutFetch() method was added to the StoreObject as a requested
feature. It is meant for when you are storing an object that was
previously fetched from Riak and want to avoid doing another fetch. If
that previous fetch returned nothing (the key was not found) then the
vector clock will be null.

When talking about deleted keys ... unless you change the default
`delete\\_mode` in Riak's app.config, you're not usually going to get a
tombstone - they are reaped after 3s. Unless either you do a fetch
immediately following a delete, you're doing store operations without
vclocks with allow\\_multi=true for the bucket (which is basically
"doing it wrong") immediately after a delete and a sibling gets
created, or hit a very small window with multiple writers under heavy
load where the read/write cycle interleaves with a delete and a
tombstone sibling gets created.

With that being said, yes, unless you set 'returnDeletedVClock(true)`
they are silently discarded by the Java client and not passed to the
Converter. If that has been set, the default JSONConverter will return
a new instance of whatever POJO is being used (if possible - if
there's not a default constructor it will throw an exception) and then
set a @RiakTombstone annotated boolean field to `true` if one exists.
It detects this by calling the .isDeleted() method of the returned
IRiakObject.

- Roach

On Tue, Mar 12, 2013 at 9:43 AM, Daniel Iwan  wrote:
&gt; Brian,
&gt;
&gt; Where I got lost was the fact that I was using custom Converter and I did
&gt; not do anything with vclock passed into fromDomain().
&gt; That was undetected because at the same time I wasn't using withoutFetch,
&gt; which I believe is the only moment where missing @RiakVClock annotation
&gt; can be detected. Normally when JSONConverter is used missing @RiakVClock
&gt; would also be detected.
&gt; Could you confirm?
&gt;
&gt; Few additional, related questions:
&gt; - if I use byte[] or VClock field and use withoutFetch() what is default
&gt; value it should be set to (since it will be extracted via StoreObject)?
&gt; - if I want to avoid overwriting deleted keys, I guess I need to set
&gt; returnDeletedVClock as below,
&gt; DomainBucketBuilder builder = DomainBucket.builder(bucket,
&gt; Custom.class)
&gt; builder.returnDeletedVClock(true);
&gt;
&gt; and then check isDeleted on sibblings and use ConditionalStoreMutation to
&gt; return false id one of he sibblings has that flag set to true?
&gt; I believe it needs to use VClock of deleted sibbling as well?
&gt;
&gt; Thanks
&gt; Daniel
&gt;
&gt;
&gt;
&gt;&gt; The .withoutFetch() method isn't available when using the DomanBucket.
&gt;&gt;
&gt;&gt; As for the vector clock, when using .withoutFetch() the .execute()
&gt;&gt; method of StoreObject is going to extract the vector clock from the
&gt;&gt; POJO returned from your Mutation by looking for a VectorClock or
&gt;&gt; byte[] field that is annotated with @RiakVClock. It is then passed to
&gt;&gt; the Converter's .fromDomain() method as an argument. If you are
&gt;&gt; storing an object you previously fetched from Riak, that vector clock
&gt;&gt; and annotation needs to be there.
&gt;&gt;
&gt;&gt; The easiest way to implement that is:
&gt;&gt; 1. Have a VectorClock or byte[] field in your POJO annotated with
&gt;&gt; @RiakVClock
&gt;&gt;
&gt;&gt; 2. When you fetch, in the .toDomain() method of your Converter have
&gt;&gt; the line of code you noted.
&gt;&gt;
&gt;&gt; 3. When you store, the vector clock stored in that field will be
&gt;&gt; passed to the .fromDomain() method of your Converter. Make sure to
&gt;&gt; call the .withVClock(vclock) method of the RiakObjectBuilder or
&gt;&gt; explicitly set it in the IRiakObject being returned.
&gt;&gt;
&gt;&gt; - Roach
&gt;&gt;
&gt;&gt;
&gt;&gt; On Fri, Mar 8, 2013 at 3:31 PM, Daniel Iwan  wrote:
&gt;&gt; &gt; Somehow I cannot find a way to avoid pre-fetch during store operation
&gt;&gt; &gt; (Java
&gt;&gt; &gt; client).
&gt;&gt; &gt; I know in StoreObject there is withoutFetch method for that purpose but
&gt;&gt; &gt; I
&gt;&gt; &gt; cannot find corresponding method/property in DomainBucket or
&gt;&gt; &gt; DomainBucketBuilder
&gt;&gt; &gt;
&gt;&gt; &gt; Am I missing something?
&gt;&gt; &gt;
&gt;&gt; &gt; Also on related note when withoutFetch is used I guess I need to provide
&gt;&gt; &gt; annotated RiakVClock field and use something like:
&gt;&gt; &gt;
&gt;&gt; &gt; VClockUtil.setVClock(domainObject, riakObject.getVClock());
&gt;&gt; &gt;
&gt;&gt; &gt; in my Converter. Is that right or is there better way to do it?
&gt;&gt; &gt;
&gt;&gt; &gt;
&gt;&gt; &gt; I'm using Riak Java client 1.1.0
&gt;&gt; &gt;
&gt;&gt; &gt; Thanks
&gt;&gt; &gt; Daniel
&gt;&gt; &gt;
&gt;&gt; &gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt; &gt; riak-users mailing list
&gt;&gt; &gt; riak-users@lists.basho.com
&gt;&gt; &gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt; &gt;
&gt;
&gt;

\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

