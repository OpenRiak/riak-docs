---
title: "Re: Evolving data model"
description: ""
project: community
lastmod: 2012-09-19T12:45:20-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg08599"
mailinglist_parent_id: "msg08598"
author_name: "Alexander Sicular"
project_section: "mailinglistitem"
sent_date: 2012-09-19T12:45:20-07:00
---


I'm of the opinion that the answer is somewhere on the spectrum of maintain 
code that can read all versions and migrating your data to the latest version. 

Really you could do both. Just keep appropriate vs info in your data. 
Personally, I lean towards the former. If you modularize your code well enough 
you can infinitely deal with new versions, which depending on your application 
may be something you have to do. 


@siculars
http://siculars.posterous.com

Sent from my iRotaryPhone

On Sep 19, 2012, at 15:30, Deepak Balasubramanyam  wrote:

&gt; It really depends on your use case. Guido's tips on not-null and 
&gt; ignore-properties will help. With JsonIgnoreProperties you can also specify 
&gt; which ones you would like to ignore. That helps check ignoring properties 
&gt; that you know \\*should\\* exist. 
&gt; 
&gt; Converting your documents to a new format is a lot of work. I assume your 
&gt; buckets are filled with millions of keys that need to take on a new format. 
&gt; The complexity depends on your Q / R / W values and the format of your keys 
&gt; (are they sequential / random with a uniform distribution ?). You will need 
&gt; to take into account the eventual consistency of the system and how the 
&gt; migration should be done on a live environment. It can get messy. Performance 
&gt; would be a concern too since you will be iterating through all keys in a 
&gt; bucket which Riak frowns upon. Not to mention recreating indexes / links / 
&gt; metadata (if applicable).
&gt; 
&gt; It will be easier to just keep adding attributes and ignore the ones that you 
&gt; know older models will not understand. Think of the model as a JSON object 
&gt; that is like a protobuf message (a .proto file if you have come across one) 
&gt; or a representation of a row on a table. It is easy to add data, but when you 
&gt; delete something and someone's model was depending on it, it can get ugly. 
&gt; 
&gt; Thanks
&gt; Deepak Bala
&gt; 
&gt; On Wed, Sep 19, 2012 at 10:03 PM, Guido Medina  
&gt; wrote:
&gt; We have done similar things, but it always depends on the available tools, 
&gt; your requirements and needs, I will give you a short example, our main 
&gt; application uses a standard SQL, for historical data we use Riak, data that 
&gt; is not changing, for example, audit trails, daily chunks from different 
&gt; sources and so on.
&gt; 
&gt; We make sure our data is 100% JSON compatible, and our tools are the 
&gt; available JSON libraries, it is fair easy to add new "columns" to your data 
&gt; (I know, columns right?), and keep your fetching still valid by ignoring 
&gt; deprecated properties and when writing back just overwriting old data, that 
&gt; way, your schema can change all the time without losing old data and evolving 
&gt; at the same time.
&gt; 
&gt; 2i is fine to stamp and migrate if you wish, since it makes your code tedious 
&gt; if you need to be checking for nulls all the time, so for migration you can 
&gt; simply use JSON transformers, from this property to another (from old to new 
&gt; schema) without even coding, but it will be up to your tools.
&gt; 
&gt; In Java for example all that can be aid with Jackson which happens to be the 
&gt; defacto JSON Riak Java client provider, here is a list of few annotations to 
&gt; accomplish most of the things are you worried about:
&gt; 
&gt; 
&gt; @JsonIgnoreProperties(ignoreUnknown=true) (Say an old property just got 
&gt; deprecated and you want your POJO not to throw exceptions while converting 
&gt; from JSON to your POJO)
&gt; @JsonSerialize(include=JsonSerialize.Inclusion.NON\\_NULL) (Saves lot of space)
&gt; 
&gt; 
&gt; @Override
&gt; @JsonProperty("ranges") (Say, a property just changed its type, and because 
&gt; of that, I need to map it to a new property, in this case, I don't have a 
&gt; list of integers anymore but a list of ranges, so a transformation is 
&gt; required...)
&gt; public List getEntries()
&gt; {
&gt; return intRangeCollection.getRangesAsArray();
&gt; }
&gt; 
&gt; @JsonProperty("ranges")
&gt; public void setEntries(final List entries)
&gt; {
&gt; 
&gt; this.intRangeCollection=IntRangeCollection.buildIntRangesCollectionFromArrays(entries);
&gt; }
&gt; 
&gt; Well, there is so much I could show you, but, examples are limitless, so 
&gt; depending on your use cases, you will figure your own ways to keep your code 
&gt; kind of clean and your schema changing constantly.
&gt; 
&gt; Hope that helps,
&gt; 
&gt; Guido.
&gt; 
&gt; 
&gt; On 19/09/12 16:08, Pinney Colton wrote:
&gt;&gt; Wow, that's a pretty big question.
&gt;&gt; 
&gt;&gt; IMO, it depends upon what you're doing with your data. Personally, I'm 
&gt;&gt; storing up to 4 different "versions" of the same data in Riak, each version 
&gt;&gt; is optimized for different types of analytical operations.
&gt;&gt; 
&gt;&gt; That's probably not ideal for everybody. Heck, storing 4 copies of my data 
&gt;&gt; isn't even optimal for me from a storage perspective - but it does help 
&gt;&gt; optimize performance of different queries. I care more about that than disk 
&gt;&gt; or memory.
&gt;&gt; 
&gt;&gt; On Tue, Sep 18, 2012 at 5:55 PM, Allen Johnson  wrote:
&gt;&gt; Hey everyone,
&gt;&gt; 
&gt;&gt; I'm beginning to experiment with Riak and I'm trying to better
&gt;&gt; understand how to model my data. One question I have at the moment is
&gt;&gt; how to evolve my data with a data store such as Riak? I know that
&gt;&gt; it's schema-less and that I can add new fields as needed but I'm
&gt;&gt; thinking more about the existing documents.
&gt;&gt; 
&gt;&gt; For example, say hypothetically, that I have a fairly successful
&gt;&gt; riak-based app. As the application code continues to evolve over
&gt;&gt; several versions I begin to find a "better" way to model my data. By
&gt;&gt; this time I have already stored many, many documents. What is the
&gt;&gt; appropriate path here? Do I version my documents with metadata and
&gt;&gt; rely on my application code to continue to deal with old-style
&gt;&gt; documents -- or do I perform some sort of bulk transformation on these
&gt;&gt; existing documents?
&gt;&gt; 
&gt;&gt; Thanks,
&gt;&gt; Allen
&gt;&gt; 
&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt; 
&gt;&gt; 
&gt;&gt; 
&gt;&gt; -- 
&gt;&gt; Pinney H. Colton
&gt;&gt; Bitwise Data, LLC
&gt;&gt; +1.763.220.0793 (o)
&gt;&gt; +1.651.492.0152 (m)
&gt;&gt; http://www.bitwisedata.com
&gt;&gt; 
&gt;&gt; 
&gt;&gt; 
&gt;&gt; 
&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt; 
&gt; 
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt; 
&gt; 
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

