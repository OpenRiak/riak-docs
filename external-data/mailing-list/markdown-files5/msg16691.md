---
title: "Re: Using Bucket Data Types slowed insert performance"
description: ""
project: community
lastmod: 2015-10-21T02:53:46-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg16691"
mailinglist_parent_id: "msg16680"
author_name: "Torben Hoffmann"
project_section: "mailinglistitem"
sent_date: 2015-10-21T02:53:46-07:00
---


Hi Russell,

I'm about start digging into profiling of Riak in order to have a way to 
pin-point
bottlenecks, so I am very interested in all efforts related to this.

How do you decide what and how to optimise the Map?
What sort of measurements do you do?

Cheers,
Torben

Russell Brown writes:

&gt; Honestly, right now we need to work on optimising the Map. We do have a 
&gt; smaller/faster map in a branch that we’re working on shipping soon, as well 
&gt; as other optimisation planned.
&gt;
&gt; Does your use case have you adding and removing registers, or is this 
&gt; basically a set schema of registers per key? If you’re not removing/re-adding 
&gt; registers, I would use a CRDT not in Riak, but in your application.
&gt;
&gt; CRDTs in Riak make sense for causal data types: where the actor management is 
&gt; onerous for the client. What you’re modelling using the map looks like Last 
&gt; Write Wins element Set. This is a pretty simple CRDT to make in your own 
&gt; programming language/application, and you can write this data type yourself, 
&gt; and simply store the binary representation of it in riak, using riak’s 
&gt; siblings (allow\\_mult=true.) hen your application gets siblings values, 
&gt; simply run you application code’s merge function.
&gt;
&gt; There are details of the last write elements set here 
&gt; https://github.com/soundcloud/roshi, but all you need to is store a pair 
&gt; (element, TS) for each member in the set. If you’re going to store removing 
&gt; registers it gets more complex…are you?
&gt;
&gt; Cheers
&gt;
&gt; Russell
&gt;
&gt; On 20 Oct 2015, at 20:25, Dennis Nicolay  wrote:
&gt;
&gt;&gt;
&gt;&gt; ResultObject cdr;
&gt;&gt; while (queued.TryDequeue(out cdr))
&gt;&gt; {
&gt;&gt; long beforeProcessing = DateTime.Now.Ticks;
&gt;&gt; UpdateMap.Builder builder = BuildMapObject(bucket, 
&gt;&gt; cdr);
&gt;&gt; UpdateMap cmd = builder.Build();
&gt;&gt; RiakResult rslt = client.Execute(cmd);
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt; private static UpdateMap.Builder BuildMapObject(string bucketname, 
&gt;&gt; ResultObject cdr )
&gt;&gt; {
&gt;&gt;
&gt;&gt; var builder = new UpdateMap.Builder()
&gt;&gt; .WithBucketType("maps")
&gt;&gt; .WithBucket(bucketname)
&gt;&gt; .WithKey(cdr.CdrKey);
&gt;&gt; var mapOperation = new UpdateMap.MapOperation();
&gt;&gt; mapOperation.SetRegister("FileTimeStamp", 
&gt;&gt; cdr.CdrValue.FileTimeStamp.ToString());
&gt;&gt; mapOperation.SetRegister("AuditId", 
&gt;&gt; cdr.CdrValue.AuditId.ToString());
&gt;&gt; mapOperation.SetRegister("CdrId", cdr.CdrValue.CdrId.ToString());
&gt;&gt; mapOperation.SetRegister("IsBillable", 
&gt;&gt; cdr.CdrValue.IsBillable.ToString());
&gt;&gt; mapOperation.SetRegister("SwitchId", 
&gt;&gt; cdr.CdrValue.SwitchId.ToString());
&gt;&gt; mapOperation.SetRegister("SwitchDescription", 
&gt;&gt; cdr.CdrValue.SwitchDescription.ToString());
&gt;&gt; mapOperation.SetRegister("SequenceNumber", 
&gt;&gt; cdr.CdrValue.SequenceNumber.ToString());
&gt;&gt; mapOperation.SetRegister("CallDirection", 
&gt;&gt; cdr.CdrValue.CallDirection.ToString());
&gt;&gt; mapOperation.SetRegister("CallTypeId", 
&gt;&gt; cdr.CdrValue.CallTypeId.ToString());
&gt;&gt; mapOperation.SetRegister("Partition", 
&gt;&gt; cdr.CdrValue.Partition.ToString());
&gt;&gt; mapOperation.SetRegister("CustomerTrunkId", 
&gt;&gt; cdr.CdrValue.CustomerTrunkId.ToString());
&gt;&gt; mapOperation.SetRegister("OrigIpAddress", 
&gt;&gt; cdr.CdrValue.OrigIpAddress.ToString());
&gt;&gt; mapOperation.SetRegister("OrigPort", 
&gt;&gt; cdr.CdrValue.OrigPort.ToString());
&gt;&gt; mapOperation.SetRegister("SupplierTrunkId", 
&gt;&gt; cdr.CdrValue.SupplierTrunkId.ToString());
&gt;&gt; mapOperation.SetRegister("TermIpAddress", 
&gt;&gt; cdr.CdrValue.TermIpAddress.ToString());
&gt;&gt; mapOperation.SetRegister("TermPort", 
&gt;&gt; cdr.CdrValue.TermPort.ToString());
&gt;&gt; mapOperation.SetRegister("Ani", cdr.CdrValue.Ani.ToString());
&gt;&gt; mapOperation.SetRegister("OutpulseNumber", 
&gt;&gt; cdr.CdrValue.OutpulseNumber.ToString());
&gt;&gt; mapOperation.SetRegister("SubscriberNumber", 
&gt;&gt; cdr.CdrValue.SupplierTrunkId.ToString());
&gt;&gt; mapOperation.SetRegister("CallingNoa", 
&gt;&gt; cdr.CdrValue.CallingNoa.ToString());
&gt;&gt; mapOperation.SetRegister("DialedNoa", 
&gt;&gt; cdr.CdrValue.DialedNoa.ToString());
&gt;&gt; mapOperation.SetRegister("OutpulseNoa", 
&gt;&gt; cdr.CdrValue.OutpulseNumber.ToString());
&gt;&gt; mapOperation.SetRegister("TreatmentCode", 
&gt;&gt; cdr.CdrValue.TreatmentCode.ToString());
&gt;&gt; mapOperation.SetRegister("CompletionCode", 
&gt;&gt; cdr.CdrValue.CompletionCode.ToString());
&gt;&gt; mapOperation.SetRegister("CustomerName", 
&gt;&gt; cdr.CdrValue.CustomerName.ToString());
&gt;&gt; mapOperation.SetRegister("CustId", 
&gt;&gt; cdr.CdrValue.CustId.ToString());
&gt;&gt; mapOperation.SetRegister("CustContractId", 
&gt;&gt; cdr.CdrValue.CustContractId.ToString());
&gt;&gt; mapOperation.SetRegister("CustCountryCode", 
&gt;&gt; cdr.CdrValue.CustCountryCode.ToString());
&gt;&gt; mapOperation.SetRegister("CustDuration", 
&gt;&gt; cdr.CdrValue.CustDuration.ToString());
&gt;&gt; mapOperation.SetRegister("Price", cdr.CdrValue.Price.ToString());
&gt;&gt; mapOperation.SetRegister("BasePrice", 
&gt;&gt; cdr.CdrValue.BasePrice.ToString());
&gt;&gt; mapOperation.SetRegister("BillingDestinationName", 
&gt;&gt; cdr.CdrValue.BillingDestinationName.ToString());
&gt;&gt; mapOperation.SetRegister("BillingGroupId", 
&gt;&gt; cdr.CdrValue.BillingGroupId.ToString());
&gt;&gt; mapOperation.SetRegister("SupplierName", 
&gt;&gt; cdr.CdrValue.SupplierName.ToString());
&gt;&gt; mapOperation.SetRegister("SuppId", 
&gt;&gt; cdr.CdrValue.SuppId.ToString());
&gt;&gt; mapOperation.SetRegister("SuppContractId", 
&gt;&gt; cdr.CdrValue.SuppContractId.ToString());
&gt;&gt; mapOperation.SetRegister("SuppCountryCode", 
&gt;&gt; cdr.CdrValue.SuppCountryCode.ToString());
&gt;&gt; mapOperation.SetRegister("SuppDuration", 
&gt;&gt; cdr.CdrValue.SuppDuration.ToString());
&gt;&gt; mapOperation.SetRegister("Cost", cdr.CdrValue.Cost.ToString());
&gt;&gt; mapOperation.SetRegister("BaseCost", 
&gt;&gt; cdr.CdrValue.BaseCost.ToString());
&gt;&gt; mapOperation.SetRegister("RoutingDestinationName", 
&gt;&gt; cdr.CdrValue.RoutingDestinationName.ToString());
&gt;&gt; mapOperation.SetRegister("RoutingGroupId", 
&gt;&gt; cdr.CdrValue.RoutingGroupId.ToString());
&gt;&gt; mapOperation.SetRegister("RouteToCountryCode", 
&gt;&gt; cdr.CdrValue.RouteToCountryCode.ToString());
&gt;&gt; mapOperation.SetRegister("Pdd", cdr.CdrValue.Pdd.ToString());
&gt;&gt; mapOperation.SetRegister("RealDuration", 
&gt;&gt; cdr.CdrValue.RealDuration.ToString());
&gt;&gt; mapOperation.SetRegister("StartTime", 
&gt;&gt; cdr.CdrValue.StartTime.ToString());
&gt;&gt; mapOperation.SetRegister("EndTime", 
&gt;&gt; cdr.CdrValue.EndTime.ToString());
&gt;&gt; mapOperation.SetRegister("NumberCalled", 
&gt;&gt; cdr.CdrValue.NumberCalled.ToString());
&gt;&gt; mapOperation.SetRegister("CallingLataOcn", 
&gt;&gt; cdr.CdrValue.CallingLataOcn.ToString());
&gt;&gt; mapOperation.SetRegister("DialedLataOcn", 
&gt;&gt; cdr.CdrValue.DialedLataOcn.ToString());
&gt;&gt; mapOperation.SetRegister("LrnLataOcn", 
&gt;&gt; cdr.CdrValue.LrnLataOcn.ToString());
&gt;&gt; mapOperation.SetRegister("CustomerPrefix", 
&gt;&gt; cdr.CdrValue.CustomerPrefix.ToString());
&gt;&gt; mapOperation.SetRegister("SupplierPrefix", 
&gt;&gt; cdr.CdrValue.SupplierPrefix.ToString());
&gt;&gt; mapOperation.SetRegister("OriginationCountryCode", 
&gt;&gt; cdr.CdrValue.OriginationCountryCode.ToString());
&gt;&gt; mapOperation.SetRegister("OriginationCost", 
&gt;&gt; cdr.CdrValue.OriginationCost.ToString());
&gt;&gt; mapOperation.SetRegister("FixedPricePerCall", 
&gt;&gt; cdr.CdrValue.FixedPricePerCall.ToString());
&gt;&gt; mapOperation.SetRegister("FixedCostPerCall", 
&gt;&gt; cdr.CdrValue.FixedCostPerCall.ToString());
&gt;&gt; mapOperation.SetRegister("InvoiceId", 
&gt;&gt; cdr.CdrValue.InvoiceId.ToString());
&gt;&gt; mapOperation.SetRegister("BusinessId", 
&gt;&gt; cdr.CdrValue.BusinessId.ToString());
&gt;&gt;
&gt;&gt; builder.WithMapOperation(mapOperation);
&gt;&gt; return builder;
&gt;&gt; }
&gt;&gt;
&gt;&gt;
&gt;&gt; From: Christopher Mancini [mailto:cmanc...@basho.com]
&gt;&gt; Sent: Tuesday, October 20, 2015 11:52 AM
&gt;&gt; To: Mark Schmidt; Alexander Sicular; Dennis Nicolay
&gt;&gt; Cc: riak-users@lists.basho.com
&gt;&gt; Subject: Re: Using Bucket Data Types slowed insert performance
&gt;&gt;
&gt;&gt; Hi Mark / Dennis,
&gt;&gt;
&gt;&gt; Can you provide the snippet of the code that puts a 5k record onto Riak as a 
&gt;&gt; map?
&gt;&gt;
&gt;&gt; Chris
&gt;&gt;
&gt;&gt; On Tue, Oct 20, 2015 at 11:30 AM Mark Schmidt  wrote:
&gt;&gt; Hi folks, sorry for the confusion.
&gt;&gt;
&gt;&gt; Our scenario is as follows:
&gt;&gt;
&gt;&gt; We have a 6 node development cluster running on its own network segment 
&gt;&gt; using HAProxy to facilitate load-balancing across the nodes. A single 
&gt;&gt; Riak-dot-NET client service is performing the insert operations from 
&gt;&gt; dedicated hardware located within the same network segment. We have basic 
&gt;&gt; network throughput capabilities of 100 Mbit with an average speed achievable 
&gt;&gt; of 75 Mbit.
&gt;&gt;
&gt;&gt; The data we are attempting to insert is composed of phone call record 
&gt;&gt; receipts from telephone carriers. These records are batched and written to a 
&gt;&gt; flat file for incorporation into our reporting engine. 1) Our Riak client 
&gt;&gt; process takes a flat file (In this case, a 40MB collection of records, each 
&gt;&gt; record being approximately 5k in size) and parses the entire file so each 
&gt;&gt; record can be added to a local .NET queue.
&gt;&gt; 2) Once the entire file has been parsed and each record loaded into the 
&gt;&gt; local queue, 20 threads are spawned and connections are opened to our Riak 
&gt;&gt; nodes via the HAProxy.
&gt;&gt; 3) Each thread will pull a 5k record from the queue on a first come first 
&gt;&gt; served basis and perform a put to the Riak environment.
&gt;&gt;
&gt;&gt; When first testing our client insert process, we were pushing the 5K records 
&gt;&gt; as whole strings into the Riak environment. Network throughput topped out at 
&gt;&gt; around 80 Mbits with a total load time of 90 seconds for 149k records. When 
&gt;&gt; the client process was modified (same queuing and de-queuing methods) so 
&gt;&gt; that a map datatype bucket would be created and keys stored as registers, we 
&gt;&gt; saw network throughput drop to around 10 Mbit with total upload time 
&gt;&gt; increase to around 270 seconds for the 149k records.
&gt;&gt;
&gt;&gt; It appears as though we’ve either encountered a potential bottleneck 
&gt;&gt; unrelated to network throughput, or we’re just seeing an expected processing 
&gt;&gt; penalty for our use of Riak datatypes. Please note, we’re configuring Zabbix 
&gt;&gt; so we can monitor disk IO on each node as processor and memory resources 
&gt;&gt; don’t appear to be the culprit either.
&gt;&gt;
&gt;&gt; If the reduction in processing speed is a natural consequence to utilizing 
&gt;&gt; Riak data types, is the inter-node network the optimum place to increase 
&gt;&gt; resources? Our eventual datacenter implementation will support speeds of 
&gt;&gt; over 40 Gbit for inter-node communication. We’re just trying to identify 
&gt;&gt; which levers from an operational standpoint we can throw to boost 
&gt;&gt; performance, or if our client implementation is suspect.
&gt;&gt;
&gt;&gt; You bring up some excellent points regarding our use of CRDTs. In our case, 
&gt;&gt; the call data records are mutable as they are subject to changes by phone 
&gt;&gt; carriers for billing error corrections, incorrect data and a host of other 
&gt;&gt; reasons. We may be better served by treating the records as immutable and 
&gt;&gt; performing wide scale record removal and “reprocessing” in the event changes 
&gt;&gt; to existing records are received/requested.
&gt;&gt;
&gt;&gt; Thank you,
&gt;&gt;
&gt;&gt; Mark Schmidt
&gt;&gt;
&gt;&gt; From: Alexander Sicular [mailto:sicul...@gmail.com]
&gt;&gt; Sent: Tuesday, October 20, 2015 10:55 AM
&gt;&gt; To: Dennis Nicolay 
&gt;&gt; Cc: Christopher Mancini ; riak-users@lists.basho.com; 
&gt;&gt; Mark Schmidt 
&gt;&gt;
&gt;&gt; Subject: Re: Using Bucket Data Types slowed insert performance
&gt;&gt;
&gt;&gt; Let's talk about Riak data types for a moment. Riak data types are 
&gt;&gt; collectively implementations of what academia refer to as CRDT's (convergent 
&gt;&gt; or conflict free replicated data types.) The key benefit a CRDT offers, over 
&gt;&gt; a traditional KV by contrast, is in automatic conflict resolution. The 
&gt;&gt; various CRDT's provided in Riak have specific conflict resolution 
&gt;&gt; strategies. This does not come for free. There is a computational cost 
&gt;&gt; associated with CRDT's. If your use case requires automated conflict 
&gt;&gt; resolution strategies than CRDT's are a good fit. Internally CRDT's rely on 
&gt;&gt; vector clocks (see DVV's in the documentation) to resolve conflict.
&gt;&gt;
&gt;&gt; Considering your ETL use case I'm going to presume that your data is 
&gt;&gt; immutable (I could very well be wrong here.) If your data is immutable I 
&gt;&gt; would consider simply using a KV and not paying the CRDT computational 
&gt;&gt; penalty (and possibly even the write once bucket.) The CRDT penalty you pay 
&gt;&gt; is obviously subjective to your use case, configuration, hw deployment etc.
&gt;&gt;
&gt;&gt; Hope that helps!
&gt;&gt; -Alexander
&gt;&gt;
&gt;&gt;
&gt;&gt; @siculars
&gt;&gt; http://siculars.posthaven.com
&gt;&gt;
&gt;&gt; Sent from my iRotaryPhone
&gt;&gt;
&gt;&gt; On Oct 20, 2015, at 12:39, Dennis Nicolay  wrote:
&gt;&gt;
&gt;&gt; Hi Alexander,
&gt;&gt;
&gt;&gt; I’m parsing the file and storing each row with own key in a map datatype 
&gt;&gt; bucket and each column is a register.
&gt;&gt;
&gt;&gt; Thanks,
&gt;&gt; Dennis
&gt;&gt;
&gt;&gt; From: Alexander Sicular [mailto:sicul...@gmail.com]
&gt;&gt; Sent: Tuesday, October 20, 2015 10:34 AM
&gt;&gt; To: Dennis Nicolay
&gt;&gt; Cc: Christopher Mancini; riak-users@lists.basho.com
&gt;&gt; Subject: Re: Using Bucket Data Types slowed insert performance
&gt;&gt;
&gt;&gt; Hi Dennis,
&gt;&gt;
&gt;&gt; It's a bit unclear what you are trying to do here. Are you 1. uploading the 
&gt;&gt; entire file and saving it to one key with the value being the file? Or are 
&gt;&gt; you 2. parsing the file and storing each row as a register in a map?
&gt;&gt;
&gt;&gt; Either of those approaches are not appropriate in Riak KV. For the first 
&gt;&gt; case I would point you to Riak S2 which is designed to manage large binary 
&gt;&gt; object storage. You can keep the large file as a single addressable entity 
&gt;&gt; and access it via Amazon S3 or Swift protocol. For the second case I would 
&gt;&gt; consider maintaining one key (map) per row in the file and have a register 
&gt;&gt; per column in the row. Or not use Riak data types (maps, sets, registers, 
&gt;&gt; flags and counters) and simply keep each row in the file as a KV in Riak 
&gt;&gt; either as a raw string or as a serialized json string. ETL'ing out of 
&gt;&gt; relational databases and into Riak is a very common use case and often 
&gt;&gt; implemented in the fashion I described.
&gt;&gt;
&gt;&gt; As Chris mentioned, soft upper bound on value size should be 1MB. I say soft 
&gt;&gt; because we won't enforce it although there are settings in the config that 
&gt;&gt; can be changed to enforce it (default 5MB warning, 50MB reject I believe.)
&gt;&gt;
&gt;&gt; Best,
&gt;&gt; Alexander
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt; @siculars
&gt;&gt; http://siculars.posthaven.com
&gt;&gt;
&gt;&gt; Sent from my iRotaryPhone
&gt;&gt;
&gt;&gt; On Oct 20, 2015, at 10:22, Christopher Mancini  wrote:
&gt;&gt;
&gt;&gt; Hi Dennis,
&gt;&gt;
&gt;&gt; I am not the most experienced, but what I do know is that a file that size 
&gt;&gt; causes a great deal of network chatter because it has to handoff that data 
&gt;&gt; to the other nodes in the network and will cause delays in Riak's ability to 
&gt;&gt; send and confirm consistency across the ring. Typically we recommend that 
&gt;&gt; you try to structure your objects to around 1mb or less to ensure consistent 
&gt;&gt; performance. That max object size can vary of course based on your network / 
&gt;&gt; server specs and configuration.
&gt;&gt;
&gt;&gt; I hope this helps.
&gt;&gt;
&gt;&gt; Chris
&gt;&gt;
&gt;&gt; On Tue, Oct 20, 2015 at 8:18 AM Dennis Nicolay  wrote:
&gt;&gt; Hi,
&gt;&gt;
&gt;&gt; I’m using .net RiakClient 2.0 to insert a 44mb delimited file with 139k rows 
&gt;&gt; of data into riak. I switched to a map bucket data type with registers. 
&gt;&gt; It is taking about 3 times longer to insert into this bucket vs non data 
&gt;&gt; typed bucket. Any suggestions?
&gt;&gt;
&gt;&gt; Thanks in advance,
&gt;&gt; Dennis
&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;
&gt;
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

--
Torben Hoffmann
Architect, basho.com
M: +45 25 14 05 38

\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

