---
title: "Re: Problem with Vector Clocks - inconsistencies encountered in	cluster with shifted real local clocks"
description: ""
project: community
lastmod: 2015-10-01T08:25:16-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg16589"
mailinglist_parent_id: "msg16588"
author_name: "Zuzana Zatrochova"
project_section: "mailinglistitem"
sent_date: 2015-10-01T08:25:16-07:00
---


More likely not what I expected - I use the definition of the strongest
consistency guarantees = linearizability (from source -
https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf)

or in other words if a user sends read request, the value obtained should
be at least that of the last write acknowledged to any other user (or later
write request) before the read request was sent to database.



On 1 October 2015 at 16:51, Russell Brown  wrote:

&gt;
&gt; On 1 Oct 2015, at 15:45, Zuzana Zatrochova  wrote:
&gt;
&gt; &gt; Thank you for fast reply,
&gt; &gt;
&gt; &gt; Could you please specify what do you mean by context sent by client?
&gt;
&gt; When a client reads a value it gets an opaque context too, it must return
&gt; this to riak when it performs an update. In the absence of a context an
&gt; empty context is assumed.
&gt;
&gt; &gt; Do you mean update on the existing object in database?
&gt;
&gt; Yes.
&gt;
&gt; &gt;
&gt; &gt; I see exactly that when allow\\_mult=false, only the highest timestamp
&gt; value is stored.
&gt; &gt;
&gt; &gt; For me the results are unexpected because the client sees inconsistent
&gt; values (not from the last write) but there are no partitions and quorum is
&gt; set to the strongest consistency configurations. In the diagram, it is
&gt; showed more clearly how shifted clocks generate inconsistent result.
&gt;
&gt; Inconsistent as in non-deterministic, or just not what you expected?
&gt;
&gt; &gt;
&gt; &gt; Thanks,
&gt; &gt; Zuzana
&gt; &gt;
&gt; &gt; On 1 October 2015 at 14:18, Russell Brown  wrote:
&gt; &gt; I need more time to examine the diagram, but this all looks as expected
&gt; so far.
&gt; &gt;
&gt; &gt; If a client sends no context then it’s write will be a sibling of
&gt; whatever is stored at the coordinator, as you rightly point out riak treats
&gt; an incoming clock that is less than a local clock as a sibling.
&gt; &gt; If the coordinator is configured to not store siblings then the sibling
&gt; value with the highest timestamp is stored, I recommend you run riak in
&gt; either allow\\_mult=true or LWW=true, allow\\_mult=false, in my view, should
&gt; not be default.
&gt; &gt; If two riak nodes do the above, and then replicate their values, the
&gt; single value with the highest value is stored. Isn’t this what you are
&gt; seeing? If you depend on time to pick the latest, and nodes’ clocks are out
&gt; of sync this is the price.
&gt; &gt;
&gt; &gt; Is this what you are seeing? Are you seeing results you didn’t expect,
&gt; or non-deterministic results? Or both?
&gt; &gt;
&gt; &gt; Regards
&gt; &gt;
&gt; &gt; Russell
&gt; &gt;
&gt; &gt; On 1 Oct 2015, at 12:58, Zuzana Zatrochova  wrote:
&gt; &gt;
&gt; &gt; &gt; Hi,
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; We are researching the client-centric consistency features of Riak
&gt; database. We encountered a problem with vector clocks implementation. The
&gt; vector clocks do not seem to work locally on a machine as expected. We
&gt; would like you to confirm if the behavior is desired. First I will describe
&gt; the environment of our experiments and then the problem will be presented.
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; Environment:
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; • Our environment consists of six virtual machines
&gt; &gt; &gt; • five machines in Riak cluster, each represent a single
&gt; Riak node with Riak database
&gt; &gt; &gt; • one machine with java application that simulates
&gt; multiple clients communicating with Riak database
&gt; &gt; &gt; • Machines are Virtualized VMs by VMware software and have
&gt; slightly shifted time to each other (no more than 1 second)
&gt; &gt; &gt; • We made experiments with versions riak-1.4.8 and riak-2.1.1.
&gt; In riak-1.4.8 app\\_config contains vnode\\_vclocks = true (default setting
&gt; that was there when downloaded) in riak-2.1.1 we could not locate
&gt; configuration for vnode vclocks either in advanced configurations in
&gt; documentation or riak.conf so we assumed it also defaults to true and is no
&gt; longer enabled to change
&gt; &gt; &gt; • For each experiment we have 500 clients concurrently sending
&gt; requests to random node from the cluster. There are 20000 requests per
&gt; minute operating only on 20 different keys (load on single key is 16
&gt; requests per second (read:write ration = 50:50).
&gt; &gt; &gt; • For referenced issue we used quorums R = 1, W = 3; R = 2, W =
&gt; 2 and R =3 W = 1
&gt; &gt; &gt; • All riak settings are default apart from IP settings and
&gt; quorum settings. We added interceptors from riak\\_test module that don’t
&gt; change the code and are implemented only for logging purposes (information
&gt; about states of nodes), error.log is empty
&gt; &gt; &gt;
&gt; &gt; &gt; Problem:
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; • It seems that Riak does not use vector clocks locally, only on
&gt; global scale. When a data object is created on client side and sent to Riak
&gt; database it does not have any vector clocks assigned (more precisely the
&gt; function riak\\_object:vclock(UpdObj) = [] and local object:
&gt; riak\\_object:vclock(LocalObj) returns the local VC for the local object.
&gt; Therefore the function (in 2.1.1 but similar behavior is in 1.4.8)
&gt; vclock:descends(NewObject, LocalObject) returns false for all my
&gt; experiments with different quorums (Empty vector clocks cannot descend non
&gt; empty vector clocks). The behavior leads to merge of contents = creation of
&gt; siblings (or resolving the value according to the timestamp not vector
&gt; clocks when siblings are not allowed – our configuration)
&gt; &gt; &gt; • In our experiments when time on VMs is not synchronized up to
&gt; 500 milliseconds the situation from picture issue.png sent in attachment
&gt; arises. Due to the fact that two objects with the same key are sent to two
&gt; different coordinators and coordinators clocks are shifted the later object
&gt; is assigned earlier timestamp as the object that was sent before. As the
&gt; result of the vector clocks implementation in Riak, the later object is
&gt; lost due to the merge of contents where later timestamp (wrong because of
&gt; local clock shift) is evaluated as the latest.
&gt; &gt; &gt;
&gt; &gt; &gt; The question:
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; Is this the Riak intended behavior? The problem is that even when
&gt; quorum is set to prefer consistency and there are no partitions in the
&gt; cluster there are still inconsistent requests seen from client perspective
&gt; = any read must return the value of the latest finished write or later
&gt; unfinished write request. (We did not use the strong\\_consistency feature of
&gt; riak-2.1.1 version).
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; Thank you,
&gt; &gt; &gt;
&gt; &gt; &gt; Zuzana
&gt; &gt; &gt;
&gt; &gt; &gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; &gt; &gt; riak-users mailing list
&gt; &gt; &gt; riak-users@lists.basho.com
&gt; &gt; &gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt; &gt;
&gt; &gt;
&gt;
&gt;
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

