---
title: "Re: MapReduce scalability"
description: ""
project: community
lastmod: 2013-02-28T07:18:44-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg10285"
mailinglist_parent_id: "msg10284"
author_name: "Christian Dahlqvist"
project_section: "mailinglistitem"
sent_date: 2013-02-28T07:18:44-08:00
---


Hi Bernard,

The description in the documentation is entirely accurate and not at all purely 
theoretical. Riak will automatically select a covering set of vnodes/partitions 
that hold the data set required to complete the job. All physical nodes may 
therefore net need to participate in the job. When performing this selection, 
the coordinating node will take into account any node outages.

Any map phases will then run on all of these vnodes and use the data stored on 
each local partition. In order to make it as efficient as possible, it will use 
only the versions of the data available locally and will not perform a quorum 
read against all the replicas holding a copy of that data as this would result 
in a lot of network traffic when running large jobs. The outputs of any map 
phases are then sent over to the coordinating node where any reduce phases 
would normally run.

As the input to the map phase only reads from one replica for every KV pair, 
results can differ from run to run if all replicas are not in sync. This 
likelihood of this happening should however be reduced with the introduction of 
active anti-entropy in release 1.3 of Riak, but will due to the eventually 
consistent nature of Riak never be completely eliminated.

MapReduce is quite resilient to data issues as long as any map phase functions 
used have been designed to handle notfounds and tombstones. Nodes going down 
during a MapReduce job will however in many cases cause it to fail.

Although it would technically be possible to create a map phase function in 
Erlang that performs a quorum read using the internal Riak client and then 
performs any processing based on this object instead of the one passed in, this 
is strongly discouraged as it would add a lot of additional network traffic and 
pose a significant risk of overloading the cluster.

Best regards,

Christian


On 28 Feb 2013, at 13:53, Bernard Fouché  wrote:

&gt; Hi Christian,
&gt; 
&gt; At 
&gt; http://docs.basho.com/riak/1.3.0/references/appendices/MapReduce-Implementation/
&gt; , one can read "...any Riak node can also coordinate a MapReduce query by 
&gt; sending a map-step evaluation request directly to the node responsible for 
&gt; maintaining the input data. Map-step results are sent back to the 
&gt; coordinating node, where reduce-step processing can produce a unified 
&gt; result.".
&gt; 
&gt; What you wrote means that the above description is purely theoretical since 
&gt; if there is any problem to get access to data in a node, then the MR fails. 
&gt; We have also seen that deleting a key while doing a MR just makes the MR to 
&gt; run forever so it makes me think that your description is accurate and for 
&gt; the documentation to be correct it seems that one must first be sure that all 
&gt; input data reading will never trigger any kind of error processing, otherwise 
&gt; the MR job will fail (or be stuck). Please correct me if I've misunderstood!
&gt; 
&gt; Now if I want to split processing of a list of keys in the cluster, is there 
&gt; a way to know what node is supposed to have at least one copy of a K/V ?
&gt; 
&gt; If so, we can setup our own kind of MR, by sending subset of keys to nodes 
&gt; known to have at least one version of the K/V pair. Hence if R==2, there will 
&gt; be one local read in the node receiving the subset and only one more read in 
&gt; another node that holds a copy. Then this distributed processing can handle 
&gt; read-repair, aggregate data and send the result to the coordinating node.
&gt; 
&gt; Best Regards,
&gt; 
&gt; Bernard
&gt; Le 28/02/2013 10:32, Christian Dahlqvist a écrit :
&gt;&gt; Hi Boris,
&gt;&gt; 
&gt;&gt; Apart from not scaling quite as well as straight K/V access, emulating 
&gt;&gt; multiGET through MapReduce also has another significant drawback. MapReduce 
&gt;&gt; has no concept of quorum reads, and only work on a single copy of the data, 
&gt;&gt; which can be thought of basically as a read with R=1 that does not trigger 
&gt;&gt; read-repair. It is therefore possible that it can give inconsistent or 
&gt;&gt; incorrect results if all replicas do not have the same data. It is worth 
&gt;&gt; noting that MapReduce was designed as a way to efficiently spread compute 
&gt;&gt; work across the cluster, and re-appropriating it for use with data 
&gt;&gt; collection is not its designed purpose.
&gt;&gt; 
&gt;&gt; The recommended way to implement efficient multiget is to perform normal GET 
&gt;&gt; operations in parallel. If you are retrieving 20 objects, you don't 
&gt;&gt; necessarily need to do all 20 GETs in parallel, but could set it up to use 
&gt;&gt; perhaps 3 or 4 connections. If you then pair this with a connection pool 
&gt;&gt; that can grow and shrink in size (perhaps between a minimum and a maximum 
&gt;&gt; value) as load requires, you should be able to retrieve the objects in a 
&gt;&gt; reasonable time without overloading the cluster.
&gt;&gt; 
&gt;&gt; Best regards,
&gt;&gt; 
&gt;&gt; Christian
&gt;&gt; 
&gt;&gt; 
&gt;&gt; On 27 Feb 2013, at 02:18, Boris Okner  wrote:
&gt;&gt; 
&gt;&gt;&gt; Thanks Christian,
&gt;&gt;&gt; 
&gt;&gt;&gt; The problem I'm trying to solve is to find the way to retrieve values for 
&gt;&gt;&gt; limited number of keys with the best possible latency (or maybe with decent 
&gt;&gt;&gt; latency which is balanced with decent throughput). Let's say we have keys 
&gt;&gt;&gt; stored in some cache 
&gt;&gt;&gt; on top of Riak, and want to retrieve values, 20 at the time, to be able to 
&gt;&gt;&gt; implement pagination. Another alternative to mapreduce would to send 
&gt;&gt;&gt; multiple asynchronous gets, but then we'd have to worry about connection 
&gt;&gt;&gt; pool being exhausted if there's too many such "page" requests. So what 
&gt;&gt;&gt; would be the proper way to deal with the situation when we need to emulate 
&gt;&gt;&gt; multiple key retrieval?
&gt;&gt;&gt; 
&gt;&gt;&gt; On Tue, Feb 26, 2013 at 1:57 AM, Christian Dahlqvist  
&gt;&gt;&gt; wrote:
&gt;&gt;&gt; Hi Boris,
&gt;&gt;&gt; 
&gt;&gt;&gt; MapReduce is a very flexible and powerful way of querying Riak and allows 
&gt;&gt;&gt; processing to be performed locally where the data resides, which allows for 
&gt;&gt;&gt; efficient processing of larger data sets. A result of this is that every 
&gt;&gt;&gt; mapreduce job requires a covering set of vnodes (all vnodes that hold the 
&gt;&gt;&gt; data required for processing) to participate, meaning that it puts 
&gt;&gt;&gt; considerable more load on the system compared to straight K/V access and 
&gt;&gt;&gt; therefore does not scale quite as well. It is primarily designed for batch 
&gt;&gt;&gt; type processing over reasonably large amounts of data and scales well with 
&gt;&gt;&gt; increased data volumes as new nodes are added. We do however usually not 
&gt;&gt;&gt; recommended using it as an interface for realtime queries where low and 
&gt;&gt;&gt; predictable latencies are required and the concurrency level, and therefore 
&gt;&gt;&gt; load level on the cluster, can not be controlled.
&gt;&gt;&gt; 
&gt;&gt;&gt; I am not sure I understand what you mean by the performance degrading with 
&gt;&gt;&gt; the number of nodes, unless you are strictly measuring latency rather than 
&gt;&gt;&gt; throughput. As the number of nodes increase, it gets more and more likely 
&gt;&gt;&gt; that multiple physical nodes will be involved in the job, which will add to 
&gt;&gt;&gt; the amount of communication and coordination required between the nodes, 
&gt;&gt;&gt; thereby increasing latency. Could you please explain in more detail what 
&gt;&gt;&gt; you are trying to achieve?
&gt;&gt;&gt; 
&gt;&gt;&gt; Best regards,
&gt;&gt;&gt; 
&gt;&gt;&gt; Christian 
&gt;&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt; On 25 Feb 2013, at 16:41, Boris Okner  wrote:
&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; Hello,
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; I'm experimenting with 2 Riak 1.3.0 nodes (both are "bare metal"), and it 
&gt;&gt;&gt;&gt; looks like mapreduce performs better when one of the nodes is down. The 
&gt;&gt;&gt;&gt; mapreduce requests are running on 20-key blocks. So am I doing something 
&gt;&gt;&gt;&gt; wrong, or is it an expected behaviour, i.e. mapreduce degrades with the 
&gt;&gt;&gt;&gt; the number of nodes increased? If the former, could 
&gt;&gt;&gt;&gt; you give me some pointers on how to set up it to get advantage of multiple 
&gt;&gt;&gt;&gt; nodes?
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; Thanks in advance for your help,
&gt;&gt;&gt;&gt; Boris
&gt;&gt;&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt;&gt;&gt; riak-users mailing list
&gt;&gt;&gt;&gt; riak-users@lists.basho.com
&gt;&gt;&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt;&gt; riak-users mailing list
&gt;&gt;&gt; riak-users@lists.basho.com
&gt;&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt; 
&gt;&gt; 
&gt;&gt; 
&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt; 

\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

