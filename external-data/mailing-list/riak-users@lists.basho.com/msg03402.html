<!DOCTYPE html>
<html lang="en">
<head>
<title>Re: Issues with capacity planning pages on wiki</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="contents" href="index.html#03402" id="c">
<link rel="index" href="maillist.html#03402" id="i">
<link rel="prev" href="msg03398.html" id="p">
<link rel="next" href="msg03403.html" id="n">
<link rel="canonical" href="https://www.mail-archive.com/riak-users@lists.basho.com/msg03402.html">
<link rel="stylesheet" href="/normalize.css" media="screen">
<link rel="stylesheet" href="/master.css" media="screen">

<!--[if lt IE 9]>
<link rel="stylesheet" href="/ie.css" media="screen">
<![endif]-->
</head>
<body>
<script language="javascript" type="text/javascript">
document.onkeydown = NavigateThrough;
function NavigateThrough (event)
{
  if (!document.getElementById) return;
  if (window.event) event = window.event;
  if (event.target.tagName == 'INPUT') return;
  if (event.ctrlKey || event.metaKey) return;
  var link = null;
  switch (event.keyCode ? event.keyCode : event.which ? event.which : null) {
    case 74:
    case 80:
      link = document.getElementById ('p');
      break;
    case 75:
    case 78:
      link = document.getElementById ('n');
      break;
    case 69:
      link = document.getElementById ('e');
      break;
    }
  if (link && link.href) document.location = link.href;
}
</script>
<div itemscope itemtype="http://schema.org/Article" class="container">
<div class="skipLink">
<a href="#nav">Skip to site navigation (Press enter)</a>
</div>
<div class="content" role="main">
<div class="msgHead">
<h1>
<span class="subject"><a href="/search?l=riak-users@lists.basho.com&amp;q=subject:%22Re%5C%3A+Issues+with+capacity+planning+pages+on+wiki%22&amp;o=newest" rel="nofollow"><span itemprop="name">Re: Issues with capacity planning pages on wiki</span></a></span>
</h1>
<p class="darkgray font13">
<span class="sender pipe"><a href="/search?l=riak-users@lists.basho.com&amp;q=from:%22Nico+Meyer%22" rel="nofollow"><span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Nico Meyer</span></span></a></span>
<span class="date"><a href="/search?l=riak-users@lists.basho.com&amp;q=date:20110525" rel="nofollow">Wed, 25 May 2011 09:23:08 -0700</a></span>
</p>
</div>
<div itemprop="articleBody" class="msgBody">
<!--X-Body-of-Message-->
<pre style="margin: 0em;">
Hi Anthony,

</pre><tt>I think, I can explain at least a big chunk of the difference in RAM and 
</tt><tt>disk consumption you see.
</tt><pre style="margin: 0em;"></pre><pre>

</pre><tt>Let start with RAM. I could of course be wrong here, but I believe the 
</tt><tt>/'static bitcask per key overhead/' is just plainly too small. Let me 
</tt><tt>explain why.
</tt><pre style="margin: 0em;">
The bitcask_keydir_entry struct for each entry looks like this:

typedef struct
{
    uint32_t file_id;
    uint32_t total_sz;
    uint64_t offset;
    uint32_t tstamp;
    uint16_t key_sz;
    char     key[0];
} bitcask_keydir_entry;


</pre><tt>This has indeed a size of 22 bytes (The array 'key' has zero entries 
</tt><tt>because the key is written to the memory address directly after the 
</tt><tt>keydir entry).
</tt><tt>As is done int the capacity planner, you need to add the size of the 
</tt><tt>bucket and key to get the size of the keydir entry, but that is not the 
</tt><tt>whole story.
</tt><pre style="margin: 0em;">

</pre><tt>The thing that is actually stored in key is the result of this Erlang 
</tt><tt>expression:
</tt><pre style="margin: 0em;">

   erlang:term_to_binary( {&lt;&lt;&quot;bucket&quot;&gt;&gt;,&lt;&lt;&quot;key&quot;&gt;&gt;} )

</pre><tt>that is, a tuple of two binaries converted to the Erlang external term 
</tt><tt>format.
</tt><pre style="margin: 0em;">

So lets see:

1&gt;  term_to_binary({&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;}).
&lt;&lt;131,104,2,109,0,0,0,0,109,0,0,0,0&gt;&gt;
2&gt;  iolist_size(term_to_binary({&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;})).
13
3&gt;  iolist_size(term_to_binary({&lt;&lt;&quot;a&quot;&gt;&gt;,&lt;&lt;&quot;b&quot;&gt;&gt;})).
15
4&gt;  iolist_size(term_to_binary({&lt;&lt;&quot;aa&quot;&gt;&gt;,&lt;&lt;&quot;b&quot;&gt;&gt;})).
16
5&gt;  iolist_size(term_to_binary({&lt;&lt;&quot;aa&quot;&gt;&gt;,&lt;&lt;&quot;bb&quot;&gt;&gt;})).
17

so even an empty bucket/key pair take 13 bytes  to store.

</pre><tt>Also, since the hashtable storing the keydir entries is essentially an 
</tt><tt>array of pointers to bitcask_keydir_entry objects, there is another 8 
</tt><tt>bytes of overhead per key, assuming you are running a 64bit system.
</tt><pre style="margin: 0em;">

so the real static overhead per key is not 22 but 22+13+8 = 43 bytes.

Lets run the numbers for your predicted memory consumption again:

  ( 43 + 10 + 36 ) * 183915891 * 3 = 49105542897 = 45.7 GB


</pre><tt>Your actual RAM consumption of 70 GB seems to be at odd with the output 
</tt><tt>of erlang:memory/0 that you sent:
</tt><pre style="margin: 0em;">

{total,7281790968} =&gt;   RAM: 7281790968 * 8 = 54.3 GB


</pre><tt>So that is much closer, within about 20 percent. Some additional 
</tt><tt>overhead is to be expected, but it is hard to say how much of that is 
</tt><tt>due to Erlangs internal usage and how much due to bitcask.
</tt><pre style="margin: 0em;">

So lets examine the disk consumption next.
</pre><tt>As you rightly concluded the equation here 
</tt><tt><a  rel="nofollow" href="http://wiki.basho.com/Cluster-Capacity-Planning.html">http://wiki.basho.com/Cluster-Capacity-Planning.html</a> is somewhat 
</tt><tt>simplified, and your are also right, that the real equation would be
</tt><pre style="margin: 0em;">

( 14 + Key + Value ) * Num Entries * N_Val

</pre><tt>On the other hand 14 bytes + keysize might be quite irrelevant if your 
</tt><tt>values have a size of at least 2KB (as in the example), which seems to 
</tt><tt>be the general assumption in some aspects of the design of riak and bitcask.
</tt><tt>As you also noticed, this additional small overhead brings you nowhere 
</tt><tt>near the disk usage that you observe.
</tt><pre style="margin: 0em;">

</pre><tt>First, the key that is stored in the bitcask files is not the key part 
</tt><tt>of the bucket/key pair that riak calls a key, but the serialized 
</tt><tt>bucket/key pair described above, so the calculation becomes:
</tt><pre style="margin: 0em;">

( 14 + ( 13 + Bucket + Key) + Value ) * Num Entries * N_Val

( 14 + ( 13 + 10 + 36) + 36 ) * 183915891 * 3 = 56 GB

Still not enough :-/.
</pre><tt>So next lets examine what is actually stored as the value in bitcask. It 
</tt><tt>is not simply the data you provide, but a riak object (r_object record) 
</tt><tt>which is again serialized by the erlang:term_to_binary/1 function. So 
</tt><tt>lets see. I create a new riak object with zero byte bucket, key and value:
</tt><pre style="margin: 0em;">

</pre><tt>3&gt;  Obj = riak_object:new(&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;).     
</tt><tt>{r_object,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,
</tt><pre style="margin: 0em;">
          [{r_content,{dict,0,16,16,8,80,48,
                            {[],[],[],[],[],[],[],[],[],[],[],[],[],[],...},
                            {{[],[],[],[],[],[],[],[],[],[],[],[],...}}},
                      &lt;&lt;&gt;&gt;}],
          [],
          {dict,1,16,16,8,80,48,
                {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...},
                {{[],[],[],[],[],[],[],[],[],[],[],[],[],...}}},
          undefined}
4&gt;  iolist_size(erlang:term_to_binary(Obj))._*
205*_

</pre><tt>Also, bucket and key are contained int  the riak object itself (and 
</tt><tt>therefore in the bitcask notion of the value). So with this information 
</tt><tt>the predicted disk usage becomes:
</tt><pre style="margin: 0em;">

( 14 + ( 13 + Bucket + Key ) + ( 205 + Bucket + Key + Value ) ) * Num Entries * 
N_Val

( 14 + ( 13 + 10 + 36) + ( 205 + 10 + 36 ) ) * 183915891 * 3 = 166.5 GB

which is way closer to the 341 GB you observe.

</pre><tt>But we can get even closer, although the detailes become somewhat more 
</tt><tt>fuzzy. But bear with me.
</tt><tt>I again create a riak object, but this time with a non empty bucket/key 
</tt><tt>so I can store it in riak:
</tt><pre style="margin: 0em;">

(ctag@172.20.1.31)7&gt;  Obj = riak_object:new(&lt;&lt;&quot;a&quot;&gt;&gt;,&lt;&lt;&quot;a&quot;&gt;&gt;,&lt;&lt;&gt;&gt;).
{r_object,&lt;&lt;&quot;a&quot;&gt;&gt;,&lt;&lt;&quot;a&quot;&gt;&gt;,
          [{r_content,{dict,0,16,16,8,80,48,
                            {[],[],[],[],[],[],[],[],[],[],[],[],[],[],...},
                            {{[],[],[],[],[],[],[],[],[],[],[],[],...}}},
                      &lt;&lt;&gt;&gt;}],
          [],
          {dict,1,16,16,8,80,48,
                {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...},
                {{[],[],[],[],[],[],[],[],[],[],[],[],[],...}}},
          undefined}

(ctag@172.20.1.31)8&gt;  iolist_size(erlang:term_to_binary(Obj)).
_*207*_

(ctag@172.20.1.31)9&gt;  {ok,C}=riak:local_client().
{ok,{riak_client,'ctag@172.20.1.31',&lt;&lt;2,123,179,255&gt;&gt;}}
</pre><tt>(ctag@172.20.1.31)10&gt;  C:put(Obj,1,1).           
</tt><tt>ok
</tt><pre style="margin: 0em;">

(ctag@172.20.1.31)12&gt;  {ok,ObjStored} = C:get(&lt;&lt;&quot;a&quot;&gt;&gt;,&lt;&lt;&quot;a&quot;&gt;&gt;, 1).
{ok,{r_object,&lt;&lt;&quot;a&quot;&gt;&gt;,&lt;&lt;&quot;a&quot;&gt;&gt;,
         [{r_content,{dict,2,16,16,8,80,48,
                         {[],[],[],[],[],[],[],[],[],[],[],[],...},
                         {{[],[],[],[],[],[],[],[],[],[],...}}},
                     &lt;&lt;&gt;&gt;}],
              [{&lt;&lt;2,123,179,255&gt;&gt;,{1,63473554112}}],
              {dict,1,16,16,8,80,48,
                    {[],[],[],[],[],[],[],[],[],[],[],[],[],...},
                    {{[],[],[],[],[],[],[],[],[],[],[],...}}},
               undefined}}
(ctag@172.20.1.31)13&gt;  iolist_size(erlang:term_to_binary(ObjStored)).
_*358*_



</pre><tt>Ok? What happened? The object we retrieved is considerably larger than 
</tt><tt>the one we stored. One culprit is the vector clock data, which was an 
</tt><tt>empty list for Obj, and now has one entry:
</tt><pre style="margin: 0em;">

(ctag@172.20.1.31)14&gt;  riak_object:vclock(Obj).
[]
(ctag@172.20.1.31)15&gt;  riak_object:vclock(ObjStored).
[{&lt;&lt;2,123,179,255&gt;&gt;,{1,63473554112}}]
</pre><tt>(ctag@172.20.1.31)23&gt;  iolist_size(term_to_binary(riak_object:vclock(Obj))).     
</tt><tt>2
</tt><pre style="margin: 0em;">
(ctag@172.20.1.31)24&gt;  
iolist_size(term_to_binary(riak_object:vclock(ObjStored))).
30

</pre><tt>So thats 28 bytes each time the object is updated with a new client ID 
</tt><tt>(so alway use a meaningful client ID!!!!), until the vclock pruning sets 
</tt><tt>in. The default bucket property is {big_vclock,50}, so in the worst case 
</tt><tt>this could account for 28*50=1400 byte!
</tt><tt>But each object that has been stored somehow has at least one entry in 
</tt><tt>the vclock, so another 28 bytes of overhead
</tt><pre style="margin: 0em;">

</pre><tt>The other part of the growth stems from some standard entries, which are 
</tt><tt>added to the object metadata during the put operation:
</tt><pre style="margin: 0em;">

(ctag@172.20.1.31)35&gt;  dict:to_list(riak_object:get_metadata(Obj)).
[]
(ctag@172.20.1.31)37&gt;  
iolist_size(term_to_binary(riak_object:get_metadata(Obj))).
60

(ctag@172.20.1.31)36&gt;  dict:to_list(riak_object:get_metadata(ObjStored)).
[{&lt;&lt;&quot;X-Riak-VTag&quot;&gt;&gt;,&quot;7PoD9FEMUBzNmQeMnjUbas&quot;},
 {&lt;&lt;&quot;X-Riak-Last-Modified&quot;&gt;&gt;,{1306,334912,424099}}]
(ctag@172.20.1.31)38&gt;  
iolist_size(term_to_binary(riak_object:get_metadata(ObjStored))).
183

So there are the other 123 bytes.

</pre><tt>In total this 356 byte* overhead per object leads us to the following 
</tt><tt>calculation:  (* 2 bytes from the above 358 came from the bucket and key 
</tt><tt>which are already accounted for)
</tt><pre style="margin: 0em;">

( 14 + ( 13 + Bucket + Key ) + ( 356 + Bucket + Key + Value ) ) * Num Entries * 
N_Val

( 14 + ( 13 + 10 + 36) + ( 356 + 10 + 36 ) ) * 183915891 * 3 = 244 GB


We are getting closer!
</pre><tt>If you loaded the data via the REST API the overhead is somewhat larger 
</tt><tt>still, since the object will also contain 'content-type', 'X-Riak-Meta' 
</tt><tt>and 'Link' metadata entries:
</tt><pre style="margin: 0em;">

xxxx@node2:~$ curl -v -d '' -H &quot;Content-Type: text/plain&quot; 
<a  rel="nofollow" href="http://127.0.0.1:8098/riak/a/a">http://127.0.0.1:8098/riak/a/a</a>


(ctag@172.20.1.31)44&gt;  {ok,ObjStored} = C:get(&lt;&lt;&quot;a&quot;&gt;&gt;,&lt;&lt;&quot;a&quot;&gt;&gt;, 1).
{ok,{r_object,&lt;&lt;&quot;a&quot;&gt;&gt;,&lt;&lt;&quot;a&quot;&gt;&gt;,
              [{r_content,{dict,5,16,16,8,80,48,
                                {[],[],[],[],[],[],[],[],[],[],[],[],...},
                                
{{[],[],[[&lt;&lt;&quot;Links&quot;&gt;&gt;]],[],[],[],[],[],[],[],...}}},
                          &lt;&lt;&gt;&gt;}],
              [{&lt;&lt;5,134,53,93&gt;&gt;,{1,63473557230}}],
              {dict,1,16,16,8,80,48,
                    {[],[],[],[],[],[],[],[],[],[],[],[],[],...},
                    {{[],[],[],[],[],[],[],[],[],[],[],...}}},
              undefined}}
</pre><tt>(ctag@172.20.1.31)45&gt;  dict:to_list(riak_object:get_metadata(ObjStored)).              
</tt><tt>[{&lt;&lt;&quot;Links&quot;&gt;&gt;,[]},
</tt><pre style="margin: 0em;">
 {&lt;&lt;&quot;X-Riak-VTag&quot;&gt;&gt;,&quot;3TQzJznzXXWtZefntWXPDR&quot;},
 {&lt;&lt;&quot;content-type&quot;&gt;&gt;,&quot;text/plain&quot;},
 {&lt;&lt;&quot;X-Riak-Last-Modified&quot;&gt;&gt;,{1306,338030,682871}},
 {&lt;&lt;&quot;X-Riak-Meta&quot;&gt;&gt;,[]}]

(ctag@172.20.1.31)46&gt;  iolist_size(erlang:term_to_binary(ObjStored))._*
449*_


Which leads to: (remember again to subtract 2 bytes)

( 14 + ( 13 + Bucket + Key ) + ( 447 + Bucket + Key + Value ) ) * Num Entries * 
N_Val

( 14 + ( 13 + 10 + 36) + ( 447 + 10 + 36 ) ) * 183915891 * 3 = 290.8 GB


Nearly there!

</pre><tt>Now there are also the hintfiles, which are a kind of an index into the 
</tt><tt>bitcask data files to speedup the start of a riak node. The hintfiles 
</tt><tt>contain one entry per key and the code that creates one entry looks like 
</tt><tt>this:
</tt><pre style="margin: 0em;">

    [&lt;&lt;Tstamp:?TSTAMPFIELD&gt;&gt;,&lt;&lt;KeySz:?KEYSIZEFIELD&gt;&gt;,
     &lt;&lt;TotalSz:?TOTALSIZEFIELD&gt;&gt;,&lt;&lt;Offset:?OFFSETFIELD&gt;&gt;, Key].


So thats 4 + 2 + 4 + 8 + KeySize (= 18 + KeySize) additonal bytes per key.
So the final result if you inserted the key via the Rest API is:

( 14 + ( 13 + Bucket + Key ) + ( 447 + Bucket + Key + Value ) + (18 + ( 13 + 
Bucket + Key ) ) ) * Num Entries * N_Val =*( 505 + 3 * (Bucket + Key) + Value ) 
* Num Entries * N_Val*

( 505 + 3 * (10 + 36) + 36 ) * 183915891 * 3 = 374636669967 = 348.9 GB


And if you used Erlang (or probably any ProtocolBuffers client):

( 14 + ( 13 + Bucket + Key ) + ( 356 + Bucket + Key + Value ) + (18 + ( 13 + 
Bucket + Key ) ) ) * Num Entries * N_Val =*( 414 + 3 * (Bucket + Key) + Value ) 
* Num Entries * N_Val*

( 414 + 3 * (10 + 36) + 36 ) * 183915891 * 3 = 324427631724 = 302.1 GB


</pre><tt>So the truth is somewhere in between. But as David wrote, there can be 
</tt><tt>additional overhead due to the append only nature on bitcask.
</tt><pre style="margin: 0em;">

Cheers,
Nico

Am 24.05.2011 23:48, schrieb Anthony Molinaro:
</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
Just curious if anyone has any ideas, for the moment, I'm just taking
the RAM calculation and multiplying by 2 and the Disk calculation and
multiplying by 8, based on my findings with my current cluster.  But
I would like to know why my values are so much higher than those I should
be getting.

Also, I'd still like to know how the forms calculate things as the disk
calculation there does not match reality or the formula.

Also, waiting to hear if there is any way to force merge to run so I can
more accurately gauge whether multiple copies are effecting disk usage.

Thanks,

-Anthony

On Mon, May 23, 2011 at 11:06:31PM -0700, Anthony Molinaro wrote:
</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
On Mon, May 23, 2011 at 10:53:29PM -0700, Anthony Molinaro wrote:
</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
On Mon, May 23, 2011 at 09:57:25PM -0600, David Smith wrote:
</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
On Mon, May 23, 2011 at 9:39 PM, Anthony Molinaro
Thus, depending on
your merge triggers, more space can be used than is strictly necessary
to store the data.
</pre></blockquote><pre style="margin: 0em;">
So the lack of any overhead in the calculation is expected?  I mean
according to <a  rel="nofollow" href="http://wiki.basho.com/Cluster-Capacity-Planning.html">http://wiki.basho.com/Cluster-Capacity-Planning.html</a>

Disk = Estimated Total Objects * Average Object Size * n_val

Which just seems wrong, doesn't it?  I don't quite understand the
bitcask code well enough yet to see what the actual data it stores is,
but the whitepaper suggested several things were involved in the on
disk representation.
</pre></blockquote><pre style="margin: 0em;">
Okay, finally found the code for this part, I kept looking in the nif
but that's only the keydir, not the data files.  It looks like

    %% Setup io_list for writing -- avoid merging binaries if we can help it
    Bytes0 = [&lt;&lt;Tstamp:?TSTAMPFIELD&gt;&gt;,&lt;&lt;KeySz:?KEYSIZEFIELD&gt;&gt;,
              &lt;&lt;ValueSz:?VALSIZEFIELD&gt;&gt;, Key, Value],
    Bytes  = [&lt;&lt;(erlang:crc32(Bytes0)):?CRCSIZEFIELD&gt;&gt;  | Bytes0],

And looking at the header, it seems that there's 14 bytes of overhead
(4 for CRC, 4 for timestamp, 2 for keysize, 4 for valsize).

So disk calculation should be

( 14 + Key + Value ) * Num Entries * N_Val

So using my numbers from before that gives

( 14 + 36 + 36 ) * 183915891 * 3 = 47450299878 = 44.1 GB

which actually isn't much closer to 341 GB than the previous calculation :(

So all my questions from the previous email still apply.

-Anthony

--
------------------------------------------------------------------------
Anthony Molinaro&lt;antho...@alumni.caltech.edu&gt;
</pre></blockquote></blockquote><pre style="margin: 0em;">

</pre><pre>_______________________________________________
riak-users mailing list
riak-users@lists.basho.com
<a  rel="nofollow" href="http://lists.basho.com/mailman/listinfo/riak-users_lists.basho.com">http://lists.basho.com/mailman/listinfo/riak-users_lists.basho.com</a>
</pre>

</div>
<div class="msgButtons margintopdouble">
<ul class="overflow">
<li class="msgButtonItems"><a class="button buttonleft " accesskey="p" href="msg03398.html">Previous message</a></li>
<li class="msgButtonItems textaligncenter"><a class="button" accesskey="c" href="index.html#03402">View by thread</a></li>
<li class="msgButtonItems textaligncenter"><a class="button" accesskey="i" href="maillist.html#03402">View by date</a></li>
<li class="msgButtonItems textalignright"><a class="button buttonright " accesskey="n" href="msg03403.html">Next message</a></li>
</ul>
</div>
<a name="tslice"></a>
<div class="tSliceList margintopdouble">
<ul class="icons monospace">
<li class="icons-email"><span class="subject"><a href="msg03391.html">Issues with capacity planning pages on wiki</a></span> <span class="sender italic">Anthony Molinaro</span></li>
<li><ul>
<li class="icons-email"><span class="subject"><a href="msg03392.html">Re: Issues with capacity planning pages on wiki</a></span> <span class="sender italic">David Smith</span></li>
<li><ul>
<li class="icons-email"><span class="subject"><a href="msg03393.html">Re: Issues with capacity planning pages on wiki</a></span> <span class="sender italic">Anthony Molinaro</span></li>
<li><ul>
<li class="icons-email"><span class="subject"><a href="msg03394.html">Re: Issues with capacity planning pages on ...</a></span> <span class="sender italic">Anthony Molinaro</span></li>
<li><ul>
<li class="icons-email"><span class="subject"><a href="msg03398.html">Re: Issues with capacity planning pages...</a></span> <span class="sender italic">Anthony Molinaro</span></li>
<li><ul>
<li class="icons-email tSliceCur"><span class="subject">Re: Issues with capacity planning ...</span> <span class="sender italic">Nico Meyer</span></li>
<li><ul>
<li class="icons-email"><span class="subject"><a href="msg03403.html">Re: Issues with capacity plann...</a></span> <span class="sender italic">Jonathan Langevin</span></li>
<li><ul>
<li class="icons-email"><span class="subject"><a href="msg03404.html">Re: Issues with capacity p...</a></span> <span class="sender italic">Nico Meyer</span></li>
<li class="icons-email"><span class="subject"><a href="msg03405.html">Re: Issues with capacity p...</a></span> <span class="sender italic">Mark Phillips</span></li>
</ul></li>
<li class="icons-email"><span class="subject"><a href="msg03406.html">Re: Issues with capacity plann...</a></span> <span class="sender italic">Anthony Molinaro</span></li>
<li><ul>
<li class="icons-email"><span class="subject"><a href="msg03411.html">Re: Issues with capacity p...</a></span> <span class="sender italic">Justin Sheehy</span></li>
<li class="icons-email"><span class="subject"><a href="msg03445.html">Re: Issues with capacity p...</a></span> <span class="sender italic">Anthony Molinaro</span></li>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</div>
<div class="overflow msgActions margintopdouble">
<div class="msgReply" >
<h2>
					Reply via email to
</h2>
<form method="POST" action="/mailto.php">
<input type="hidden" name="subject" value="Re: Issues with capacity planning pages on wiki">
<input type="hidden" name="msgid" value="4DDD2CDD.9090504@adition.com">
<input type="hidden" name="relpath" value="riak-users@lists.basho.com/msg03402.html">
<input type="submit" value=" Nico Meyer ">
</form>
</div>
</div>
</div>
<div class="aside" role="complementary">
<div class="logo">
<a href="/"><img src="/logo.png" width=247 height=88 alt="The Mail Archive"></a>
</div>
<form class="overflow" action="/search" method="get">
<input type="hidden" name="l" value="riak-users@lists.basho.com">
<label class="hidden" for="q">Search the site</label>
<input class="submittext" type="text" id="q" name="q" placeholder="Search riak-users">
<input class="submitbutton" name="submit" type="image" src="/submit.png" alt="Submit">
</form>
<div class="nav margintop" id="nav" role="navigation">
<ul class="icons font16">
<li class="icons-home"><a href="/">The Mail Archive home</a></li>
<li class="icons-list"><a href="/riak-users@lists.basho.com/">riak-users - all messages</a></li>
<li class="icons-about"><a href="/riak-users@lists.basho.com/info.html">riak-users - about the list</a></li>
<li class="icons-expand"><a href="/search?l=riak-users@lists.basho.com&amp;q=subject:%22Re%5C%3A+Issues+with+capacity+planning+pages+on+wiki%22&amp;o=newest&amp;f=1" title="e" id="e">Expand</a></li>
<li class="icons-prev"><a href="msg03398.html" title="p">Previous message</a></li>
<li class="icons-next"><a href="msg03403.html" title="n">Next message</a></li>
</ul>
</div>
<div class="listlogo margintopdouble">

</div>
<div class="margintopdouble">

</div>
</div>
</div>
<div class="footer" role="contentinfo">
<ul>
<li><a href="/">The Mail Archive home</a></li>
<li><a href="/faq.html#newlist">Add your mailing list</a></li>
<li><a href="/faq.html">FAQ</a></li>
<li><a href="/faq.html#support">Support</a></li>
<li><a href="/faq.html#privacy">Privacy</a></li>
<li class="darkgray">4DDD2CDD.9090504@adition.com</li>
</ul>
</div>
</body>
</html>
