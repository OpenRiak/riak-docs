---
title: "Re: Using $bucket index in java client"
description: ""
project: community
lastmod: 2014-12-02T00:24:07-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg15292"
mailinglist_parent_id: "msg15290"
author_name: "Vassil Kolarov"
project_section: "mailinglistitem"
sent_date: 2014-12-02T00:24:07-08:00
---


I just changed the Init() constructor in BinIndexQuery to:

super(namespace, indexName, start, end);

and in the second constructor:
super(namespace, indexName, match);

Then in the SecondaryIndexQuery:

 public Init(Namespace namespace, String indexName, S match)
 {
 this.namespace = namespace;

 if(indexName.compareTo("$bucket")!=0){
 this.indexName = indexName + Type.\_BIN;
 }else{
 this.indexName = indexName;
 }
 this.match = match;
 }

in both constructors - Init(Namespace namespace, String indexName, S match)
and
 Init(Namespace namespace, String indexName, S start, S end)

Works like a charm.

Best regards,
Vasco

On Tue, Dec 2, 2014 at 5:50 AM, niedomnie  wrote:

> there is a bug in BinIndexQuery - I've overriden some classes and now it is
> working (with orginal sources of client). Use MyBinIndexQuery instead of
> BinIndexQuery. Problem is that \_BIN in always apppended to name of index.
>
> import com.basho.riak.client.api.commands.CoreFutureAdapter
> import com.basho.riak.client.api.commands.indexes.BinIndexQuery
> import com.basho.riak.client.api.commands.indexes.SecondaryIndexQuery
> import com.basho.riak.client.core.RiakCluster
> import com.basho.riak.client.core.RiakFuture
> import com.basho.riak.client.core.operations.SecondaryIndexQueryOperation
> import com.basho.riak.client.core.query.Location
> import com.basho.riak.client.core.query.Namespace
> import com.basho.riak.client.core.util.BinaryValue
>
> import java.nio.charset.Charset
>
> abstract class MyInit> extends
> SecondaryIndexQuery.Init
> {
> Charset charset = Charset.defaultCharset();
>
> public MyInit(Namespace namespace, String indexName, S start, S end)
> {
> // super(namespace, indexName + SecondaryIndexQuery.Type.\_BIN,
> start,
> end);
> super(namespace, indexName, start, end);
> }
>
> public MyInit(Namespace namespace, String indexName, S match)
> {
> // super(namespace, indexName + SecondaryIndexQuery.Type.\_BIN,
> match);
> super(namespace, indexName, match);
> }
>
> T withCharacterSet(Charset charset)
> {
> this.charset = charset;
> return self();
> }
> }
>
> public class MyBuilder extends MyInit
> {
> public MyBuilder(Namespace namespace, String indexName, String start,
> String end)
> {
> super(namespace, indexName, start, end);
> }
>
> public MyBuilder(Namespace namespace, String indexName, String match)
> {
> super(namespace, indexName, match);
> }
>
> @Override
> protected MyBuilder self()
> {
> return this;
> }
>
> public MyBinIndexQuery build()
> {
> return new MyBinIndexQuery(this);
> }
> }
>
> public class MyBinIndexQuery extends SecondaryIndexQuery BinIndexQuery.Response, BinIndexQuery>
> {
> private final Charset charset;
> private final SecondaryIndexQuery.IndexConverter converter;
>
> public MyBinIndexQuery(MyInit builder)
> {
> super(builder);
> this.charset = builder.charset;
> this.converter = new SecondaryIndexQuery.IndexConverter()
> {
> @Override
> public String convert(BinaryValue input)
> {
> return input.toString(charset);
> }
>
> @Override
> public BinaryValue convert(String input)
> {
> return BinaryValue.create(input, charset);
> }
> };
> }
>
> @Override
> protected SecondaryIndexQuery.IndexConverter getConverter()
> {
> return converter;
> }
>
> @Override
> protected RiakFuture
> executeAsync(RiakCluster cluster)
> {
> RiakFuture SecondaryIndexQueryOperation.Query> coreFuture =
> executeCoreAsync(cluster);
>
> BinQueryFuture future = new BinQueryFuture(coreFuture);
> coreFuture.addListener(future);
> return future;
> }
>
> protected final class BinQueryFuture extends
> CoreFutureAdapter SecondaryIndexQueryOperation.Response, SecondaryIndexQueryOperation.Query>
> {
> public
> BinQueryFuture(RiakFuture SecondaryIndexQueryOperation.Query> coreFuture)
> {
> super(coreFuture);
> }
>
> @Override
> protected MyResponse
> convertResponse(SecondaryIndexQueryOperation.Response coreResponse)
> {
> return new MyResponse(namespace, coreResponse, converter);
> }
>
> @Override
> protected MyBinIndexQuery
> convertQueryInfo(SecondaryIndexQueryOperation.Query coreQueryInfo)
> {
> return MyBinIndexQuery.this;
> }
> }
>
> protected static abstract class Init> extends
> SecondaryIndexQuery.Init
> {
> private Charset charset = Charset.defaultCharset();
>
> public Init(Namespace namespace, String indexName, S start, S end)
> {
> super(namespace, indexName + Type.\_BIN, start, end);
> }
>
> public Init(Namespace namespace, String indexName, S match)
> {
> super(namespace, indexName + Type.\_BIN, match);
> }
>
> T withCharacterSet(Charset charset)
> {
> this.charset = charset;
> return self();
> }
>
> }
>
> /\*\*
> \* Builder used to construct a BinIndexQuery.
> \*/
> public static class Builder extends Init
> {
>
> /\*\*
> \* Construct a Builder for a BinIndexQuery with a range.
> \* 
> \* Note that your index name should not include the Riak {@literal
> \_int} or
> \* {@literal \_bin} extension.
> \* 
> \* @param namespace The namespace in Riak to query.
> \* @param indexName The index name in Riak to query.
> \* @param start The start of the 2i range.
> \* @param end The end of the 2i range.
> \*/
> public Builder(Namespace namespace, String indexName, String start,
> String end)
> {
> super(namespace, indexName, start, end);
> }
>
> /\*\*
> \* Construct a Builder for a BinIndexQuery with a single 2i key.
> \* 
> \* Note that your index name should not include the Riak {@literal
> \_int} or
> \* {@literal \_bin} extension.
> \* 
> \* @param namespace The namespace in Riak to query.
> \* @param indexName The name of the index in Riak.
> \* @param match the 2i key.
> \*/
> public Builder(Namespace namespace, String indexName, String match)
> {
> super(namespace, indexName, match);
> }
>
> @Override
> protected Builder self()
> {
> return this;
> }
>
> /\*\*
> \* Construct the query.
> \* @return a new BinIndexQuery
> \*/
> public MyBinIndexQuery build()
> {
> return new MyBinIndexQuery(this);
> }
>
> }
>
> public static class MyResponse extends
> SecondaryIndexQuery.Response
> {
> final SecondaryIndexQueryOperation.Response coreResponseCopy;
> final SecondaryIndexQuery.IndexConverter converterCopy;
>
> protected MyResponse(Namespace queryLocation,
> SecondaryIndexQueryOperation.Response coreResponse,
> SecondaryIndexQuery.IndexConverter converter)
> {
> super(queryLocation, coreResponse, converter);
> this.coreResponseCopy = coreResponse
> this.converterCopy = converter
> }
>
> @Override
> public List getEntries()
> {
> List convertedList = new ArrayList();
> for (SecondaryIndexQueryOperation.Response.Entry e :
> coreResponseCopy.getEntryList())
> {
> Location loc = getLocationFromCoreEntry(e);
> MyEntry ce = new MyEntry(loc, e.getIndexKey(),
> converterCopy);
> convertedList.add(ce);
> }
> return convertedList;
> }
>
> public class MyEntry extends
> SecondaryIndexQuery.Response.Entry
> {
> protected MyEntry(Location riakObjectLocation, BinaryValue
> indexKey, SecondaryIndexQuery.IndexConverter converter)
> {
> super(riakObjectLocation, indexKey, converter);
> }
>
> }
> }
> }
>
>
>
> --
> View this message in context:
> http://riak-users.197444.n3.nabble.com/Using-bucket-index-in-java-client-tp4032125p4032199.html
> Sent from the Riak Users mailing list archive at Nabble.com.
>
> \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
> riak-users mailing list
> riak-users@lists.basho.com
> http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
>
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com









