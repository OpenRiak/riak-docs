---
title: "Re: Associating Riak CRDT Sets to Buckets / Keys via Erlang Client"
description: ""
project: community
lastmod: 2016-11-17T04:49:43-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg17757"
mailinglist_parent_id: "msg17755"
author_name: "Magnus Kessler"
project_section: "mailinglistitem"
sent_date: 2016-11-17T04:49:43-08:00
---


On 16 November 2016 at 17:40, Vikram Lalit  wrote:

> Hi - I am trying to leveraging CRDT sets to store chat messages that my
> distributed Riak infrastructure would store. Given the intrinsic
> conflict-resolution, I thought this might be more beneficial than me
> putting together a merge implementation based on the causal context.
>
> However, my data model requires each chat message to be associated to
> something like a post, hence I was thinking of having the post reference as
> the bucket, and chat references as keys in that bucket. With of course the
> bucket-type datasource equated to 'set'. Unfortunately though, from the
> documentation, I'm not able to ascertain how to associate a created set
> with an existing bucket and a new key reference if I use the Erlang client.
> This seems possible for other languages but not for Erlang, with the Basho
> doc mentioning "%% Sets in the Erlang client are opaque data structures
> that collect operations as you mutate them. We will associate the data 
> structure
> with a bucket type, bucket, and key later on.".
>
> Subsequent code only seems to fetch the set from the bucket / key but
> where exactly is the allocation happening?
>
> {ok, SetX} = riakc\_pb\_socket:fetch\_type(Pid, {<<"sets">>,<<"travel">>}, <<
> "cities">>).
>
> Perhaps I'm missing something, or is there a code snippet that I can
> leverage?
>
> Thanks!
>
>
Hi Vikram,

Please have a look at the following snippet, that shows the complete set of
operations used to update a CRDT set with the Erlang client:

update\_crdt\_set(Server, BType, Bucket, Key, Val) ->
 T = unicode:characters\_to\_binary(BType),
 B = unicode:characters\_to\_binary(Bucket),
 K = unicode:characters\_to\_binary(Key),

 {ok, Pid} = riakc\_pb\_socket:start\_link(Server, 8087),

 Set = case
 riakc\_pb\_socket:fetch\_type(Pid, {T, B}, K)
 of
 {ok, O} -> O;
 {error, {notfound, set}} -> riakc\_set:new()
 end,

 Set1 = riakc\_set:add\_element(unicode:characters\_to\_binary(Val),
Set),

 {ok, {set, Vals, \_Adds, \_Dels, \_Ctx}} = riakc\_pb\_socket:update\_type(
 Pid, {T, B}, K, riakc\_set:to\_op(Set1), [return\_body]),
 Vals.

The set is updated with riakc\_set:add\_element/2, and sent back to the
server with riakc\_pb\_socket:update\_type/5, which in turn takes an argument
returned from riakc\_set:to\_op/1.

More information and samples can be found in the Riak documentation [0] and
the Riak Erlang client API docs [1][2].

Please let me know if this answered your question.

Kind Regards,

Magnus

[0]: http://docs.basho.com/riak/kv/2.1.4/developing/data-types/sets/
[1]: https://basho.github.io/riak-erlang-client/riakc\_set.html
[2]:
https://basho.github.io/riak-erlang-client/riakc\_pb\_socket.html#update\_type-5

-- 
Magnus Kessler
Client Services Engineer
Basho Technologies Limited

Registered Office - 8 Lincolnâ€™s Inn Fields London WC2A 3BP Reg 07970431
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

