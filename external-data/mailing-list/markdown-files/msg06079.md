---
title: "Re: Question regarding recent riak_core_vnode_master changes"
description: ""
project: community
lastmod: 2011-12-27T13:15:31-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg06079"
mailinglist_parent_id: "msg05996"
author_name: "Joseph Blomstedt"
project_section: "mailinglistitem"
sent_date: 2011-12-27T13:15:31-08:00
---


Jeff,

There have been several changes to how vnodes are managed leading up
to the next release of Riak. One of those changes is the addition of
vnode proxy processes.

As before, vnodes are still started on demand. However, there are now
a set of vnode proxy processes that are always running. Unlike vnodes,
the proxy processes for all partition indices are started when a node
comes online, and the proxy processes are supervised and automatically
restarted if they crash. Each proxy process has a unique locally
registered name. To send an event to a vnode, you send it directly to
the proxy process for that vnode. If the proxy already has a pid for
the vnode, it forwards the message to the vnode. If it doesn't have a
cached pid, it will contact the 'riak\_core\_vnode\_manager' to get a
vnode pid. If the vnode is currently running, the manager returns the
pid; otherwise it starts up the vnode and returns the newly spawned
pid. The same lazy / on-demand process as before.

The 'badarg' issue you are seeing is related to the relevant proxy
processes not being spawned for your vnodes before you try to send the
event, and therefore the constructed atom doesn't refer to a known
registered name. I am not sure how that is occurring, as vnode proxy
processes are automatically started the moment you register your vnode
module with riak\_core. Of course, there has also been some changes to
have vnode are registered with riak\_core as well. Make sure you are
registering your vnode with Riak using 'riak\_core:register'. As an
example, here's how 'riak\_kv' registers with riak\_core (see in
riak\_kv\_app.erl):
=====
riak\_core:register(riak\_kv, [
 {vnode\_module, riak\_kv\_vnode},
 {bucket\_validator, riak\_kv\_bucket}
]),
=====

You don't need a bucket\_validator if your app isn't using one, but you
must always register your vnode\_module. That call should trigger
'register\_mod' in riak\_core.erl that should trigger a call to
riak\_core\_vnode\_proxy\_sup:start\_proxies.

-Joe

On Mon, Dec 19, 2011 at 10:52 AM, Jeff Thompson  wrote:
> As a project to better learn riak\_core and to think more about distributed
> problems, I've been writing a little mud app using riak\_core.
>
> I just updated to the latest riak\_core version and am running into a problem
> when riak\_core\_vnode\_master gets a handle\_cast.
>
> In the previous version handle\_cast would:
>
> handle\_cast(Req=?VNODE\_REQ{index=Idx}, State) ->
>     Pid = get\_vnode(Idx, State),
>     gen\_fsm:send\_event(Pid, Req),
>     {noreply, State};
>
> get\_vnode:
>
> get\_vnode(Idx, State=#state{vnode\_mod=Mod}) ->
>     case idx2vnode(Idx, State) of
>         no\_match ->
>             {ok, Pid} = riak\_core\_vnode\_sup:start\_vnode(Mod, Idx),
>             MonRef = erlang:monitor(process, Pid),
>             add\_vnode\_rec(#idxrec{idx=Idx,pid=Pid,monref=MonRef}, State),
>             Pid;
>         X -> X
>     end.
>
>
>
> I would see the get\_vnode code successfully start my vnode and the
> subsequent gen\_fsm:send\_event/2 call would succeed.
>
> However, the new version of get\_vnode looks like:
>
> handle\_cast(Req=?VNODE\_REQ{index=Idx}, State=#state{vnode\_mod=Mod}) ->
>     Proxy = riak\_core\_vnode\_proxy:reg\_name(Mod, Idx),
>     gen\_fsm:send\_event(Proxy, Req),
>     {noreply, State};
>
>
> and riak\_core\_vnode\_proxy:reg\_name/2 just returns an atom:
>
> reg\_name(Mod, Index) ->
>     ModBin = atom\_to\_binary(Mod, latin1),
>     IdxBin = list\_to\_binary(integer\_to\_list(Index)),
>     AllBin = <<$p,$r,$o,$x,$y,$\_, ModBin/binary, $\_, IdxBin/binary>>,
>     binary\_to\_atom(AllBin, latin1).
>
>
>
> This is resulting in a:
>
> {badarg,[{gen\_fsm,send\_event,2},
>             {riak\_core\_vnode\_master,handle\_cast,2},
>             {gen\_server,handle\_msg,5},
>             {proc\_lib,init\_p\_do\_apply,3}]}
>
> Based on the above, there doesn't seem to be an 'on demand' starting of
> vnodes anymore?
>
> I'm happy to dig into this more (which I will anyway to learn whats going
> on), but if there are any quick pointers that can be given as to how the
> recent changes impact the writing of riak\_core vnodes and what I'm seeing
> above, I would certainly appreciate it.
>
> Thanks!
>
> Jeff
>
>
>
>
> \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
> riak-users mailing list
> riak-users@lists.basho.com
> http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
>

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

