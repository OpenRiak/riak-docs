---
title: "efficient fetching of values falling in a key range"
description: ""
project: community
lastmod: 2012-01-30T10:12:56-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg06459"
author_name: "Dietrich Featherston"
project_section: "mailinglistitem"
sent_date: 2012-01-30T10:12:56-08:00

---


I'm using a leveldb-backed riak 1.0.2 and looking for some suggestions to
fetch a block of data by key range. I have control over the keys and all
reads out of this setup will involve at minimum a key range. It seems that
if leveldb is an ideal candidate for this kind of access pattern so long as
I'm able to take advantage of that in the APIs exposed by riak.

First thought is to use the built-in $key index to do a query for the keys
falling in a range, then fetch the underlying objects (either directly or
via a map job). Doesn't look like this is yielding any results for a range
known to contain data, however.

Doing something like the following in the Java API yields no data

val keys =
> bucket.fetchIndex(BinIndex.named("$key")).from(startKey).to(endKey).execute();


Whereas the same question phrased as a keyfilter map job does yield data

 riak.mapReduce(query)
> .addKeyFilter(new BetweenFilter(startKey, endKey))
> .addMapPhase(new NamedErlangFunction("riak\_kv\_mapreduce",
> "map\_object\_value"), true)
> .execute()


Perhaps there is something I need to do to make sure the $key index is
built other than using the leveldb backend, but I couldn't find any
evidence of that in the docs.

Does this seem like a reasonable approach? If so, any thoughts on how I
might be reading the key index incorrectly?

Thanks,
D
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

