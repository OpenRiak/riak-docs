---
title: "Re: Active Anti Entropy with Bitcask Key Expiry"
description: ""
project: community
lastmod: 2013-04-18T08:10:02-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg10936"
mailinglist_parent_id: "msg10899"
author_name: "Ryan Zezeski"
project_section: "mailinglistitem"
sent_date: 2013-04-18T08:10:02-07:00
---


Ben,

AAE should not resurrect keys when bitcask expiry is enabled. However, a
non-trivial amount of work may be performed if a lot of keys expire all at
once.

You're correct that the layers above bitcask have no notion of expiry.
 When a key expires no notification is sent to Riak. This means that
hashtrees (which I'll call trees from here on out) will continue storing an
entry for a key after it has expired. As long as all trees agree that the
key is still there AAE will be none the wiser about expiry. However, AAE
has its own notion of expiry. Every tree has en expiration date at which
point is is discarded and rebuilt from scratch based on the data in the
backend. By default trees expire after a week. This means there could be
a window where the trees disagree because some were rebuilt and no longer
include the expired key. At this point AAE will try to repair the data by
invoking a read-repair. Since bitcask honors expiry on 'get' all N copies
will return not\_found and thus read-repair will do nothing. Then AAE will
send a 'rehash' request to all N replicas [1] [2]. The rehash will notice
the key is no longer and delete it from the tree.

So, keys should not be resurrected, but it could generate additional I/O
proportional to the number of keys expired. For example:

1. bitcask expiry is set to 1 day
2. millions of keys are written in hour time span thus every hour millions
of keys expire
3. the same key is never overwritten inside a weeks time
4. AAE is using default tree expiry of a week
5. the trees for a given preflist are \_not\_ all expired at about the same
time

In this scenario, when a tree expires it may have millions of expired keys
to deal with. This means millions of Riak 'get' calls plus millions of
'rehash' calls. Now, since the rehash operation is sent to all replicas
only 1 tree of a preflist needs to expire for all replica trees to be
repaired. This means the maximum number of times you should take this hit
is Q / N where Q = ring size, N = n\_val.

Point #3, #4, #5 really are the key here. There must be an overlap where
keys are expired and only a subset of a preflist's trees have been rebuilt.
 The more often keys are re-written and the more nodes you have the less
likely it will be to hit this window.

-Z

[1]
https://github.com/basho/riak\_kv/blob/master/src/riak\_kv\_exchange\_fsm.erl#L232

[2] https://github.com/basho/riak\_kv/blob/master/src/riak\_kv\_vnode.erl#L482


On Tue, Apr 16, 2013 at 11:07 AM, Ben Murphy  wrote:

> Does anyone know if these two place nice with each other? As far as I can
> see the higher layers sitting on top of bitcask are not aware that bitcask
> can expire keys. Would the anti-entropy code try to resurrect expired keys?
>
> \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
> riak-users mailing list
> riak-users@lists.basho.com
> http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
>
>
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

