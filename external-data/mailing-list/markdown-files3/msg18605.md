---
title: "Riak data model for SCIM (or sets of maps)"
description: ""
project: community
lastmod: 2019-03-25T06:10:05-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg18605"
author_name: "Paul Bismuth"
project_section: "mailinglistitem"
sent_date: 2019-03-25T06:10:05-07:00
---


Hi everybody,

I'm implementing SCIM (System for Cross-domain Identity Management -
https://tools.ietf.org/html/rfc7643 &
https://tools.ietf.org/html/rfc7644) with several backends and I'm
scratching my head trying to figure out how to model the data model in
Riak.

There are 2 types of attributes:
\* simple attributes: scalars, such as boolean, string, date, integer, float
\* complex attributes: a map of simple attributes

Attributes (simple \_and\_ complex) can be:
\* singular (0 or 1 occurence)
\* muti-valued

Example of a "User" object:
{
 "userName": "bjen...@example.com",
 "name": {
 "formatted": "Ms. Barbara J Jensen, III",
 "familyName": "Jensen",
 "givenName": "Barbara",
 "middleName": "Jane",
 "honorificPrefix": "Ms.",
 "honorificSuffix": "III"
 },
 "access\_rights": [
 "scope\_a",
 "scope\_b",
 "scope\_c"
 ]
 "emails": [
 {
 "value": "bjen...@example.com",
 "type": "work",
 "primary": true
 },
 {
 "value": "b...@jensen.org",
 "type": "home"
 }
 ],
}
With respectively a simple singular attribute, a complex singular
attribute, a simple multi-valued attribute and a complex multi-value
attribute. SCIM prohibits further nesting of objects (therefore the
deepest level is the subattribute).

I'd like to implement a Riak backend using the core CRDTS, and also to
implement SCIM "search"
(https://tools.ietf.org/html/rfc7644#section-3.4.2). In a nutshell,
SCIM search allows:
\* comparing equality, inequality, greater/lower than, attribute is
present, starts/ends with (for strings), contains (for strings)
\* and, or and not operands
\* matching for attribute and sub-attributes (e.g.: name.familyName co
"O'Malley" - co is for "contains")
\* complex attribute filter grouping (e.g.: userType eq "Employee" and
emails[type eq "work" and value co "@example.com"] - eq is for
"equal"). In this case the expression between the brackets must
evaluate to true on the same complex attribute
Note that \_any\_ attribute can be multi-valued.

Regarding the data model with CRDTs and using a map as the base
object, implementing:
\* simple singular attribute: straightforward (let's forget the data
types not natively supported such as floats for now)
\* complex singular attribute: a map of map
\* simple multi-value attribute: use of a set
\* complex multi-valued attribute: that's where I can't find a good
solution since sets of maps don't exist in Riak CRDTs (sets can only
have string values)

For this latter case, I've been thinking of map of maps using random keys:
iex(53)> Riak.Search.query("test\_index",
"my\_map\_map.attr5\_0\_map.subattr1\_register:\*")
{:ok,
 {:search\_results,
 [
 {"test\_index",
 [
 {"score", "1.00000000000000000000e+00"},
 {"\_yz\_rb", "test\_bucket"},
 {"\_yz\_rt", "test"},
 {"\_yz\_rk", "key2"},
 {"\_yz\_id", "1\*test\*test\_bucket\*key2\*20"},
 {"my\_map\_map.attr1\_register", "value1"},
 {"my\_map\_map.attr2\_register", "value2"},
 {"my\_map\_map.attr3\_register", "value3"},
 {"my\_map\_map.attr4\_register", "value4"},
 {"my\_map\_map.attr5\_0\_map.subattr1\_register", "subvalue1"},
 {"my\_map\_map.attr5\_0\_map.subattr2\_register", "subvalue2"},
 {"my\_map\_map.attr5\_0\_map.subattr3\_register", "subvalue3"},
 {"my\_map\_map.attr5\_0\_map.subattr4\_register", "oups !"},
 {"my\_map\_map.attr5\_1\_map.subattr1\_register", "subvalue11"},
 {"my\_map\_map.attr5\_1\_map.subattr2\_register", "subvalue12"},
 {"my\_map\_map.attr5\_1\_map.subattr3\_register", "subvalue13"},
 {"my\_map\_map.attr5\_1\_map.subattr4\_register", "oups !"}
 ]},
 {"test\_index",
 [
 {"score", "1.00000000000000000000e+00"},
 {"\_yz\_rb", "test\_bucket"},
 {"\_yz\_rt", "test"},
 {"\_yz\_rk", "key1"},
 {"\_yz\_id", "1\*test\*test\_bucket\*key1\*23"},
 {"my\_map\_map.attr1\_register", "value1"},
 {"my\_map\_map.attr2\_register", "value2"},
 {"my\_map\_map.attr3\_register", "value3"},
 {"my\_map\_map.attr4\_register", "value4"},
 {"my\_map\_map.attr5\_0\_map.subattr1\_register", "subvalue1"},
 {"my\_map\_map.attr5\_0\_map.subattr2\_register", "subvalue2"},
 {"my\_map\_map.attr5\_0\_map.subattr3\_register", "subvalue3"},
 {"my\_map\_map.attr5\_0\_map.subattr4\_register", "subvalue4"},
 {"my\_map\_map.attr5\_1\_map.subattr1\_register", "subvalue5"},
 {"my\_map\_map.attr5\_1\_map.subattr2\_register", "subvalue6"},
 {"my\_map\_map.attr5\_1\_map.subattr3\_register", "subvalue7"},
 {"my\_map\_map.attr5\_1\_map.subattr4\_register", "subvalue8"}
 ]}
 ], 1.0, 2}}

Here the attr5 is multivalued (thanks to \_0, \_1..., but could be UUIDs
as well). However:
\* How to search for any "attr5\_\*"? It seems that wildcards in query
\_attributes\_ are not supported (e.g.: Riak.Search.query("test\_index",
"my\_map\_map.attr5\_\*\_map.subattr1\_register:\*") won't work)
\* Even if that worked, how to filter on one submap? The search
"my\_map\_map.attr5\_\*\_map.subattr1\_register:subvalue1 AND
my\_map\_map.attr5\_\*\_map.subattr4\_register:subvalue4" would return key1
but not key2?

Are some other approaches worth digging? I've thought of:
\* not storing a whole "user" as an object, but each attribute as an
object (key being {id, attribute}). However it doesn't enable
multivalued complex attributes neither
\* using JSON instead of CRDTs: would such search filters be doable?
Also, no eventual consistency with this approach since, as far as I
understand, Riak cannot "merge" JSON documents

Any feedback on how you implement such models is welcome.

(Sorry if that's not the right place to ask - if so feel free to tell
where it's better to ask.)

Cheers,

Paul

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

