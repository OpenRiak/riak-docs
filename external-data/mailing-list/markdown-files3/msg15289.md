---
title: "Re: Using $bucket index in java client"
description: ""
project: community
lastmod: 2014-12-01T21:48:07-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg15289"
mailinglist_parent_id: "msg15216"
author_name: "niedomnie"
project_section: "mailinglistitem"
sent_date: 2014-12-01T21:48:07-08:00
---


not possible on that code - I've overrided some classes, and no it is
possible - use MyBinIndexQuery instead - it was tested against $key index -
but problem is with appending \_BIN or \_INT suffix to key name (always)

package com.thalesgroup.riak

import com.basho.riak.client.api.commands.CoreFutureAdapter
import com.basho.riak.client.api.commands.indexes.BinIndexQuery
import com.basho.riak.client.api.commands.indexes.SecondaryIndexQuery
import com.basho.riak.client.core.RiakCluster
import com.basho.riak.client.core.RiakFuture
import com.basho.riak.client.core.operations.SecondaryIndexQueryOperation
import com.basho.riak.client.core.query.Location
import com.basho.riak.client.core.query.Namespace
import com.basho.riak.client.core.util.BinaryValue

import java.nio.charset.Charset

abstract class MyInit> extends
SecondaryIndexQuery.Init
{
 Charset charset = Charset.defaultCharset();

 public MyInit(Namespace namespace, String indexName, S start, S end)
 {
// super(namespace, indexName + SecondaryIndexQuery.Type.\_BIN, start,
end);
 super(namespace, indexName, start, end);
 }

 public MyInit(Namespace namespace, String indexName, S match)
 {
// super(namespace, indexName + SecondaryIndexQuery.Type.\_BIN,
match);
 super(namespace, indexName, match);
 }

 T withCharacterSet(Charset charset)
 {
 this.charset = charset;
 return self();
 }
}

public class MyBuilder extends MyInit
{
 public MyBuilder(Namespace namespace, String indexName, String start,
String end)
 {
 super(namespace, indexName, start, end);
 }

 public MyBuilder(Namespace namespace, String indexName, String match)
 {
 super(namespace, indexName, match);
 }

 @Override
 protected MyBuilder self()
 {
 return this;
 }

 public MyBinIndexQuery build()
 {
 return new MyBinIndexQuery(this);
 }
}

public class MyBinIndexQuery extends SecondaryIndexQuery
{
 private final Charset charset;
 private final SecondaryIndexQuery.IndexConverter converter;

 public MyBinIndexQuery(MyInit builder)
 {
 super(builder);
 this.charset = builder.charset;
 this.converter = new SecondaryIndexQuery.IndexConverter() {
 @Override
 public String convert(BinaryValue input)
 {
 return input.toString(charset);
 }

 @Override
 public BinaryValue convert(String input)
 {
 return BinaryValue.create(input, charset);
 }
 };
 }

 @Override
 protected SecondaryIndexQuery.IndexConverter getConverter()
 {
 return converter;
 }

 @Override
 protected RiakFuture
executeAsync(RiakCluster cluster)
 {
 RiakFuture coreFuture =
 executeCoreAsync(cluster);

 BinQueryFuture future = new BinQueryFuture(coreFuture);
 coreFuture.addListener(future);
 return future;
 }

 protected final class BinQueryFuture extends
CoreFutureAdapter {
 public
BinQueryFuture(RiakFuture coreFuture)
 {
 super(coreFuture);
 }

 @Override
 protected MyResponse
convertResponse(SecondaryIndexQueryOperation.Response coreResponse)
 {
 return new MyResponse(namespace, coreResponse, converter);
 }

 @Override
 protected MyBinIndexQuery
convertQueryInfo(SecondaryIndexQueryOperation.Query coreQueryInfo)
 {
 return MyBinIndexQuery.this;
 }
 }

 protected static abstract class Init> extends
SecondaryIndexQuery.Init
 {
 private Charset charset = Charset.defaultCharset();

 public Init(Namespace namespace, String indexName, S start, S end)
 {
 super(namespace, indexName + Type.\_BIN, start, end);
 }

 public Init(Namespace namespace, String indexName, S match)
 {
 super(namespace, indexName + Type.\_BIN, match);
 }

 T withCharacterSet(Charset charset)
 {
 this.charset = charset;
 return self();
 }

 }

 /\*\*
 \* Builder used to construct a BinIndexQuery.
 \*/
 public static class Builder extends Init
 {

 /\*\*
 \* Construct a Builder for a BinIndexQuery with a range.
 \* 
 \* Note that your index name should not include the Riak {@literal
\_int} or
 \* {@literal \_bin} extension.
 \* 
 \* @param namespace The namespace in Riak to query.
 \* @param indexName The index name in Riak to query.
 \* @param start The start of the 2i range.
 \* @param end The end of the 2i range.
 \*/
 public Builder(Namespace namespace, String indexName, String start,
String end)
 {
 super(namespace, indexName, start, end);
 }

 /\*\*
 \* Construct a Builder for a BinIndexQuery with a single 2i key.
 \* 
 \* Note that your index name should not include the Riak {@literal
\_int} or
 \* {@literal \_bin} extension.
 \* 
 \* @param namespace The namespace in Riak to query.
 \* @param indexName The name of the index in Riak.
 \* @param match the 2i key.
 \*/
 public Builder(Namespace namespace, String indexName, String match)
 {
 super(namespace, indexName, match);
 }

 @Override
 protected Builder self()
 {
 return this;
 }

 /\*\*
 \* Construct the query.
 \* @return a new BinIndexQuery
 \*/
 public MyBinIndexQuery build()
 {
 return new MyBinIndexQuery(this);
 }

 }

 public static class MyResponse extends
SecondaryIndexQuery.Response
 {
 final SecondaryIndexQueryOperation.Response coreResponseCopy;
 final SecondaryIndexQuery.IndexConverter converterCopy;

 protected MyResponse(Namespace queryLocation,
SecondaryIndexQueryOperation.Response coreResponse,
SecondaryIndexQuery.IndexConverter converter)
 {
 super(queryLocation, coreResponse, converter);
 this.coreResponseCopy = coreResponse
 this.converterCopy = converter
 }

 @Override
 public List getEntries()
 {
 List convertedList = new ArrayList();
 for (SecondaryIndexQueryOperation.Response.Entry e :
coreResponseCopy.getEntryList())
 {
 Location loc = getLocationFromCoreEntry(e);
 MyEntry ce = new MyEntry(loc, e.getIndexKey(),
converterCopy);
 convertedList.add(ce);
 }
 return convertedList;
 }

 public class MyEntry extends
SecondaryIndexQuery.Response.Entry
 {
 protected MyEntry(Location riakObjectLocation, BinaryValue
indexKey, SecondaryIndexQuery.IndexConverter converter)
 {
 super(riakObjectLocation, indexKey, converter);
 }

 }
 }
}



--
View this message in context: 
http://riak-users.197444.n3.nabble.com/Using-bucket-index-in-java-client-tp4032125p4032198.html
Sent from the Riak Users mailing list archive at Nabble.com.

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com









