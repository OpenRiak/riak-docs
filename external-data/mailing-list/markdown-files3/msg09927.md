---
title: "Re: Differences between riak_client and riak_kv_mrc_pipe MapReduce	when one node is down."
description: ""
project: community
lastmod: 2013-01-30T13:59:43-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg09927"
mailinglist_parent_id: "msg09920"
author_name: "John Daily"
project_section: "mailinglistitem"
sent_date: 2013-01-30T13:59:43-08:00
---


Riak's MapReduce functionality cannot survive a node failure. If a vnode 
involved with a query fails while actively processing the request, the entire 
query will have to be re-run. The failed query should be automatically 
terminated, but you'll have to re-run the query yourself.

If you create queries using Riak Pipe (the technology layer beneath MapReduce), 
it is possible to create queries that can survive a vnode failure, but that is 
not a trivial exercise.

Regarding the empty result set you're seeing: one possibility is that a vnode 
has failed recently and has come back online without data. MapReduce will not 
currently trigger a read repair, but that problem should be resolved with the 
forthcoming Riak 1.3 release.

-John Daily
Technical Evangelist
Basho

On Jan 30, 2013, at 8:05 AM, gu...@mail.mipt.ru wrote:

> We have 6 node riak cluster.I simple custom erlang application for custom 
> MapReduce job.
> 
> We start MapReduce job using riak\_kv\_mrc\_pipe pipe module,for example - 
> 
> Query = [{map, {modfun,Mod,MapFun},[do\_prereduce,{from,1}], false},{reduce, 
> {modfun,Mod,ReduceFun},[{reduce\_phase\_batch\_size, 1000}], true}],
> riak\_kv\_mrc\_pipe:mapred({index,Bucket,Field,From,To},Query,Timeout).
> 
> But if one of the node down for along time. Response is unpredictable 
> sometimes it's return {ok,GoodResultList}, but sometimes {ok,[]}(empty list).
> We trace riak\_kv and riak\_pipe and found too problem:
> 1. In riak\_kv\_pipe\_index or in riak\_kv\_pipe\_liskeys created fitting\_spec this 
> nval always is 1.
> 2. Actual error is occurred in riak\_pipe\_vnode:remaining\_preflist that retun 
> empty PrefList for some Hash(#fitting\_spec.nval is 1). It use 
> riak\_core\_apl:get\_primary\_apl function.
> 
> But if we use old style map reduce,for example:
> {ok,C} = riak:local\_client(),
> Me = self(),
> Query = [{map, {modfun,Mod,MapFun},[do\_prereduce,{from,1}], 
> false},{reduce, {modfun,Mod,ReduceFun},[{reduce\_phase\_batch\_size, 1000}], 
> true}],
> {ok, {ReqId,FlowPid}} = C:mapred\_stream(Query,Me,Timeout),
> 
> {ok,\_}=riak\_kv\_index\_fsm\_sup:start\_index\_fsm(zont\_riak\_connection:riak\_node(),
> [{raw, ReqId,FlowPid}, [Bucket, none,{range,Field,From,To},Timeout,mapred]]),
> luke\_flow:collect\_output(ReqId, Timeout).
> 
> Query executed well. But problem is that do\_prereduce and 
> {reduce\_phase\_batch\_size, 1000} is ignored,that why execution is slow.
> 
> 
> Can you make some recommendation? May be riak\_pipe\_vnode:remaining\_preflist 
> we need use riak\_core\_apl:get\_apl\_ann or set #fitting\_spec.nval to nval from 
> out Bucket props?
> 
> \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
> riak-users mailing list
> riak-users@lists.basho.com
> http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com


\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

