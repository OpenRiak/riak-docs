---
title: "Re: Emulating composite index queries with secondary indexes and key	filters"
description: ""
project: community
lastmod: 2012-08-28T06:27:48-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg08380"
mailinglist_parent_id: "msg08379"
author_name: "Olav Frengstad"
project_section: "mailinglistitem"
sent_date: 2012-08-28T06:27:48-07:00
---


Looking at riak\_kv\_mapred\_json it seems to be the case that you
can only do key filter on entire buckets.

On the other hand one can still use the riak\_kv\_mapred\_filters, even
though it's ugly constructing all the filter manually instead of matching
binary patterns:

{ok, Pid} = riakc\_pb\_socket:start\_link("127.0.0.1", 8087),
{ok, Filter} = riak\_kv\_mapred\_filters:build\_filter([[<<"ends\_with">>,"1"]]),
MapReduce = [
 { reduce
 , {qfun, fun(X, F) -> lists:filter(fun({A, B}) -> F(B) end, X) end},
 , riak\_kv\_mapred\_filters:compose(Filter),
 , true}],
Index = {index, <<"test1">>, <<"field\_int">>, <<"123">>},
riakc\_pb\_socket:mapred(Pid, Index, MapReduce).

Question 2 & 3 still remains though:
>> 2) Would this be a efficient solution, considering the 2i query
>> will return 10k+ results? the reduce should cut that in half.
>> 3) What other options to i have for querying this? Obviously i can
>> use Riak search, but the term based indexing puts me off. Other
>> option is building this manually with empty object just linking.


2012/8/28 Jeremiah Peschka :
> As best as I can recall, you can't key filter on 2i. You can, however,
> perform range filtering. You could query where the 2i key is between
> 20110101T00:00:00Z|a|a and 20110201T00:00:00Z|zzz|zzz
>
> Please forgive any typos. I'm using a phone.
>
>
> On Tuesday, August 28, 2012, Olav Frengstad wrote:
>>
>> Hey,
>>
>> I'm looking to use riak to store time series. So naturaly i'm in the
>> processes of validating all possible methods this query. A object
>> has a id, origin, timestamp and type. The query in question is to
>> select all object within a time range that originated from "origin"
>> and has a certain "type".
>>
>> The current plan is to store the timestamp as a secondary index and
>> then have composite keys responsible for matching origin/type predicate.
>>
>> A key would look like this: "::".
>>
>> To query one would just pipe the 2i query to key filter map reduce:
>>
>> curl -X POST -H "Content-Type: application/json" -d '{"inputs":{
>> "bucket" : "seriesx", "index" : "timestamp\_int", "start" : 123,
>> "end" : 456, "key\_filters" : [["ends\_with", ":"]]}}'
>>
>> In regards to this "imaginary" solution i have a few questions:
>> 1) is this possible, or does key filter only work on a bucket?
>> 2) Would this be a efficient solution, considering the 2i query
>> will return 10k+ results? the reduce should cut that in half.
>> 3) What other options to i have for querying this? Obviously i can
>> use Riak search, but the term based indexing puts me off. Other
>> option is building this manually with empty object just linking.
>>
>> --
>> Med Vennlig Hilsen
>> Olav Frengstad
>>
>> Systemutvikler // FWT
>> +47 920 42 090
>>
>> \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
>> riak-users mailing list
>> riak-users@lists.basho.com
>> http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
>
>
>
> --
> ---
> Jeremiah Peschka
> Managing Director, Brent Ozar PLF, LLC



-- 
Med Vennlig Hilsen
Olav Frengstad

Systemutvikler // FWT
+47 920 42 090

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

