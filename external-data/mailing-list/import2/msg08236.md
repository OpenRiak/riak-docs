---
title: "Re: multi-get (yet again)"
description: ""
project: community
lastmod: 2012-08-09T02:11:16-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg08236"
mailinglist_parent_id: "msg08234"
author_name: "Kresten Krab Thorup"
project_section: "mailinglistitem"
sent_date: 2012-08-09T02:11:16-07:00
---


The only issue with this approach is AFAIK that M/R effectively runs with R=1, 
i.e. it doesn't ensure that a value is consistent across replicas. 

IMHO riak\_kv\_mapreduce should have a map\_get\_object\_value, which does a proper 
RiakClient:get, i.e. something like this: [will be slower, but will honour the 
bucket's default R value].

map\_get\_object\_value({error, notfound}=NF, KD, Action) -> 
 
 notfound\_map\_action(NF, KD, Action); 
 
map\_get\_object\_value(RO, KD, Action) -> 
 
 {ok, RiakClient} = riak:local\_client(), 
 
 case RiakClient:get(riak\_object:bucket(RO),riak\_object:bucket(RO)) of 
 
 {error, notfound}=NF -> 
 
 notfound\_map\_action(NF, KD, Action); 
 
 {ok, RiakObject} -> 
 
 [riak\_object:get\_value(RiakObject)] 
 
 end. 
 
 
 
 
 


Kresten


On Aug 9, 2012, at 10:46 AM, Parnell Springmeyer  wrote:

> Jeremy,
> 
> I was looking for something similar and first built an extra handler onto an 
> internal erlang cowboy API server that used maelstrom (my own worker pool OTP 
> application).
> 
> It was used to make a simple POST with a string of the {bucket, key} pairs 
> and the server would concurrently GET and combine the results and send it 
> back. This was very fast (thousands of keys GET in ms).
> 
> Since that seemed gross, I then decided (based on some input from someone 
> else on the list) to try using a simple Map/Reduce phase that did not use 
> javascript but the erlang functions (since those are going to be really fast 
> and take advantage Erlang's concurrency better than the javascript VM's).
> 
> In python, you can do this to run that type of M/R phase without knowing any 
> Erlang code:
> 
> client = riak.RiakClient()
> 
> # Add your KNOWN bucket and key pairs (you can do this in a loop)
> query = client.add(bucket, key)
> query.add(bucket, key)
> query.add(bucket, key)
> etcâ€¦ (as many as you like)
> 
> # Now tell the map and reduce phases to use Erlang module "riak\_kv\_mapreduce" 
> and its given function 
> # "map\_object\_value" and "reduce\_set\_union".
> results = client.map(["riak\_kv\_mapreduce", "map\_object\_value"]) \
> .reduce(["riak\_kv\_mapreduce", "reduce\_set\_union"]) \
> .run()
> 
> The above returns results faster for me, than the brokered multi-get approach 
> I used (I guarantee my brokered multi-get is faster than anything you can do 
> with python + gevent, if that's the case, the M/R phase is definitely the 
> route you want to go).
> 
> So IMHO, it is very fast as long as you know the buckets and keys you want to 
> get.
> 
> On Aug 9, 2012, at 12:11 AM, Jeremy Dunck wrote:
> 
>> I'm new to riak and need multi-get (that is, getting the value and/or
>> existence of keys in a single network-trip latency).
>> 
>> I was wondering what the latency of the map-reduce approach is?
>> http://lists.basho.com/pipermail/riak-users\_lists.basho.com/2011-February/003229.html
>> 
>> Alternatively, has anyone tried scaling concurrent gets (perhaps with
>> evented io) to do many concurrent requests and combining results on
>> the client?
>> 
>> I am toying with a python+gevent multiget function. If the stance is
>> still that a multiget operation doesn't belong in core, I'm a little
>> surprised that there doesn't seem to at least be a nice client-lib API
>> func to do it. It sure seems useful...
>> 
>> In my use-case, the immediate need is to know whether a db insert
>> needs to be done. We're handling too many keys to want to store in
>> memory (so no redis, etc), and we don't want to go to the db more than
>> we need to, so it seems riak would be good here. But we're getting
>> 1000s of potential insert keys and want to whittle down all those to a
>> relative few db inserts.
>> 
>> So I was thinking riak key-per-id, and insert to the db iff the riak
>> key doesn't exist, then add the riak key. We'll get some race
>> conditions on the insert, but that's OK in our case.
>> 
>> We do need low latency on the riak check, though, hence either
>> multiplexing w/ eventing or map-reduce (if that latency is actually
>> good).
>> 
>> Am I doing it wrong?
>> 
>> \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
>> riak-users mailing list
>> riak-users@lists.basho.com
>> http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
> 
> 
> \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
> riak-users mailing list
> riak-users@lists.basho.com
> http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com



Mobile: + 45 2343 4626 | Skype: krestenkrabthorup | Twitter: @drkrab
Trifork A/S | Margrethepladsen 4 | DK- 8000 Aarhus C | Phone : +45 8732 
8787 | www.trifork.com
 




\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

