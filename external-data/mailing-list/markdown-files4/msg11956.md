---
title: "Re: Java client - conflict resolver on both fetch() and store()?"
description: ""
project: community
lastmod: 2013-08-10T19:34:50-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg11956"
mailinglist_parent_id: "msg11955"
author_name: "Sean Cribbs"
project_section: "mailinglistitem"
sent_date: 2013-08-10T19:34:50-07:00
---


I'm sure Roach will correct me if I'm off-base, but I believe the store
operation does a fetch and resolve before writing. I think the ideal way to
do that is to create a Mutation (T being your POJO) as well, in which
case it's less of a "store" and more of a "fetch-modify-write". The way to
skip the fetch/modify is to use the withoutFetch() option on the operation
builder.


On Sat, Aug 10, 2013 at 6:50 PM, Matt Painter  wrote:

&gt; Hi,
&gt;
&gt; I've just rolled up my sleeves and have started to make my application
&gt; more robust with conflict resolution.
&gt;
&gt; I am currently using a @RiakVClock in my POJO (I need to think more about
&gt; whether the read/modify/write approach is preferable or whether I'd have to
&gt; rearchitect things).
&gt;
&gt; I read in the Riak Handbook the recommendation that conflicts are best
&gt; resolved on read - not write - however the example App.java snipping on
&gt; the Storing data in 
&gt; Riak
&gt; page
&gt; in the Java client's doco uses a resolver on both the store() and 
&gt; fetch()operations.
&gt;
&gt; Indeed, if I don't specify my conflict resolver in my store(), things
&gt; blow up (in my unit test, mind - I'm still getting my head around the whole
&gt; area so my test may be a bit contrived).
&gt;
&gt; However when I use it in both places, my conflicts are being resolved
&gt; twice. Is this anticipated?
&gt;
&gt; My store is:
&gt;
&gt; bucket.store(record).returnBody(true).
&gt; withoutFetch().withResolver(myConflictResolver);
&gt; and my fetch is:
&gt;
&gt; bucket.fetch(id, Record.class).withResolver(myConflictResolver).execute();
&gt; The order of operations in my test is:
&gt;
&gt; 1. Store new record
&gt; 2. Fetch the record as firstRecord
&gt; 3. Fetch the record as secondRecord
&gt; 4. Modify a field on firstRecord and secondRecord
&gt; 5. Save firstRecord
&gt; 6. Save secondRecord - this invokes my resolver with two siblings
&gt; 7. Read record - this also invokes my resolver with the two siblings
&gt;
&gt; Am I missing something? Or is this what's supposed to happen? I'm not too
&gt; worried - the double-handling is hardly that intensive - but I'm keen to
&gt; get it right.
&gt;
&gt; Thanks in advance,
&gt; Matt
&gt;
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;
&gt;


-- 
Sean Cribbs 
Software Engineer
Basho Technologies, Inc.
http://basho.com/
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

