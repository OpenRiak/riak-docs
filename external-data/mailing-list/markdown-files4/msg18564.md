---
title: "Re: Node Recovery Questions"
description: ""
project: community
lastmod: 2018-08-08T10:11:50-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg18564"
mailinglist_parent_id: "msg18563"
author_name: "Martin Sumner"
project_section: "mailinglistitem"
sent_date: 2018-08-08T10:11:50-07:00
---


Based on a quick read of the code, compaction in bitcask is performed only
on "readable" files, and the current active file for writing is excluded
from that list. With default settings, that active file can grow to 2GB.
So it is possible that if objects had been replaced/deleted many times
within the active file, that space will not be recovered if all the
replacements amount to &lt; 2GB per vnode. So at these small data sizes - you
may get a relatively significant discrepancy between an old and recovered
node in terms of disk space usage.

On 8 August 2018 at 17:37, Martin Sumner 
wrote:

&gt; Sean,
&gt;
&gt; Some partial answers to your questions.
&gt;
&gt; I don't believe force-replace itself will sync anything up - it just
&gt; reassigns ownership (hence handoff happens very quickly).
&gt;
&gt; Read repair would synchronise a portion of the data. So if 10% of you
&gt; data is read regularly, this might explain some of what you see.
&gt;
&gt; AAE should also repair your data. But if nothing has happened for 4 days,
&gt; then that doesn't seem to be the case. It would be worth checking the
&gt; aae-status page (http://docs.basho.com/riak/kv/2.2.3/using/admin/riak-
&gt; admin/#aae-status) to confirm things are happening.
&gt;
&gt; I don't know if there are any minimum levels of data before bitcask will
&gt; perform compaction. There's nothing obvious in the code that wouldn't be
&gt; triggered way before 90%. I don't know if it will merge on the active file
&gt; (the one currently being written to), but that is 2GB max size (configured
&gt; through bitcask.max\_file\_size).
&gt;
&gt; When you say the size of the bitcask directory - is this the size shared
&gt; across all vnodes on the node? I guess if each vnode has a single file
&gt; &lt;2GB, and there are multiple vnodes - something unexpected might happen
&gt; here? If bitcask does indeed not merge the file active for writing.
&gt;
&gt; In terms of distribution around the cluster, if you have an n\_val of 3 you
&gt; should normally expect to see a relatively even distribution of the data on
&gt; failure (certainly not it all going to one). Worst case scenario is that 3
&gt; nodes get all the load from that one failed node.
&gt;
&gt; When a vnode is inaccessible, 3 (assuming n=3) fallback vnodes are
&gt; selected to handle the load for that 1 vnode (as that vnode would normally
&gt; be in 3 preflists, and commonly a different node will be asked to start a
&gt; vnode for each preflist).
&gt;
&gt;
&gt; I will try and dig later into bitcask merge/compaction code, to see if I
&gt; spot anything else.
&gt;
&gt; Martin
&gt;
&gt;
&gt;
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

