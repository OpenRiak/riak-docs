---
title: "Re: Use of fallback nodes for get requests?"
description: ""
project: community
lastmod: 2010-08-04T04:58:29-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg00840"
mailinglist_parent_id: "msg00826"
author_name: "Nico Meyer"
project_section: "mailinglistitem"
sent_date: 2010-08-04T04:58:29-07:00
---


Hi Justin,

I think we are coming from two different directions here, leading to
some confusion. You seem to treat a get for a non existing key as an
error, in which case all your points are valid of course. I suspected
that this is the reason for the current design choice, but I didn't see
it stated anywhere explicitly. And also notfound seems to be handled
differently from other types of errors, at least in the way it is
signalled to the client, so I didn't immediately think of it as an error
case.
On the other hand there are many applications where asking for a key
that has never been put is perfectly valid, an not\_found is indeed the
right answer in that case. Our application is an example of that. The
key is given (it is a unique cookie ID), and we need to check if we saw
a specific ID before in a certain context and if so get some data that
was associated with the ID back then. More often than not this is not
the case, so notfound is the expected answer.

If you read my original mail again with that use case in mind it might
become clearer what my problem with the current design is.

Having to fulfil the precondition that we only do gets for keys we know
to have been put before would require another datastore for that
purpose, which seems kind of akward and unnecessary, since riak has all
the required data to handle our use case.

Please let me know if I need to further clarify my thoughts about this.
English is not my first language and its hard enough to reason about
these things in German and face-to-face :-).

Cheers,
Nico

Am Montag, den 02.08.2010, 22:29 -0400 schrieb Justin Sheehy: 
&gt; Hi, Nico.
&gt; 
&gt; On Mon, Aug 2, 2010 at 1:19 PM, Nico Meyer  wrote:
&gt; 
&gt; &gt; What I mean is, if I do a get request for a key with R=N, and one of the
&gt; &gt; first N nodes in the preflist is down the request will still succeed.
&gt; &gt; Why is that? Doesn't that undermine the purpose of seting R to a high
&gt; &gt; number (specifically setting it to N)? That way a request might succeed
&gt; &gt; even if all primary nodes responsible for the key are unavailable.
&gt; 
&gt; You are correct, and this is intentional. There is nothing in the R
&gt; or W settings that is intended to indicate anything at all about
&gt; "primary" nodes. It is rather simply the number of successful
&gt; responses that the client wishes to wait for, and thus the degree of
&gt; quorum sought before a client reply is sent. Using fallback nodes to
&gt; satisfy reads is a natural result of using fallback nodes to satisfy
&gt; writes.
&gt; 




&gt; If all primary nodes responsible for a key are unavailable, but enough
&gt; of the fallback nodes for that key have received a value for that key
&gt; since they went unavailable (through a fallback write) then a request
&gt; to get that key might succeed. I am not sure why you see this as a
&gt; bad thing.
&gt; 
&gt; (It will only succeed if R nodes actually provide a successful result,
&gt; not just if they are available.)
&gt; 
&gt; &gt; On a similar note, why is the riak\_kv\_get\_fsm waiting for at least
&gt; &gt; (N/2)+1 responses, if there are only not\_found responses, effectively
&gt; &gt; ignoring a smaller R value of the request if the key does not exists?
&gt; 
&gt; This is a compromise to deal with real situations that can occur where
&gt; a single node might be taking a very long time to reply, and a value
&gt; has never been stored for a given key. Without either this basic
&gt; quorum default for notfounds or alternately considering a notfound as
&gt; success and thus only waiting for R of them, that situation would mean
&gt; that an R=1 request would take much longer to complete than an R=2
&gt; request (due to waiting for the slow node) which is confusing to most
&gt; users. Note that since it applies to notfounds, this tends to only
&gt; come into play for items that have never been successfully stored with
&gt; at least a basic quorum -- things that really are not present, that
&gt; is.
&gt; 
&gt; &gt; My guess was, that this also has to do with the use of fallback nodes:
&gt; &gt; Since the partition will usually be very small on the fallback/handoff
&gt; &gt; node, it is likely to be the first to answer. So to avoid returning
&gt; &gt; false not\_found responses, a basic quorum is required.
&gt; &gt; Am I on the right track here?
&gt; 
&gt; It doesn't have anything to do with fallback nodes explicitly. It is
&gt; for situations where a node is under any condition that will slow it
&gt; down significantly. In such situations, there is little to be gained
&gt; in waiting for all N replies if (N/2)+1 have already declared
&gt; notfound.
&gt; 
&gt; &gt; The problem is, this is imposed even for the case that all nodes are up.
&gt; &gt; If one requires very low latency or very high availability (that's why
&gt; &gt; one uses a small R value in the first place) and does a lot of gets for
&gt; &gt; non existent keys, riak silently screws you over by raising R for those
&gt; &gt; keys.
&gt; 
&gt; It seems that there is something here worth clarifying. If you are
&gt; issuing requests with W+R&lt;=N, and some reads following writes return
&gt; notfound during an interval immediately following initial storage
&gt; time... well, that's what you asked for by not requesting a quorum.
&gt; If you store the object with a sufficiently high W value first, then
&gt; you will not get this sort of notfound response even if your R value
&gt; is only 1.
&gt; 
&gt; I suppose that providing the freedom to do this might be considered
&gt; "screwing you over," but we see it more as allowing you to make
&gt; different choices while still providing safe and unsurprising default
&gt; behavior. If you try hard enough to screw yourself over, though, Riak
&gt; won't stop you. If you issue write requests (to any dynamo-model
&gt; system) with some W, followed immediately by a read request with some
&gt; R, and W+R is not greater than N, you should not be expecting the
&gt; write to necessarily be reflected yet.
&gt; 
&gt; &gt; I most likely missed something here, but some ad hoc test I did seem to
&gt; &gt; be consistent with my understanding of the code.
&gt; 
&gt; You have certainly put some real effort into understanding some
&gt; choices made in the Riak code, which I appreciate. I hope that I have
&gt; helped to extend your understanding of the real operational scenarios
&gt; that have motivated those choices, and how the code will behave in
&gt; those scenarios.
&gt; 
&gt; Best,
&gt; 
&gt; -Justin




\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

