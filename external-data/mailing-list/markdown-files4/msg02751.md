---
title: "Re: Multiple disks"
description: ""
project: community
lastmod: 2011-03-27T18:06:11-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg02751"
mailinglist_parent_id: "msg02706"
author_name: "Dan Reverri"
project_section: "mailinglistitem"
sent_date: 2011-03-27T18:06:11-07:00
---


Hi Joe,

You observation regarding question 5 is correct. The coordinating FSM
would attempt to send the request to the failed vnode and receive
either an error or no reply. A request may still succeed if enough of
the other vnodes respond; "enough" would be determined by the "r",
"w", "dw", or "rw" setting of the request. Handoff would not occur in
this scenario.

Thanks,
Dan

Daniel Reverri
Developer Advocate
Basho Technologies, Inc.
d...@basho.com


On Wed, Mar 23, 2011 at 5:58 PM, Joseph Blomstedt
 wrote:
&gt;
&gt; Sorry, I don't have a lot of time right now. I'll try to write a more
&gt; detailed response later.
&gt;
&gt; &gt;&gt;&gt; With a few hours of investigation today, your patch is looking
&gt; &gt;&gt;&gt; promising. Maybe you can give some more detail on what you did in your
&gt; &gt;&gt;&gt; experiments a few months ago?
&gt;
&gt; I'll try to write something up when I have the time. I need to find my
&gt; notes. In general, the focus was mostly on performance tuning,
&gt; although I did look into error/recovery a bit as well. My main goal at
&gt; the time was trying to reduce disk seeks as much as possible. Bitcask
&gt; is awesome as it is an append only store, but if you have multiple
&gt; bitcasks being written to on the same disk you still end up with disk
&gt; seeking depending on how the underlying file system works. I was
&gt; trying to mitigate this as much as possible, given a project that used
&gt; bitcask in a predominately write-only mode (basically as a transaction
&gt; log that was only written to; read only in failure conditions). BTW,
&gt; concerning RAID, I recall seeing better performance spreading vnode
&gt; bitcasks across several smaller RAID arrays than using a single larger
&gt; RAID array during write-heavy bursts.
&gt;
&gt; &gt;&gt;&gt; Oh, one thing I noticed is that while Riak starts up, if there's a bad
&gt; &gt;&gt;&gt; disk then it will shutdown (the whole node), at this line:
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt; https://github.com/jtuple/riak\_kv/blob/jdb-multi-dirs/src/riak\_kv\_bitcask\_backend.erl#L103
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt; That makes sense, but I'm wondering if it's possible to let the node
&gt; &gt;&gt;&gt; start since some of its vnodes would be able to open their bitcasks just
&gt; &gt;&gt;&gt; fine. I wonder if it's as simple as removing that line?
&gt; &gt;&gt;&gt;
&gt;
&gt; You don't want to remove that line, riak expects the vnode to come
&gt; online or kill the entire node. You would need to have a vnode failure
&gt; trigger an ownership change if you really wanted things to behave
&gt; properly.
&gt;
&gt; The better case is to not have the vnode fail if there are other
&gt; existing disks. That's an easy change that I'll throw together when I
&gt; have time. Basically, when a vnode starts, have it pick a bitcask
&gt; directory, if that directory fails, then have it pick a different
&gt; directory. If all configured directories fail, then call riak:stop.
&gt; Thus, if a disk fails and a vnode restarts, it should create a new
&gt; empty bitcask on a working disk. Then read repair will slowly rewrite
&gt; your data depending on data access (handoff won't occur though, unless
&gt; that's added in patch).
&gt;
&gt; &gt; After reading todays recap, I am a bit unsure:
&gt; &gt;
&gt; &gt;&gt; 5) Q --- Would Riak handle an individual vnode failure the same way as
&gt; &gt;&gt; an entire node failure? (from grourk via #riak)
&gt; &gt;&gt;
&gt; &gt;&gt;    A --- Yes. The request to that vnode would fail and will be routed
&gt; &gt;&gt; to the next available vnode
&gt; &gt;
&gt; &gt; Is it really handled the same way? I don't believe handoff will occur. The
&gt; &gt; R/W values still apply of course, but I think there will be one less replica
&gt; &gt; of the keys that map to the failed vnode until the situation.
&gt; &gt; I have delved quite a bit into the riak code, but if I really missed
&gt; &gt; something I would be glad if someone could point me to the place where a
&gt; &gt; vnode failure is detected. As far as I can see, the heavy lifting happens in
&gt; &gt; riak\_kv\_util:try\_cast/5 (
&gt; &gt; https://github.com/basho/riak\_kv/blob/riak\_kv-0.14.1/src/riak\_kv\_util.erl#L78),
&gt; &gt; which only checks if the whole node is up.
&gt;
&gt; I don't think handoff occurs either. Maybe folks at Basho can look
&gt; into this further, or someone can test it. I'll test it
&gt; tonight/tomorrow if I have the time. It looks like the cast will
&gt; occur, but never return. So, your overall write may fail depending on
&gt; your W-val. Is there something we're both missing here?
&gt;
&gt; -Joe
&gt;
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

