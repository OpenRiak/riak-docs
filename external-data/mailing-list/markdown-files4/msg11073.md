---
title: "Re: On siblings"
description: ""
project: community
lastmod: 2013-05-15T07:04:41-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg11073"
mailinglist_parent_id: "msg11070"
author_name: "Jeremiah Peschka"
project_section: "mailinglistitem"
sent_date: 2013-05-15T07:04:41-07:00
---


John Daily (@macintux) wrote a great blog post that covers sibling behavior
[1]

In short, though, because you're supplying an older vector clock, and you
have allow\_mult turned on, Riak makes the decision that since a vector
clock is present that conflicts with what's already on disk a sibling
should be created.

As I understand it, the only way to write into Riak and not get siblings is
to set allow\_mult to false - even leaving out vector clocks will lead to
siblings if allow\_mult is true. Or so John Daily's chart claims.

[1]: http://basho.com/riaks-config-behaviors-part-2/

---
Jeremiah Peschka - Founder, Brent Ozar Unlimited
MCITP: SQL Server 2008, MVP
Cloudera Certified Developer for Apache Hadoop


On Tue, May 14, 2013 at 10:48 PM, Jeremy Ong  wrote:

&gt; To clarify, I am using the erlang client. From the looks of it, the vector
&gt; clock transition to the new value is opaque to the client so the only way
&gt; to streamline this use case is to pass the `return\_body` option (My use
&gt; case is one read, many subsequent writes while updating in memory).
&gt;
&gt; In this case however, I already have the value in memory, so it seems
&gt; inefficient to have to get the entire riakc\_obj back when I really just
&gt; need the metadata to construct the new object. Is this correct?
&gt;
&gt;
&gt; On Tue, May 14, 2013 at 9:06 PM, Jeremy Ong  wrote:
&gt;
&gt;&gt; Suppose I have an object X.
&gt;&gt;
&gt;&gt; I make an update to X and store it as X1. I perform a put operation using
&gt;&gt; X1.
&gt;&gt;
&gt;&gt; The same client then makes a modification to X1 and stores it as X2.
&gt;&gt; Then, I perform a put operation using X2.
&gt;&gt;
&gt;&gt; This will create two siblings X1 and X2 if allow\_mult is true. Is there
&gt;&gt; any way I can avoid this? To me, the vector clock should have incremented
&gt;&gt; once when transitioning from X to X1, then once more when transitioning
&gt;&gt; from X1 to X2. This way, I shouldn't need to issue a get before I have to
&gt;&gt; perform another write since my data is already in memory.
&gt;&gt;
&gt;&gt; I probably am misunderstanding something about vector clocks. Does
&gt;&gt; anybody care to clarify this?
&gt;&gt;
&gt;&gt; Thanks,
&gt;&gt; Jeremy
&gt;&gt;
&gt;
&gt;
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;
&gt;
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

