---
title: "Re: Java client - conflict resolver on both fetch() and store()?"
description: ""
project: community
lastmod: 2013-08-11T01:44:49-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg11960"
mailinglist_parent_id: "msg11957"
author_name: "Matt Painter"
project_section: "mailinglistitem"
sent_date: 2013-08-11T01:44:49-07:00
---


PS. I presume the advantage of the mutator approach is that it reduces the
likelihood of sibling conflict resolution having to take place? Or, at
least the likelihood of unresolveable conflicts? Would my the resolver and
main POJO be the same using this approach?

Currently in my POJO, I'm maintaining a Map containing references to things
that have changed (key being the operation, value being identifiers and
data appropriate to the key) and am using this in my resolver for things
which need unravelling.


On 11 August 2013 14:43, Matt Painter  wrote:

&gt; Thanks Sean. I understand that the fetch-modify-write is the approach that
&gt; I'm \*not\* taking in this case, as I am using withoutFetch() and setting a
&gt; @RiakVClock in my POJO.
&gt;
&gt; I just need to weigh up whether the ideal way is sufficiently better to
&gt; rejig bits of my code - but I think that's a different issue :)
&gt;
&gt; M
&gt;
&gt;
&gt; On 11 August 2013 14:32, Sean Cribbs  wrote:
&gt;
&gt;&gt; I'm sure Roach will correct me if I'm off-base, but I believe the store
&gt;&gt; operation does a fetch and resolve before writing. I think the ideal way to
&gt;&gt; do that is to create a Mutation (T being your POJO) as well, in which
&gt;&gt; case it's less of a "store" and more of a "fetch-modify-write". The way to
&gt;&gt; skip the fetch/modify is to use the withoutFetch() option on the operation
&gt;&gt; builder.
&gt;&gt;
&gt;&gt;
&gt;&gt; On Sat, Aug 10, 2013 at 6:50 PM, Matt Painter  wrote:
&gt;&gt;
&gt;&gt;&gt; Hi,
&gt;&gt;&gt;
&gt;&gt;&gt; I've just rolled up my sleeves and have started to make my application
&gt;&gt;&gt; more robust with conflict resolution.
&gt;&gt;&gt;
&gt;&gt;&gt; I am currently using a @RiakVClock in my POJO (I need to think more
&gt;&gt;&gt; about whether the read/modify/write approach is preferable or whether I'd
&gt;&gt;&gt; have to rearchitect things).
&gt;&gt;&gt;
&gt;&gt;&gt; I read in the Riak Handbook the recommendation that conflicts are best
&gt;&gt;&gt; resolved on read - not write - however the example App.java snipping
&gt;&gt;&gt; on the Storing data in 
&gt;&gt;&gt; Riak
&gt;&gt;&gt; page
&gt;&gt;&gt; in the Java client's doco uses a resolver on both the store() and
&gt;&gt;&gt; fetch() operations.
&gt;&gt;&gt;
&gt;&gt;&gt; Indeed, if I don't specify my conflict resolver in my store(), things
&gt;&gt;&gt; blow up (in my unit test, mind - I'm still getting my head around the whole
&gt;&gt;&gt; area so my test may be a bit contrived).
&gt;&gt;&gt;
&gt;&gt;&gt; However when I use it in both places, my conflicts are being resolved
&gt;&gt;&gt; twice. Is this anticipated?
&gt;&gt;&gt;
&gt;&gt;&gt; My store is:
&gt;&gt;&gt;
&gt;&gt;&gt; bucket.store(record).returnBody(true).
&gt;&gt;&gt; withoutFetch().withResolver(myConflictResolver);
&gt;&gt;&gt; and my fetch is:
&gt;&gt;&gt;
&gt;&gt;&gt; bucket.fetch(id, Record.class).withResolver(myConflictResolver
&gt;&gt;&gt; ).execute();
&gt;&gt;&gt; The order of operations in my test is:
&gt;&gt;&gt;
&gt;&gt;&gt; 1. Store new record
&gt;&gt;&gt; 2. Fetch the record as firstRecord
&gt;&gt;&gt; 3. Fetch the record as secondRecord
&gt;&gt;&gt; 4. Modify a field on firstRecord and secondRecord
&gt;&gt;&gt; 5. Save firstRecord
&gt;&gt;&gt; 6. Save secondRecord - this invokes my resolver with two siblings
&gt;&gt;&gt; 7. Read record - this also invokes my resolver with the two siblings
&gt;&gt;&gt;
&gt;&gt;&gt; Am I missing something? Or is this what's supposed to happen? I'm not
&gt;&gt;&gt; too worried - the double-handling is hardly that intensive - but I'm keen
&gt;&gt;&gt; to get it right.
&gt;&gt;&gt;
&gt;&gt;&gt; Thanks in advance,
&gt;&gt;&gt; Matt
&gt;&gt;&gt;
&gt;&gt;&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt;&gt;&gt; riak-users mailing list
&gt;&gt;&gt; riak-users@lists.basho.com
&gt;&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt; --
&gt;&gt; Sean Cribbs 
&gt;&gt; Software Engineer
&gt;&gt; Basho Technologies, Inc.
&gt;&gt; http://basho.com/
&gt;&gt;
&gt;
&gt;
&gt;
&gt; --
&gt; Matt Painter
&gt; m...@deity.co.nz
&gt; +64 21 115 9378
&gt;



-- 
Matt Painter
m...@deity.co.nz
+64 21 115 9378
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

