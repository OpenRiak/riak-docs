---
title: "Re: aggregate query"
description: ""
project: community
lastmod: 2013-11-11T08:11:11-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg12932"
mailinglist_parent_id: "msg12931"
author_name: "Ron Pastore"
project_section: "mailinglistitem"
sent_date: 2013-11-11T08:11:11-08:00
---


Thanks Mark. Yeah I like the idea of operating locally and ensuring
everything before i remove the key.

My fears with data loss mainly pertain to mid-operation failures and them
leading to a discrepancy between my encrypted values and whatever secondary
method i have of storing their usages. So yeah, i guess my issue is
somewhat the same regardless of the secondary storage method.

I think with link walking, as with the search index, it comes down to the
need to transactionally manage the updating of the secondary place where
key usages are stored, with the primary being on the value itself (inside
meta). Essentially, i'd have to manually handle rollback procedures for
cases like when an item is stored but key usage storing (search or
linkwalk/bucket ) fails. This get tricky because what if part of the
rollback then fails, without persisting some sort of transaction log (may
be fine if that's the only way) it's hard to guarantee my secondary store
isn't missing something at the time i go to discard a key.





On Mon, Nov 11, 2013 at 10:20 AM, Mark A. Basil, Jr.
wrote:

&gt; Operate on the data locally, validating the decryption process as a final
&gt; step after the re-encrypted value is put back into the db.
&gt;
&gt;
&gt;
&gt; Also, you don’t have to do it all in one step. Pull a list of keys down,
&gt; break them up, and test your batch job on a small portion. If you’re
&gt; concerned with data loss, ensure you haven’t lost any before you delete the
&gt; updated value locally.
&gt;
&gt;
&gt;
&gt; The most efficient way to have set up your map would be a bucket to map
&gt; the keyname to the thing it’s encrypted.
&gt;
&gt; Alternatively, you could have added a keys bucket that uses Links which
&gt; would relate the key name to the thing that was encrypted by it.
&gt;
&gt;
&gt;
&gt; Lastly, it seems strange that your concerns with data loss are related to
&gt; how you’ll be pulling the list of keys which need updated. They really
&gt; shouldn’t be related.
&gt;
&gt;
&gt;
&gt; -m
&gt;
&gt;
&gt;
&gt;
&gt;
&gt;
&gt;
&gt; \*From:\* riak-users [mailto:riak-users-boun...@lists.basho.com] \*On Behalf
&gt; Of \*Ron Pastore
&gt; \*Sent:\* Monday, November 11, 2013 9:42 AM
&gt; \*To:\* riak-users@lists.basho.com
&gt; \*Subject:\* aggregate query
&gt;
&gt;
&gt;
&gt; Hi All,
&gt;
&gt; I posted this question to Stack Overflow a few days back but not much
&gt; luck. Hoping someone here has some thoughts.
&gt;
&gt; I have a use case for an aggregate query across the entire db and all
&gt; buckets, I'm wondering the best query method to use, leaning towards
&gt; multiple secondary index calls. This won't be a frequently used feature,
&gt; possibly invoked once a week or so via scheduled job or something.
&gt;
&gt; Some records have a value in their meta attribute that I'd like to
&gt; match/target for the selection. After the selection I'll need to update
&gt; those records.
&gt;
&gt; From what I've read, secondary index looks great but it is limited to a
&gt; single bucket? I also saw "list buckets", which has warnings about
&gt; production use, though not sure if that's applicable to such infrequently
&gt; used functionality. Thought maybe i could list buckets then perform the
&gt; secondary index query on each.
&gt;
&gt; Is there a better way? MapReduce seems heavy, having to load every KV off
&gt; the file system. Search seem possible too but index setup/maintenance seems
&gt; overkill if there's an easier way.
&gt;
&gt; UPDATE: i went ahead with a Search index but am now second guessing that.
&gt; This lookup will be part of an encryption key rotation, where we'll be
&gt; finding certain values from Riak that are encrypted with a given key then
&gt; re-encrypting with a new key. So, if there are discrepancies or failed
&gt; operations between the actual encrypted values and the search index, there
&gt; is a potential for data loss, as we'll be discarding keys once rotated.
&gt;
&gt;
&gt;
&gt; Sorry for the long winded description. Any help would be greatly
&gt; appreciated.
&gt;
&gt;
&gt;
&gt;
&gt;
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

