---
title: "Re: Riak pre-commit hook crashing unexpectedly"
description: ""
project: community
lastmod: 2015-12-07T07:47:52-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg16848"
mailinglist_parent_id: "msg16846"
author_name: "Jon Meredith"
project_section: "mailinglistitem"
sent_date: 2015-12-07T07:47:52-08:00
---


Does your signed\_pb:decode\_sign(Msg) function expect the binary to be in
external term format? I would guess you probably want the direct value
there without the term to binary - it should already be a binary.

Is your hook expected to work with allow\_mult=true, if so the get\_metadata
and get\_value calls could get badmatch errors if called with siblings.

Jon

On Mon, Dec 7, 2015 at 1:52 AM David Rogers 
wrote:

&gt; Hello,
&gt;
&gt; I'm using riak {release,"riak","2.1.0","5.10.3",
&gt; [{kernel,"2.16.3",
&gt; "$HOME/src/riak-2.1.1/rel/riak/lib/kernel-2.16.3"} ...}
&gt; on a cluster with 1 Linux 3.16.0-38 and 4 OSX machines.
&gt;
&gt; I have installed the following pre-commit hook (see end of email) to
&gt; validate protobuf-formatted values whose key should be the sha1-hash of
&gt; part of their payload.
&gt;
&gt; props =
&gt;
&gt; {"props":{"allow\_mult":false,"basic\_quorum":false,"big\_vclock":50,"chash\_keyfun":{"mod":"riak\_core\_util","fun":"chash\_std\_keyfun"},"dvv\_enabled":false,"dw":"quorum","last\_write\_wins":false,"linkfun":{"mod":"riak\_kv\_wm\_link\_walker","fun":"mapreduce\_linkfun"},"n\_val":3,"name":"sil/code","notfound\_ok":true,"old\_vclock":86400,"postcommit":[],"pr":0,"precommit":[{"mod":"validate\_hash","fun":"validate"}],"pw":0,"r":"quorum","rw":"quorum","small\_vclock":50,"w":"quorum","write\_once":false,"young\_vclock":20}})
&gt;
&gt; I attached the failed data element. I'm using the riak-c-client to
&gt; interface.
&gt;
&gt; Although almost everything I've added to the bucket this way has
&gt; worked so far, a few (like the sample I sent) fail, with riak\_put
&gt; returning only the unhelpful ERIAK\_SERVER\_ERROR ("An error was returned
&gt; from the server"). This happens even though manually running the
&gt; validation works fine. It is consistently reproducible on this input.
&gt;
&gt; In my attempt to track down the error, I added a test at the end of
&gt; riak\_sync\_request (below) that will log all server errors. The only
&gt; problem is that cfg-&gt;log\_fn is always NULL when riak\_log\_error is
&gt; called, rather than what I set it to initially with
&gt; riak\_config\_set\_logging! Gdb can't seem to catch any writes there, so
&gt; maybe cfg gets incompletely copied somewhere?
&gt;
&gt; Anyway, I can get out the error message from the debugger.
&gt;
&gt; riak\_sync\_request (rop\_target=rop\_target@entry=0x7fffffffe0b0,
&gt; response=response@entry=0x7fffffffe130)
&gt; at src/riak.c:81
&gt; 81 riak\_log\_error(cxn, "%.\*s\n", (int)msg-&gt;len, msg-&gt;data);
&gt; (gdb) print msg-&gt;data
&gt; $13 = (riak\_uint8\_t \*) 0x670a40
&gt; "{precommit\_fail,{hook\_crashed,{validate\_hash,validate,error,badarg}}}"
&gt;
&gt; so the server error shows only that the precommit hook
&gt; (validate\_hash:validate/1) crashes. Again, manually running doesn't
&gt; crash it...
&gt;
&gt; Questions:
&gt;
&gt; First, I don't understand why riak-c-client doesn't call the function
&gt; I supplied to riak\_config\_set\_logging. Second, I don't know where to
&gt; look for more details on why the pre-commit hook crashes only when I
&gt; actually try to add this particular key/value. Can anyone spot a problem
&gt; in its error handling or suggest a way to debug?
&gt;
&gt; Note: I get slightly more info. when posting from curl,
&gt; $ curl -XPOST
&gt; http://127.0.0.1:8098/types/default/buckets/sil%2Fcode/keys/$hash -H
&gt; 'Content-Type: application/octet-stream' --data-binary @"$hash"
&gt; 500 Internal Server
&gt; ErrorInternal Server Error
=====================

The server
&gt; encountered an error while processing this request:  

```
{error,
&gt;      {error,badarg,
&gt;          [{erlang,iolist_to_binary,
&gt;               [{hook_crashed,{validate_hash,validate,error,badarg}}],
&gt;               []},
&gt; {wrq,append_to_response_body,2,[{file,"src/wrq.erl"},{line,215}]},
&gt;           {riak_kv_wm_object,handle_common_error,3,
&gt;               [{file,"src/riak_kv_wm_object.erl"},{line,1178}]},
&gt;           {webmachine_resource,resource_call,3,
&gt;               [{file,"src/webmachine_resource.erl"},{line,186}]},
&gt;           {webmachine_resource,do,3,
&gt;               [{file,"src/webmachine_resource.erl"},{line,142}]},
&gt;           {webmachine_decision_core,resource_call,1,
&gt;               [{file,"src/webmachine_decision_core.erl"},{line,48}]},
&gt;           {webmachine_decision_core,decision,1,
&gt; [{file,"src/webmachine_decision_core.erl"},{line,490}]},
&gt;           {webmachine_decision_core,handle_request,2,
&gt;
&gt; [{file,"src/webmachine_decision_core.erl"},{line,33}]}]}}
```


---

mochiweb+webmachine
&gt; web server


&gt;
&gt; Sincerely,
&gt; ~ David M. Rogers
&gt;
&gt; signed.proto:
&gt; ```
&gt; message sign {
&gt; required bytes signer = 1;
&gt; required uint32 dig\_alg = 2;
&gt; required bytes sign = 3;
&gt; required uint64 ctime = 4;
&gt; optional uint32 flags = 5;
&gt;
&gt; optional bytes obj = 10;
&gt; }
&gt; ```
&gt;
&gt;
&gt; validate\_hash.erl:
&gt; ```
&gt; -module(validate\_hash).
&gt; -export([validate/1, ck\_hash/2, start/0]).
&gt; %-on\_load(load\_proto/0).
&gt;
&gt; -author("David M. Rogers ").
&gt;
&gt; %load\_proto() -&gt;
&gt; % protobuffs\_compile:scan\_file("signed.proto").
&gt;
&gt; validate(Object) -&gt;
&gt; try
&gt; dict:is\_key(&lt;&lt;"X-Riak-Deleted"&gt;&gt;, riak\_object:get\_metadata(Object)) of
&gt; true -&gt; Object;
&gt; false -&gt; correct\_hash(Object)
&gt; catch
&gt; error:Error -&gt;
&gt; {fail, "Invalid Commit: " ++
&gt; binary\_to\_list(list\_to\_binary(io\_lib:format("~p", [Error])))}
&gt; end.
&gt;
&gt; correct\_hash(Object) -&gt;
&gt; Msg = term\_to\_binary(riak\_object:get\_value(Object)),
&gt; Hash = binary\_to\_list(riak\_object:key(Object)),
&gt; case ck\_hash(Hash, Msg) of
&gt; true -&gt; Object;
&gt; false -&gt; {fail, "Invalid Commit: Bad hash value."}
&gt; end.
&gt;
&gt; %% Hash : string of 40 hex chars
&gt; %% Msg : protocol buffer sign message (signed.proto)
&gt; %% returns bool
&gt; ck\_hash(Hash, Msg) -&gt;
&gt; Obj = signed\_pb:decode\_sign(Msg), %% signed and sobject come from
&gt; file naming
&gt; Digest = crypto:hash(sha, element(7,Obj)),
&gt; bin\_to\_hexstr(Digest) == Hash
&gt; .
&gt;
&gt; bin\_to\_hexstr(Bin) -&gt;
&gt; lists:flatten([io\_lib:format("~2.16.0b", [X]) ||
&gt; X &lt;- binary\_to\_list(Bin)]).
&gt;
&gt; hexstr\_to\_bin(S) -&gt;
&gt; hexstr\_to\_bin(S, []).
&gt; hexstr\_to\_bin([], Acc) -&gt;
&gt; list\_to\_binary(lists:reverse(Acc));
&gt; hexstr\_to\_bin([X,Y|T], Acc) -&gt;
&gt; {ok, [V], []} = io\_lib:fread("~16u", [X,Y]),
&gt; hexstr\_to\_bin(T, [V | Acc]).
&gt;
&gt; start() -&gt;
&gt; Hash = "fc144f6728c994a10309a922d0fd9758b9999cc4",
&gt; {ok, Msg} = file:read\_file(Hash),
&gt; Ret = ck\_hash(Hash, Msg),
&gt; io:fwrite( "Returned: ~p.~n", [Ret] ).
&gt; ```
&gt;
&gt;
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

