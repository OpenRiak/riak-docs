---
title: "Re: May allow_mult cause DoS?"
description: ""
project: community
lastmod: 2013-12-19T06:22:47-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg13298"
mailinglist_parent_id: "msg13297"
author_name: "Andy Gross"
project_section: "mailinglistitem"
sent_date: 2013-12-19T06:22:47-08:00
---



I’d wait for strong consistency in Riak 2.0 or try another solution. Your 
requirements probably need to be rethought if you intend to use any database on 
the AP side of the spectrum.

- Andy

—
Andy Gross 
Chief Architect
Basho Technologies, Inc.



On Dec 18, 2013, at 9:18 PM, Viable Nisei  wrote:

&gt; Hi
&gt; 
&gt; On Thu, Dec 19, 2013 at 3:07 AM, Rune Skou Larsen  wrote:
&gt; Save the transaction list inside the customer object keyed by customerid. 
&gt; Index this object with 2i on storeids for each contained tx.
&gt; 
&gt; Not so good idea. Transactions may be running in parallel, but there is no 
&gt; atomic operations in Riak, or lock managers or UPDATE operation knowing about 
&gt; blob structure. Risk of race condition is not so high but it exists.
&gt; 
&gt; If some customer objects grow too big, you can move old txs into archive 
&gt; objects keyed by customerid\_seqno. For your low latency customer reads, you 
&gt; probably only need the newest txs anyway.
&gt; 
&gt; Yeah, we've considered approaches similar to this, but rejected this due to 
&gt; race conditions. Also we've considered some kind of DLM (like ZooKeeper), but 
&gt; if we need DLM, we'll just use hadoop/cassandra/hbase...
&gt; 
&gt; That's just one idea. Trifork will be happy to help you find a suitable model 
&gt; for your use cases.
&gt; 
&gt; Ok, but such idea doesn't look as something mind-blowing...we have considered 
&gt; this idea and many other approaches. Also what may be anwser for 
&gt; STORE-TRANSACTION binding? Just mapred?..
&gt; 
&gt; We usually do this by stress-testing a simulation with realistic data 
&gt; sizes/shapes and access patterns.
&gt; Same for us. We using tsung (scripts are generated, tsung is slightly 
&gt; automated with some pieces of erlang code) and some custom multithreaded 
&gt; scenarios like I've mentioned in op-message.
&gt; 
&gt; It's fastest if we come onsite for a couple of days and work with you to set 
&gt; it up, but we can also help you offsite.
&gt; 
&gt; Write me if you're interested, then we can do a call.
&gt; I'm interested, but for now it looks like that there is no prefect solution 
&gt; (the only untested approach left is custom indexing on riak side), so I don't 
&gt; really sure if we should pay to just confirm that there is no real solution...
&gt; 
&gt; 
&gt; On Thu, Dec 19, 2013 at 3:07 AM, Rune Skou Larsen  wrote:
&gt; Save the transaction list inside the customer object keyed by customerid. 
&gt; Index this object with 2i on storeids for each contained tx.
&gt; 
&gt; If some customer objects grow too big, you can move old txs into archive 
&gt; objects keyed by customerid\_seqno. For your low latency customer reads, you 
&gt; probably only need the newest txs anyway.
&gt; 
&gt; That's just one idea. Trifork will be happy to help you find a suitable model 
&gt; for your use cases.
&gt; 
&gt; We usually do this by stress-testing a simulation with realistic data 
&gt; sizes/shapes and access patterns. It's fastest if we come onsite for a couple 
&gt; of days and work with you to set it up, but we can also help you offsite.
&gt; 
&gt; Write me if you're interested, then we can do a call.
&gt; 
&gt; Rune Skou Larsen
&gt; Trifork, Denmark
&gt; 
&gt; 
&gt; ----- Reply message -----
&gt; Fra: "Viable Nisei" 
&gt; Til: "riak-users@lists.basho.com" 
&gt; Emne: May allow\_mult cause DoS?
&gt; Dato: ons., dec. 18, 2013 20:13
&gt; 
&gt; 
&gt; 
&gt; 
&gt; 
&gt; ---------- Forwarded message ----------
&gt; From: Viable Nisei &gt;
&gt; Date: Thu, Dec 19, 2013 at 2:11 AM
&gt; Subject: Re: May allow\_mult cause DoS?
&gt; To: Russell Brown &gt;
&gt; 
&gt; 
&gt; Hi.
&gt; 
&gt; Thank you for your descriptive and so informative answer very much.
&gt; 
&gt; On Wed, Dec 18, 2013 at 3:29 PM, Russell Brown 
&gt; &gt; wrote:
&gt; Hi,
&gt; 
&gt; Can you describe your use case a little? Maybe it would be easier for us to 
&gt; help.
&gt; Yeah, let me describe some abstract case equivalent to our. Let we have 
&gt; CUSTOMER object, STORE object and TRANSACTION object, each TRANSACTION has 
&gt; one tribool attribute STATE={ACTIVE, COMPLETED, ROLLED\_BACK}.
&gt; 
&gt; We should be able to list all the TRANSACTIONs of given CUSTOMER, for example 
&gt; (so we should establish 1-many relation, this list should not be long, 
&gt; 10^2-10^3 records, but we should be able to obtain this list fast enough). 
&gt; Also we should be able to list all the TRANSACTIONs of given STATE made in 
&gt; given STORE (lists may be very long, up to 10^8 records), but these list may 
&gt; be computed with some latency. Predictable latency is surely preferred but is 
&gt; not show-stopper. So, that's all.
&gt; 
&gt; Another pain is races and/or operations atomicity, but it's not so important 
&gt; at current time.
&gt; 
&gt; 
&gt; On 18 Dec 2013, at 04:32, Viable Nisei 
&gt; &gt; wrote:
&gt; 
&gt; &gt; On Wed, Dec 18, 2013 at 8:32 AM, Erik Søe Sørensen 
&gt; &gt; &gt; wrote:
&gt; &gt; It really is not a good idea to use siblings to represent 1-to-many 
&gt; &gt; relations. That's not what it's intended for, nor what it's optimized for...
&gt; &gt; Ok, understood.
&gt; &gt;
&gt; &gt; Can you tell us exactly why you need Bitcask rather than LevelDB? 2i would 
&gt; &gt; probably do it.
&gt; &gt; 1) According to 
&gt; &gt; http://docs.basho.com/riak/latest/ops/running/backups/#LevelDB-Backups , 
&gt; &gt; it's real pain to implement backups with leveldb.
&gt; &gt; 2) According to 
&gt; &gt; http://docs.basho.com/riak/latest/ops/advanced/backends/leveldb/ , reads 
&gt; &gt; may be slower comparing to bitcask, it's critical for us
&gt; &gt;
&gt; &gt; Otherwise, storing a list of items under each key could be a solution, 
&gt; &gt; depending of course on the number of items per key. (But do perform 
&gt; &gt; conflict resolution.)
&gt; &gt; Why any conflict resolving is required? As far as I understood, with 
&gt; &gt; allow\_mult=true riak should just collect all the values written to key 
&gt; &gt; without anything additional work? What design decision leads to exponential 
&gt; &gt; slowdown and crashes when multiple values allowed for any single key?.. So, 
&gt; &gt; what's the REAL purpose of allow\_mult=true if it's bad idea to use it for 
&gt; &gt; unlimited values per single key?
&gt; 
&gt; The real purpose of allow\_mult=true is so that writes are never dropped. In 
&gt; the case where your application concurrently writes to the same key on two 
&gt; different nodes, or on two partitioned nodes, Riak keeps both values. Other 
&gt; data stores will lose one of the writes based on timestamp, serialise your 
&gt; writes (slow) or simply refuse to accept one or more of them.
&gt; Ok, but documentation doesn't make points really clear.
&gt; 
&gt; 
&gt; It is the job of the client to aggregate those multiple writes into a single 
&gt; value when it detects the conflict on read. Conflict resolution is required 
&gt; because your data is opaque to Riak. Riak doesn’t know that you’re storing 
&gt; lists of values, or JPEGs or JSON. It can’t possibly know how to resolve two 
&gt; conflicting values unless it knows the semantics of the values. Riak \_does\_ 
&gt; collect all the values written to a key, but it does so as a temporary 
&gt; measure, it expects your application to resolve them to a single value. How 
&gt; many are you writing per Key?
&gt; As I said before, we need really many values in our 1-many sets - up to 10^8
&gt; Also why not to implement separate bucket mode allowing just to collect all 
&gt; the values writing? Anyway, current allow\_mult implementation looks like very 
&gt; dangerous. Also documentation should be more clear - in "sibling explosion" 
&gt; paragraph some statement should be added pointing that this relates to 
&gt; allow\_mult=true too.
&gt; 
&gt; 
&gt; Riak’s sweetspot is highly write available applications. If you have the time 
&gt; read the Amazon Dynamo paper[1], as it explains the \_problems\_ Riak solves as 
&gt; well as the way in which it solves them. If you don’t have these problems, 
&gt; maybe Riak is not the right datastore for you. Solving these problems comes 
&gt; with some developer complexity costs. You’ve run into one of them. We have 
&gt; many customers who think the trade-off is worth it: that the high 
&gt; availability and low-latency makes up for having eventual consistency.
&gt; 
&gt; Yeah, ok, but what riak&lt;2.0 really allows? FTS looks unscalable (am I right? 
&gt; is any way to speed-up it available?), list of all bucket keys is not for 
&gt; production, 2i is not implemented for bitcask (anyway, we'll try them on 
&gt; leveldb), links "implemented as hacks in java driver". So, riak&lt;2.0 with 
&gt; bitcask is only good distributed 1-1 hashmap with mapred support.
&gt; 
&gt; &gt;
&gt; &gt; Ok, documentation contains the following paragraph:
&gt; &gt;
&gt; &gt; &gt; Sibling explosion occurs when an object rapidly collects siblings without 
&gt; &gt; &gt; being reconciled. This can lead to a myriad of issues. Having an enormous 
&gt; &gt; &gt; object in your node can cause reads of that object to crash the entire 
&gt; &gt; &gt; node. Other issues are increased cluster latency as the object is 
&gt; &gt; &gt; replicated and out of memory errors.
&gt; &gt;
&gt; &gt; But there is no point if it related to allow\_mult=false or both cases.
&gt; 
&gt; Sorry, but I don’t understand what you mean by this statement. The point of 
&gt; allow\_mult=true is so that writes are not arbitrarily dropped. It allows Riak 
&gt; nodes to continue to be available to take writes even if they can’t 
&gt; communicate with each other. Have a look at Kyle Kingsbury’s Jepsen[2] post 
&gt; on Riak.
&gt; 
&gt; I'm just speaking about that this paragraph should contain something like 
&gt; "don't write multiple values into single key in bucket with allow\_mult=true, 
&gt; this will cause dramatic slowdowns/crashes". It's not really obvious that 
&gt; siblings explosion is related to bucket with allow\_mult=true.
&gt; 
&gt; &gt;
&gt; &gt; So, the only solution is leveldb+2i?
&gt; 
&gt; Maybe. Or maybe just use the client as it is intended to resolve sibling 
&gt; values and send that value and a vector clock back to Riak.
&gt; Not a solution for big sets of 10^8 elements
&gt; 
&gt; Or maybe roll your own indexes like in this blog post[3].
&gt; It's not an option to use some custom "indexes" on client side for long 
&gt; lists, so the only option is to write some erlang piece of code?..
&gt; 
&gt; With Riak 2.0 there are a few data types added to Riak that are not opaque. 
&gt; Maybe Riak’s Sets would suit your purpose (depending on the size of your Set.)
&gt; 
&gt; What are you meaning by "depending size of Set"?
&gt; Will I be able to store 10^8 values and enumerate/add new values fast enough?
&gt; 
&gt; You’re fighting the database at the moment, rather than working with it. The 
&gt; properties of Riak buy you some wonderful things (high availability, 
&gt; partition tolerance, low latency) but you have to want / need those 
&gt; properties, and then you have to accept that there is a data modelling / 
&gt; developer complexity price to pay. We don’t think that price is too high. We 
&gt; have many customers who agree. We’re always working to lower that price (see 
&gt; Strong Consistency, Yokozuna, Data Types etc in Riak 2.0[4].)
&gt; We've built 2.0 TP but it like to crash frequently and 2.0 driver still is 
&gt; not ready, but according to docs it looks like significantly better. But 
&gt; questions about maximum Set size and FTS scalability still looks actual.
&gt; 
&gt; 
&gt; You seem to have had a very negative first experience of Riak (and Basho.) I 
&gt; think that is because you misunderstand what it is for and how it should be 
&gt; used. I'm very keen to fix that. If it turns out that Riak is just not for 
&gt; you, that is fine too.
&gt; It's not negative experience, it's just WTFZOMG state. Everything looked good 
&gt; until loading/scalability tests...
&gt; 
&gt; 
&gt; In response to your earlier mail, I think Basho’s consulting costs sound 
&gt; incredibly low. I think you got that answer because you reached out to Basho 
&gt; through that channel, rather than ask the list. We’re still trying to track 
&gt; down who you spoke to and when, if you could provide me details of that 
&gt; conversation directly (rather than to the list) I’d be very grateful.
&gt; I think it's not really important for now, I think we've incorrectly 
&gt; emphasized our questions/thoughts.
&gt; Anyway for now looks like there is no silver bullet priced for $5k - all the 
&gt; possible approaches to solve our problem was already listed in this thread. 
&gt; And the only way I've missed in op message was custom indexing on server side 
&gt; (implemented as precommit hook, am I right? such as FTS?)
&gt; 
&gt; 
&gt; I’m not sure if it is just a cultural / language thing, but you’re very 
&gt; negative right now, and you sound like you're attacking Basho and Riak. I 
&gt; don’t think that is warranted at this point as we’re just trying to help you 
&gt; figure out if Riak is the datastore you want / need.
&gt; 
&gt; As I said before, I'm not negative. This picture http://tinyurl.com/p5zntks 
&gt; excellently describes thoughts of our dev team after set of loading tests. We 
&gt; got 100 writes/sec on single core i3 host. Ok, we got up to 500 writes (but 
&gt; we need 10k+) on single cc2.8xlarge host, but with 5 cc2.8xlarge nodes we got 
&gt; lesser with latency significantly increased. We changed our approach to using 
&gt; allow\_mult - and got only 100 for some first seconds, then exponentially 
&gt; dropping to zero, then total crash of all the cluster... Also you are right - 
&gt; english is not my native language. What about subject of our thread - take it 
&gt; like like some yellow press headline (but I still think that it's not so good 
&gt; idea to allow client code to do SUCH BAD THINGS WITH WHOLE CLUSTER)
&gt; 
&gt; Cheers
&gt; 
&gt; Russell
&gt; 
&gt; [1] http://dl.acm.org/citation.cfm?id=1294281
&gt; [2] http://aphyr.com/posts/285-call-me-maybe-riak
&gt; [3] http://basho.com/index-for-fun-and-for-profit/
&gt; [4] http://basho.com/technical-preview-of-riak-2-0/
&gt; 
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt; On Wed, Dec 18, 2013 at 8:32 AM, Erik Søe Sørensen 
&gt; &gt; &gt; wrote:
&gt; &gt; It really is not a good idea to use siblings to represent 1-to-many 
&gt; &gt; relations. That's not what it's intended for, nor what it's optimized for...
&gt; &gt; Can you tell us exactly why you need Bitcask rather than LevelDB? 2i would 
&gt; &gt; probably do it.
&gt; &gt; Otherwise, storing a list of items under each key could be a solution, 
&gt; &gt; depending of course on the number of items per key. (But do perform 
&gt; &gt; conflict resolution.)
&gt; &gt; /Erik
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt; -------- Oprindelig meddelelse --------
&gt; &gt; Fra: Viable Nisei &gt;
&gt; &gt; Dato:
&gt; &gt; Til: riak-users@lists.basho.com
&gt; &gt; Emne: May allow\_mult cause DoS?
&gt; &gt;
&gt; &gt;
&gt; &gt; Hi.
&gt; &gt;
&gt; &gt; Recently we've described that something is going unexpectedly. We are using 
&gt; &gt; Riak 1.4.2 with some buckets with allow\_mult=true.
&gt; &gt; We've tried our app under load then found that... concurrently writes into 
&gt; &gt; bucket with allow\_mult turning Riak into irresponsible slowpoke and even 
&gt; &gt; crash it.
&gt; &gt;
&gt; &gt; Core i3 with 4GB RAM performs only 20 writes/sec with 5 client threads 
&gt; &gt; writing 20 short strings into 20 keys in bucket with allow\_mult=true, 
&gt; &gt; search=false. With 40 values per 40 keys it performs only 6 writes/sec. 
&gt; &gt; 60x60 cause riak crash?
&gt; &gt; Throughput drops drastically. Ok, we've not chaged concurrency factor (5) 
&gt; &gt; and increased our data set 4x, but why throughput drops?
&gt; &gt; Ok, we increase our dataset linear, 20 strings \* 20 keys, 40 strings\*20 
&gt; &gt; keys, 60 strings\*20 keys... Results will be same - exponential throughput 
&gt; &gt; drop with crash at end.
&gt; &gt;
&gt; &gt; Cluster of five Amazon EC2 cc2.8xlarge nodes becomes irresponsibly with 
&gt; &gt; throughput 1-5 writes/sec with only 80-100 values per 1-10 keys.
&gt; &gt;
&gt; &gt; So, we think it is very strange.
&gt; &gt;
&gt; &gt; Here you can check our code sample (in java) reproducing this behavior: 
&gt; &gt; https://bitbucket.org/vsnisei/riak-allow\_mult\_wtf
&gt; &gt;
&gt; &gt; So, we have asked Basho about this, but they said that "we think SQLish" 
&gt; &gt; and asked us for $5k for 2-days consultation to resolve our problem.
&gt; &gt; So, I've decided to ask here if we are really so stupid and not able to 
&gt; &gt; understood some simple things or Basho didn't understood us correctly?..
&gt; &gt;
&gt; &gt; Anyway, looks like that some DoS/DDoS attack approach utilizing this 
&gt; &gt; behavior may be proposed. We should only know that some 
&gt; &gt; service/appliation/website is using Riak with allow\_mult buckets then 
&gt; &gt; provoke concurrent writes into them...
&gt; &gt;
&gt; &gt; Actually our question to Basho was broader. Our application needs to 
&gt; &gt; implement 1-many bindings. Riak allows the following approaches to 
&gt; &gt; simultate such bindings, according to documentation:
&gt; &gt;
&gt; &gt; 1. Riak search - but we've found that it's VERY slow (20x performance 
&gt; &gt; drop when search enabled, even for simple objects like {source\_id: xxx, 
&gt; &gt; target\_id: yyy}, also we've found that search is not really scalable - 
&gt; &gt; adding new nodes into cluster not increasing throughput, but even slows 
&gt; &gt; cluster down...
&gt; &gt; 2. secondary indexes. But, according to docs, they are working only on 
&gt; &gt; LevelDb, but we need Bitcask
&gt; &gt; 3. Link walking. But, according to docs, it's "rest only operation" and 
&gt; &gt; in java driver it's implemented as a hack
&gt; &gt; 4. allow\_mult. But we've found that it's just a nightmare. So we told 
&gt; &gt; Basho about this and given link to our example, but they didn't given us 
&gt; &gt; any feedback
&gt; &gt; 5. Bucket keys enumeration. But, according to docs, this operation causes 
&gt; &gt; full keys scan on each node and must not be used in production
&gt; &gt; 6. Mapred queries. Ok, we didn't tried them yet, maybe it's silver 
&gt; &gt; bullet, really. But according to docs (and common sense) mapred causes 
&gt; &gt; full-scan (for bucket at least. Or for all keys?) and it's operation with 
&gt; &gt; unpredictable latency.
&gt; &gt;
&gt; &gt; So, where we are wrong? Is everything ok with behavior I've described? Are 
&gt; &gt; we misunderstood Riak completely and should pay $5k for some 
&gt; &gt; mind-expansion, or there is no any hidden mystical knowledge and they will 
&gt; &gt; not say us anything excepting approaches listed above?
&gt; &gt;
&gt; &gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; &gt; riak-users mailing list
&gt; &gt; riak-users@lists.basho.com
&gt; &gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt; 
&gt; 
&gt; 
&gt; 
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

