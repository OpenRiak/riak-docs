---
title: "Re: Java client and siblings question"
description: ""
project: community
lastmod: 2013-05-20T10:36:25-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg11121"
mailinglist_parent_id: "msg11120"
author_name: "Brian Roach"
project_section: "mailinglistitem"
sent_date: 2013-05-20T10:36:25-07:00
---


If you're going to use the withoutFetch() method it is required that
you use that @RiakVClock annotated field in your class - you need to
store the vclock from when you fetched in that field.

When you call StoreObject.execute() it is extracted from your object
and passed to the Converter.fromDomain() method. Since you're using
your own Converter, in that method you need to store the vclock in the
IRiakObject you're constructing and returning. The RiakObjectBuilder
has a withVClock method (and of course the DefaultRiakObject
constructor takes it as a parameter).

As for your second question ... yeah, MapReduce doesn't have that.
It's probably something worth thinking about for a future release (and
yeah, I'm pretty much in charge of the Java client right now - I'll
add it to my backlog).

As-is the best suggestion I would have is using the
MapReduceResult.getResultRaw() and then pass that String to your own
code for conversion.

Thanks!
- Roach

(BTW - I apologize for the late reply - your original email was caught
up in our listserv server for some reason and I only received it
today).


On Mon, May 20, 2013 at 10:32 AM, Y N  wrote:
&gt; Hi Brian,
&gt;
&gt; Thanks for the response.
&gt;
&gt; I am not using the default JSONConverter, but have my own. The way I am
&gt; currently resolving siblings is as follows:
&gt;
&gt; Create a new object
&gt; Merge fields (using whatever logic)
&gt; Return new object with merged fields
&gt;
&gt; In this case, what should I use for the vclock for the newly created object
&gt; that was resolved? Do I randomly pick from one of the objects being
&gt; resolved, or is there some order or precedence I should use?
&gt;
&gt; On a side note, I am not sure if you are responsible for the Riak Java
&gt; client. If so, I don't see an option to allow me to use my own converter for
&gt; objects obtained via a MapReduce query (through the Java client). Is this
&gt; feature currently available, or is this something that will be added at some
&gt; point?
&gt;
&gt; A .withConverter(blah) would be nice for mapreduce queries as well.
&gt;
&gt; Thanks!
&gt;
&gt;
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; From: Brian Roach 
&gt; To: Y N 
&gt; Cc: "riak-users@lists.basho.com" 
&gt; Sent: Monday, May 20, 2013 7:42 AM
&gt; Subject: Re: Java client and siblings question
&gt;
&gt; Hello!
&gt;
&gt; When you do your fetch (read) and resolve any conflicts, you're going
&gt; to get a vector clock along with each sibling. If you're using the
&gt; default JSONConverter it will be stored in your POJO's @RiakVClock
&gt; annotated field. That's the vector clock you're going to use when you
&gt; do your store (write) later - the modified object you're passing to
&gt; Bucket.store() should contain it.
&gt;
&gt; The withoutFetch() option simply allows you to break this into two
&gt; separate actions. Without it, when you called StoreObject.execute()
&gt; that's exactly what would be happening.
&gt;
&gt; Thanks!
&gt; - Roach
&gt;
&gt; On Sat, Apr 27, 2013 at 5:35 PM, Y N  wrote:
&gt;&gt; Hi,
&gt;&gt;
&gt;&gt; I am currently using the latest java client, and I have a question
&gt;&gt; regarding
&gt;&gt; updating data in a bucket where siblings are allowed (i.e. allowSiblings =
&gt;&gt; true).
&gt;&gt;
&gt;&gt; I finally understand the whole read-resolve-mutate-write cycle, and also
&gt;&gt; doing an update / store using previously fetched data (i.e. not in the
&gt;&gt; same
&gt;&gt; "transaction").
&gt;&gt;
&gt;&gt; This question is regarding the latter case (updating previously fetched
&gt;&gt; data). My read uses a resolver. My data class has a @RiakVClock field
&gt;&gt; defined.
&gt;&gt;
&gt;&gt; The problem is when I do the store(blah).withoutFetch(). It seems to be
&gt;&gt; generating siblings. I just realized that's probably because my resolver
&gt;&gt; (during the read) is creating a new object and then merging then siblings
&gt;&gt; into the new object, however it's not setting the vclock field.
&gt;&gt;
&gt;&gt; My question is, during the read resolve stage, what should I use for the
&gt;&gt; vlock? Should I just copy it from one of the other siblings, or is there
&gt;&gt; some specific sort order I should use to pick a particular vlock for the
&gt;&gt; new
&gt;&gt; object?
&gt;&gt;
&gt;&gt; Thanks.
&gt;&gt;
&gt;&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;&gt;
&gt;
&gt;

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

