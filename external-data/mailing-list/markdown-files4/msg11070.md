---
title: "Re: On siblings"
description: ""
project: community
lastmod: 2013-05-14T22:49:29-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg11070"
mailinglist_parent_id: "msg11069"
author_name: "Jeremy Ong"
project_section: "mailinglistitem"
sent_date: 2013-05-14T22:49:29-07:00
---


To clarify, I am using the erlang client. From the looks of it, the vector
clock transition to the new value is opaque to the client so the only way
to streamline this use case is to pass the `return\_body` option (My use
case is one read, many subsequent writes while updating in memory).

In this case however, I already have the value in memory, so it seems
inefficient to have to get the entire riakc\_obj back when I really just
need the metadata to construct the new object. Is this correct?


On Tue, May 14, 2013 at 9:06 PM, Jeremy Ong  wrote:

&gt; Suppose I have an object X.
&gt;
&gt; I make an update to X and store it as X1. I perform a put operation using
&gt; X1.
&gt;
&gt; The same client then makes a modification to X1 and stores it as X2. Then,
&gt; I perform a put operation using X2.
&gt;
&gt; This will create two siblings X1 and X2 if allow\_mult is true. Is there
&gt; any way I can avoid this? To me, the vector clock should have incremented
&gt; once when transitioning from X to X1, then once more when transitioning
&gt; from X1 to X2. This way, I shouldn't need to issue a get before I have to
&gt; perform another write since my data is already in memory.
&gt;
&gt; I probably am misunderstanding something about vector clocks. Does anybody
&gt; care to clarify this?
&gt;
&gt; Thanks,
&gt; Jeremy
&gt;
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

