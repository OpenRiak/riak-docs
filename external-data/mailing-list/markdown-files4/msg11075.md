---
title: "Re: On siblings"
description: ""
project: community
lastmod: 2013-05-15T07:43:15-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg11075"
mailinglist_parent_id: "msg11074"
author_name: "Brian Roach"
project_section: "mailinglistitem"
sent_date: 2013-05-15T07:43:15-07:00
---


Jeremy -

As noted in the other replies, yes, you need to use 'return\_body' to
get the new vector clock in order to avoid creating a sibling on a
subsequent write of the same key.

That said, you can supply the param 'return\_head` in the proplist
along with `return\_body` which will eliminate having the value
returned to you and get the vclock you need.

- Roach

On Wed, May 15, 2013 at 8:23 AM, John Daily  wrote:
&gt; Thanks for the kind words, Jeremiah.
&gt;
&gt; Jeremy, if you find anything that's wrong with that description of sibling
&gt; behavior, please let me know. It's always possible I missed something
&gt; important.
&gt;
&gt; -John
&gt;
&gt;
&gt; On Wednesday, May 15, 2013, Jeremiah Peschka wrote:
&gt;&gt;
&gt;&gt; John Daily (@macintux) wrote a great blog post that covers sibling
&gt;&gt; behavior [1]
&gt;&gt;
&gt;&gt; In short, though, because you're supplying an older vector clock, and you
&gt;&gt; have allow\_mult turned on, Riak makes the decision that since a vector clock
&gt;&gt; is present that conflicts with what's already on disk a sibling should be
&gt;&gt; created.
&gt;&gt;
&gt;&gt; As I understand it, the only way to write into Riak and not get siblings
&gt;&gt; is to set allow\_mult to false - even leaving out vector clocks will lead to
&gt;&gt; siblings if allow\_mult is true. Or so John Daily's chart claims.
&gt;&gt;
&gt;&gt; [1]: http://basho.com/riaks-config-behaviors-part-2/
&gt;&gt;
&gt;&gt; ---
&gt;&gt; Jeremiah Peschka - Founder, Brent Ozar Unlimited
&gt;&gt; MCITP: SQL Server 2008, MVP
&gt;&gt; Cloudera Certified Developer for Apache Hadoop
&gt;&gt;
&gt;&gt;
&gt;&gt; On Tue, May 14, 2013 at 10:48 PM, Jeremy Ong 
&gt;&gt; wrote:
&gt;&gt;&gt;
&gt;&gt;&gt; To clarify, I am using the erlang client. From the looks of it, the
&gt;&gt;&gt; vector clock transition to the new value is opaque to the client so the only
&gt;&gt;&gt; way to streamline this use case is to pass the `return\_body` option (My use
&gt;&gt;&gt; case is one read, many subsequent writes while updating in memory).
&gt;&gt;&gt;
&gt;&gt;&gt; In this case however, I already have the value in memory, so it seems
&gt;&gt;&gt; inefficient to have to get the entire riakc\_obj back when I really just need
&gt;&gt;&gt; the metadata to construct the new object. Is this correct?
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; On Tue, May 14, 2013 at 9:06 PM, Jeremy Ong 
&gt;&gt;&gt; wrote:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Suppose I have an object X.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; I make an update to X and store it as X1. I perform a put operation
&gt;&gt;&gt;&gt; using X1.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; The same client then makes a modification to X1 and stores it as X2.
&gt;&gt;&gt;&gt; Then, I perform a put operation using X2.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; This will create two siblings X1 and X2 if allow\_mult is true. Is there
&gt;&gt;&gt;&gt; any way I can avoid this? To me, the vector clock should have incremented
&gt;&gt;&gt;&gt; once when transitioning from X to X1, then once more when transitioning 
&gt;&gt;&gt;&gt; from
&gt;&gt;&gt;&gt; X1 to X2. This way, I shouldn't need to issue a get before I have to 
&gt;&gt;&gt;&gt; perform
&gt;&gt;&gt;&gt; another write since my data is already in memory.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; I probably am misunderstanding something about vector clocks. Does
&gt;&gt;&gt;&gt; anybody care to clarify this?
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Thanks,
&gt;&gt;&gt;&gt; Jeremy
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt;&gt;&gt; riak-users mailing list
&gt;&gt;&gt; riak-users@lists.basho.com
&gt;&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;&gt;&gt;
&gt;&gt;
&gt;
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

