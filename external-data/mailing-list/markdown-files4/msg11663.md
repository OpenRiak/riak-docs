---
title: "Re: Dangling keys/objects after a batch of sequential inserts (for	going on 3 days)"
description: ""
project: community
lastmod: 2013-07-21T13:58:33-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg11663"
mailinglist_parent_id: "msg11659"
author_name: "Russell Brown"
project_section: "mailinglistitem"
sent_date: 2013-07-21T13:58:33-07:00
---



On 21 Jul 2013, at 14:20, Siraaj Khandkar  wrote:

&gt; On 07/21/2013 07:24 AM, Russell Brown wrote:&gt; Hi,
&gt; &gt;
&gt; &gt; On 21 Jul 2013, at 02:09, Siraaj Khandkar  wrote:
&gt; &gt;
&gt; &gt;&gt; I (sequentially) made 146204 inserts of unique objects to a single
&gt; &gt;&gt; bucket. Several secondary indices (most with unique values) were set
&gt; &gt;&gt; for each object, one of which was "bucket" = BucketName (to use 2i
&gt; &gt;&gt; for listing all keys).
&gt; &gt;
&gt; &gt; There is a special $bucket index for this already, please see the docs
&gt; &gt; here http://docs.basho.com/riak/latest/dev/using/2i/
&gt; &gt;
&gt; 
&gt; Yeah... I stumbled on that piece of info in another doc about two days
&gt; ago - made me feel both stupid and validated :)
&gt; 
&gt; However, it doesn't seem to work for me - I always get: {ok,{keys,[]}}

Curious. How do you make the 2i query to the $bucket index?

&gt; 
&gt; 
&gt; &gt;&gt;
&gt; &gt;&gt; 6 of the objects appear to have been lost - they're consistently not
&gt; &gt;&gt; found by GETs (by key) and are not found by 2i queries to the indices
&gt; &gt;&gt; with unique values.
&gt; &gt;
&gt; &gt; Oh. Erm. Have you deleted some keys? 2i is essentially an r=1 query.
&gt; &gt;
&gt; 
&gt; Sort-of. This was a second instance of this batch insertion (a slightly
&gt; extended set of keys), the first one was deleted ~6 hours prior to
&gt; executing the second one.
&gt; 
&gt; At the end of the deletion there \_were\_ some tombstones left. Frankly I
&gt; do not remember with certainty if there are overlaps between tombstones
&gt; from previous delete and the keys in question. In retrospect - it was
&gt; big failure on my part not to take note of those.
&gt; 
&gt; After the second instance of the set insertion - there were \_no\_
&gt; more deletions.
&gt; 
&gt; So, in summary:
&gt; 
&gt; 1) Inserted the set
&gt; 2) Deleted the set
&gt; 3) 6 hours passed
&gt; 4) Inserted the set
&gt; 5) Observed the problem

What is your delete\_mode setting, please 
(http://docs.basho.com/riak/latest/ops/advanced/configs/configuration-files/)?

Did the second insert do a fetch to get a tombstone vclock before trying to 
overwrite the key, or a PUT with an empty vclock?

&gt; 
&gt; 
&gt; &gt;&gt;
&gt; &gt;&gt; Now, I understand there may be a replication lag, but this state has
&gt; &gt;&gt; remained for over 3 days now.
&gt; &gt;&gt;
&gt; &gt;&gt; "What is fucked, and why?" :)
&gt; &gt;
&gt; &gt; Good question.
&gt; &gt;
&gt; 
&gt; I was hoping this list would appreciate the reference :)
&gt; 
&gt; 
&gt; &gt; Could you provide some more details to help me figure it out: How many
&gt; &gt; nodes are you running?
&gt; 
&gt; 5
&gt; 
&gt; 
&gt; &gt; Can you provide an example of the 2i queries you're running?
&gt; 
&gt; This is how I am testing it:
&gt; 
&gt; Compare = fun(PID, Bucket) -&gt;
&gt; B = Bucket,
&gt; L1 = riakc\_pb\_socket:get\_index(PID, B, {binary\_index, "bucket"}, B),
&gt; L2 = riakc\_pb\_socket:get\_index(PID, B, {binary\_index, "bucket"}, B),
&gt; io:format("L1: ~b, L2: ~b~n",[length(L1), length(L2)]),
&gt; Diff\_L1\_L2 = L1 -- L2,
&gt; Diff\_L2\_L1 = L2 -- L1,
&gt; io:format("=== L1 -- L2 ===~n~p~n~n", [Diff\_L1\_L2]),
&gt; io:format("=== L2 -- L1 ===~n~p~n~n", [Diff\_L2\_L1]),
&gt; Fetch = fun(Key) -&gt;
&gt; case riakc\_pb\_socket:get(PID, B, Key) of
&gt; {ok, \_} -&gt; io:format("FOUND: ~p~n", [Key]);
&gt; {error, \_} -&gt; io:format("NOT FOUND: ~p~n", [Key])
&gt; end
&gt; end,
&gt; io:format("=== L1 -- L2 ===~n"),
&gt; lists:foreach(Fetch, Diff\_L1\_L2),
&gt; io:format("=== L2 -- L1 ===~n"),
&gt; lists:foreach(Fetch, Diff\_L2\_L1)
&gt; end.
&gt; 
&gt; Which results in differences \_sometimes\_, but \_always\_ fails on get.
&gt; 
&gt; 
&gt; &gt; If this is just a dev cluster, can you verify the keys are present /
&gt; &gt; absent using either a range 2i $keys query, or a key list, please?
&gt; &gt;
&gt; 
&gt; Unfortunately this is prod, so brute-force key list is out of the
&gt; question.
&gt; 
&gt; Running:
&gt; curl "http://127.0.0.1:8098/buckets/$bucket/index/\$keys\_bin/0/z"
&gt; 
&gt; Returns:
&gt; {"keys":[]}
&gt; 


\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

