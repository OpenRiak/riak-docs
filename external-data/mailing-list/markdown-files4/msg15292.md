---
title: "Re: Using $bucket index in java client"
description: ""
project: community
lastmod: 2014-12-02T00:24:07-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg15292"
mailinglist_parent_id: "msg15290"
author_name: "Vassil Kolarov"
project_section: "mailinglistitem"
sent_date: 2014-12-02T00:24:07-08:00
---


I just changed the Init() constructor in BinIndexQuery to:

super(namespace, indexName, start, end);

and in the second constructor:
super(namespace, indexName, match);

Then in the SecondaryIndexQuery:

 public Init(Namespace namespace, String indexName, S match)
 {
 this.namespace = namespace;

 if(indexName.compareTo("$bucket")!=0){
 this.indexName = indexName + Type.\_BIN;
 }else{
 this.indexName = indexName;
 }
 this.match = match;
 }

in both constructors - Init(Namespace namespace, String indexName, S match)
and
 Init(Namespace namespace, String indexName, S start, S end)

Works like a charm.

Best regards,
Vasco

On Tue, Dec 2, 2014 at 5:50 AM, niedomnie  wrote:

&gt; there is a bug in BinIndexQuery - I've overriden some classes and now it is
&gt; working (with orginal sources of client). Use MyBinIndexQuery instead of
&gt; BinIndexQuery. Problem is that \_BIN in always apppended to name of index.
&gt;
&gt; import com.basho.riak.client.api.commands.CoreFutureAdapter
&gt; import com.basho.riak.client.api.commands.indexes.BinIndexQuery
&gt; import com.basho.riak.client.api.commands.indexes.SecondaryIndexQuery
&gt; import com.basho.riak.client.core.RiakCluster
&gt; import com.basho.riak.client.core.RiakFuture
&gt; import com.basho.riak.client.core.operations.SecondaryIndexQueryOperation
&gt; import com.basho.riak.client.core.query.Location
&gt; import com.basho.riak.client.core.query.Namespace
&gt; import com.basho.riak.client.core.util.BinaryValue
&gt;
&gt; import java.nio.charset.Charset
&gt;
&gt; abstract class MyInit&gt; extends
&gt; SecondaryIndexQuery.Init
&gt; {
&gt; Charset charset = Charset.defaultCharset();
&gt;
&gt; public MyInit(Namespace namespace, String indexName, S start, S end)
&gt; {
&gt; // super(namespace, indexName + SecondaryIndexQuery.Type.\_BIN,
&gt; start,
&gt; end);
&gt; super(namespace, indexName, start, end);
&gt; }
&gt;
&gt; public MyInit(Namespace namespace, String indexName, S match)
&gt; {
&gt; // super(namespace, indexName + SecondaryIndexQuery.Type.\_BIN,
&gt; match);
&gt; super(namespace, indexName, match);
&gt; }
&gt;
&gt; T withCharacterSet(Charset charset)
&gt; {
&gt; this.charset = charset;
&gt; return self();
&gt; }
&gt; }
&gt;
&gt; public class MyBuilder extends MyInit
&gt; {
&gt; public MyBuilder(Namespace namespace, String indexName, String start,
&gt; String end)
&gt; {
&gt; super(namespace, indexName, start, end);
&gt; }
&gt;
&gt; public MyBuilder(Namespace namespace, String indexName, String match)
&gt; {
&gt; super(namespace, indexName, match);
&gt; }
&gt;
&gt; @Override
&gt; protected MyBuilder self()
&gt; {
&gt; return this;
&gt; }
&gt;
&gt; public MyBinIndexQuery build()
&gt; {
&gt; return new MyBinIndexQuery(this);
&gt; }
&gt; }
&gt;
&gt; public class MyBinIndexQuery extends SecondaryIndexQuery BinIndexQuery.Response, BinIndexQuery&gt;
&gt; {
&gt; private final Charset charset;
&gt; private final SecondaryIndexQuery.IndexConverter converter;
&gt;
&gt; public MyBinIndexQuery(MyInit builder)
&gt; {
&gt; super(builder);
&gt; this.charset = builder.charset;
&gt; this.converter = new SecondaryIndexQuery.IndexConverter()
&gt; {
&gt; @Override
&gt; public String convert(BinaryValue input)
&gt; {
&gt; return input.toString(charset);
&gt; }
&gt;
&gt; @Override
&gt; public BinaryValue convert(String input)
&gt; {
&gt; return BinaryValue.create(input, charset);
&gt; }
&gt; };
&gt; }
&gt;
&gt; @Override
&gt; protected SecondaryIndexQuery.IndexConverter getConverter()
&gt; {
&gt; return converter;
&gt; }
&gt;
&gt; @Override
&gt; protected RiakFuture
&gt; executeAsync(RiakCluster cluster)
&gt; {
&gt; RiakFuture SecondaryIndexQueryOperation.Query&gt; coreFuture =
&gt; executeCoreAsync(cluster);
&gt;
&gt; BinQueryFuture future = new BinQueryFuture(coreFuture);
&gt; coreFuture.addListener(future);
&gt; return future;
&gt; }
&gt;
&gt; protected final class BinQueryFuture extends
&gt; CoreFutureAdapter SecondaryIndexQueryOperation.Response, SecondaryIndexQueryOperation.Query&gt;
&gt; {
&gt; public
&gt; BinQueryFuture(RiakFuture SecondaryIndexQueryOperation.Query&gt; coreFuture)
&gt; {
&gt; super(coreFuture);
&gt; }
&gt;
&gt; @Override
&gt; protected MyResponse
&gt; convertResponse(SecondaryIndexQueryOperation.Response coreResponse)
&gt; {
&gt; return new MyResponse(namespace, coreResponse, converter);
&gt; }
&gt;
&gt; @Override
&gt; protected MyBinIndexQuery
&gt; convertQueryInfo(SecondaryIndexQueryOperation.Query coreQueryInfo)
&gt; {
&gt; return MyBinIndexQuery.this;
&gt; }
&gt; }
&gt;
&gt; protected static abstract class Init&gt; extends
&gt; SecondaryIndexQuery.Init
&gt; {
&gt; private Charset charset = Charset.defaultCharset();
&gt;
&gt; public Init(Namespace namespace, String indexName, S start, S end)
&gt; {
&gt; super(namespace, indexName + Type.\_BIN, start, end);
&gt; }
&gt;
&gt; public Init(Namespace namespace, String indexName, S match)
&gt; {
&gt; super(namespace, indexName + Type.\_BIN, match);
&gt; }
&gt;
&gt; T withCharacterSet(Charset charset)
&gt; {
&gt; this.charset = charset;
&gt; return self();
&gt; }
&gt;
&gt; }
&gt;
&gt; /\*\*
&gt; \* Builder used to construct a BinIndexQuery.
&gt; \*/
&gt; public static class Builder extends Init
&gt; {
&gt;
&gt; /\*\*
&gt; \* Construct a Builder for a BinIndexQuery with a range.
&gt; \* 
&gt; \* Note that your index name should not include the Riak {@literal
&gt; \_int} or
&gt; \* {@literal \_bin} extension.
&gt; \* 
&gt; \* @param namespace The namespace in Riak to query.
&gt; \* @param indexName The index name in Riak to query.
&gt; \* @param start The start of the 2i range.
&gt; \* @param end The end of the 2i range.
&gt; \*/
&gt; public Builder(Namespace namespace, String indexName, String start,
&gt; String end)
&gt; {
&gt; super(namespace, indexName, start, end);
&gt; }
&gt;
&gt; /\*\*
&gt; \* Construct a Builder for a BinIndexQuery with a single 2i key.
&gt; \* 
&gt; \* Note that your index name should not include the Riak {@literal
&gt; \_int} or
&gt; \* {@literal \_bin} extension.
&gt; \* 
&gt; \* @param namespace The namespace in Riak to query.
&gt; \* @param indexName The name of the index in Riak.
&gt; \* @param match the 2i key.
&gt; \*/
&gt; public Builder(Namespace namespace, String indexName, String match)
&gt; {
&gt; super(namespace, indexName, match);
&gt; }
&gt;
&gt; @Override
&gt; protected Builder self()
&gt; {
&gt; return this;
&gt; }
&gt;
&gt; /\*\*
&gt; \* Construct the query.
&gt; \* @return a new BinIndexQuery
&gt; \*/
&gt; public MyBinIndexQuery build()
&gt; {
&gt; return new MyBinIndexQuery(this);
&gt; }
&gt;
&gt; }
&gt;
&gt; public static class MyResponse extends
&gt; SecondaryIndexQuery.Response
&gt; {
&gt; final SecondaryIndexQueryOperation.Response coreResponseCopy;
&gt; final SecondaryIndexQuery.IndexConverter converterCopy;
&gt;
&gt; protected MyResponse(Namespace queryLocation,
&gt; SecondaryIndexQueryOperation.Response coreResponse,
&gt; SecondaryIndexQuery.IndexConverter converter)
&gt; {
&gt; super(queryLocation, coreResponse, converter);
&gt; this.coreResponseCopy = coreResponse
&gt; this.converterCopy = converter
&gt; }
&gt;
&gt; @Override
&gt; public List getEntries()
&gt; {
&gt; List convertedList = new ArrayList();
&gt; for (SecondaryIndexQueryOperation.Response.Entry e :
&gt; coreResponseCopy.getEntryList())
&gt; {
&gt; Location loc = getLocationFromCoreEntry(e);
&gt; MyEntry ce = new MyEntry(loc, e.getIndexKey(),
&gt; converterCopy);
&gt; convertedList.add(ce);
&gt; }
&gt; return convertedList;
&gt; }
&gt;
&gt; public class MyEntry extends
&gt; SecondaryIndexQuery.Response.Entry
&gt; {
&gt; protected MyEntry(Location riakObjectLocation, BinaryValue
&gt; indexKey, SecondaryIndexQuery.IndexConverter converter)
&gt; {
&gt; super(riakObjectLocation, indexKey, converter);
&gt; }
&gt;
&gt; }
&gt; }
&gt; }
&gt;
&gt;
&gt;
&gt; --
&gt; View this message in context:
&gt; http://riak-users.197444.n3.nabble.com/Using-bucket-index-in-java-client-tp4032125p4032199.html
&gt; Sent from the Riak Users mailing list archive at Nabble.com.
&gt;
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com









