---
title: "Re: Riak CS 1.3 S3 access does not seem to mark s3 deleted file as	truly deleted"
description: ""
project: community
lastmod: 2013-05-21T16:28:23-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg11146"
mailinglist_parent_id: "msg11143"
author_name: "Kelly McLaughlin"
project_section: "mailinglistitem"
sent_date: 2013-05-21T16:28:23-07:00
---


Idan,

Bitcask can sometimes be slow to reclaim space after deleting objects from
Riak CS. Are the settings you included the settings that have been in place
during all of your uploads and deletions? I am surprised that just a few
tens of uploads of 32 MB objects used up 15 GB of space. Can you be more
specific on a count of uploads? Also do you have any error output in the
riak or riak cs log files that may be related? Finally, which packages are
you using for your testing?

Kelly


On Tue, May 21, 2013 at 2:18 PM, Idan Shinberg wrote:

&gt; Thus , I fear Riak never treats their data as "dead-bytes" and they never
&gt; get merged
&gt;
&gt; I created 2 buckets using s3cmd and made several tens of uploads of 32mb
&gt; sized files , deleting them right afterwards ( with proper s3cmd commands ,
&gt; of course) .
&gt;
&gt; I ended up with no buckets and no keys in my riak s3 database ,
&gt; however , directory /var/lib/riak/bitcask/ 64 partitions now occupy 15GB
&gt; worth of space
&gt;
&gt; several riak restarts did not trigger any merges , and my merge settings
&gt; are set to impose very though merge triggering criterias , So I'm guessing
&gt; the only reason the data is not being cleared is the fact that it's still
&gt; in use ...
&gt;
&gt; Relevant riak-cs config :
&gt;
&gt; \* %% == Garbage Collection ==\*
&gt; \*
&gt; \*
&gt; \* %% The number of seconds to retain the block\*
&gt; \* %% for an object after it has been deleted.\*
&gt; \* %% This leeway time is set to give the delete\*
&gt; \* %% indication time to propogate to all replicas.\*
&gt; \* %% 86400 is 24-hours.\*
&gt; \* {leeway\_seconds, 30},\*
&gt; \*
&gt; \*
&gt; \* %% How often the garbage collection daemon\*
&gt; \* %% waits in-between gc batches.\*
&gt; \* %% 900 is 15-minutes.\*
&gt; \* {gc\_interval, 60},\*
&gt; \*
&gt; \*
&gt; \* %% How long a move to the garbage\*
&gt; \* %% collection to do list can remain\*
&gt; \* %% failed, before we retry it.\*
&gt; \* %% 21600 is 6-hours.\*
&gt; \* {gc\_retry\_interval,300},\*
&gt;
&gt;
&gt;
&gt; Relevant Riak Config
&gt;
&gt; \*{riak\_kv, [\*
&gt; \* %% Storage\_backend specifies the Erlang module defining the
&gt; storage\*
&gt; \* %% mechanism that will be used on this node.\*
&gt; \* {add\_paths,
&gt; ["/usr/lib64/riak-cs/lib/riak\_cs-1.3.1/ebin"]},\*
&gt; \* {storage\_backend, riak\_cs\_kv\_multi\_backend},\*
&gt; \* {multi\_backend\_prefix\_list, [{&lt;&lt;"0b:"&gt;&gt;, be\_blocks}]},\*
&gt; \* {multi\_backend\_default, be\_default},\*
&gt; \* {multi\_backend, [\*
&gt; \* {be\_default, riak\_kv\_eleveldb\_backend, [\*
&gt; \* {max\_open\_files, 50},\*
&gt; \* {data\_root, "/var/lib/riak/leveldb"}\*
&gt; \* ]},\*
&gt; \* {be\_blocks, riak\_kv\_bitcask\_backend, [\*
&gt; \*
&gt; \*
&gt; \* {max\_file\_size, 16#4000000}, %% 64MB\*
&gt; \*
&gt; \*
&gt; \* %% Trigger a merge if any of the following are
&gt; true:\*
&gt; \* {frag\_merge\_trigger, 10}, %% fragmentation &gt;= 10%
&gt; \*
&gt; \* {dead\_bytes\_merge\_trigger, 33554432}, %% dead
&gt; bytes &gt; 32 MB\*
&gt; \*
&gt; \*
&gt; \* %% Conditions that determine if a file will be
&gt; examined during a merge:\*
&gt; \* {frag\_threshold, 5}, %% fragmentation &gt;= 5%\*
&gt; \* {dead\_bytes\_threshold, 8388608}, %% dead bytes &gt;
&gt; 8 MB\*
&gt; \* {small\_file\_threshold, 16#80000000}, %% file is
&gt; &lt; 2GB\*
&gt; \*
&gt; \*
&gt; \* {data\_root, "/var/lib/riak/bitcask"}\*
&gt; \* ]}\*
&gt; \* ]},\*
&gt;
&gt; ...
&gt; ...
&gt; ...
&gt;
&gt; \* {bitcask, [\*
&gt; \* %% Configure how Bitcask writes data to disk.\*
&gt; \* %% erlang: Erlang's built-in file API\*
&gt; \* %% nif: Direct calls to the POSIX C API\*
&gt; \* %%\*
&gt; \* %% The NIF mode provides higher throughput for certain\*
&gt; \* %% workloads, but has the potential to negatively impact\*
&gt; \* %% the Erlang VM, leading to higher worst-case latencies\*
&gt; \* %% and possible throughput collapse.\*
&gt; \* {io\_mode, erlang},\*
&gt; \*
&gt; \*
&gt; \* {max\_file\_size, 16#4000000}, %% 64MB\*
&gt; \* {merge\_window, always}, %% Span of hours during which merge
&gt; is acceptable.\*
&gt; \*
&gt; \*
&gt; \* %% Trigger a merge if any of the following are true:\*
&gt; \* {frag\_merge\_trigger, 10}, %% fragmentation &gt;= 10%\*
&gt; \* {dead\_bytes\_merge\_trigger, 33554432}, %% dead bytes &gt; 32 MB\*
&gt; \*
&gt; \*
&gt; \* %% Conditions that determine if a file will be examined
&gt; during a merge:\*
&gt; \* {frag\_threshold, 5}, %% fragmentation &gt;= 5%\*
&gt; \* {dead\_bytes\_threshold, 8388608}, %% dead bytes &gt; 8 MB\*
&gt; \* {small\_file\_threshold, 16#80000000}, %% file is &lt; 2GB\*
&gt; \*
&gt; \*
&gt; \* {data\_root, "/var/lib/riak/bitcask"}\*
&gt; \*
&gt; \*
&gt; \* ]},\*
&gt;
&gt; I do see merges taking place in riak's console.log , they're just not
&gt; making that much of a difference ...
&gt;
&gt; Any idea what I might be missing here ?
&gt;
&gt; Thanks
&gt;
&gt; Idan Shinberg
&gt; idomoo
&gt;
&gt;
&gt;
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;
&gt;
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

