---
title: "Re: Differences between riak_client and riak_kv_mrc_pipe MapReduce	when one node is down."
description: ""
project: community
lastmod: 2013-01-30T13:59:43-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg09927"
mailinglist_parent_id: "msg09920"
author_name: "John Daily"
project_section: "mailinglistitem"
sent_date: 2013-01-30T13:59:43-08:00
---


Riak's MapReduce functionality cannot survive a node failure. If a vnode 
involved with a query fails while actively processing the request, the entire 
query will have to be re-run. The failed query should be automatically 
terminated, but you'll have to re-run the query yourself.

If you create queries using Riak Pipe (the technology layer beneath MapReduce), 
it is possible to create queries that can survive a vnode failure, but that is 
not a trivial exercise.

Regarding the empty result set you're seeing: one possibility is that a vnode 
has failed recently and has come back online without data. MapReduce will not 
currently trigger a read repair, but that problem should be resolved with the 
forthcoming Riak 1.3 release.

-John Daily
Technical Evangelist
Basho

On Jan 30, 2013, at 8:05 AM, gu...@mail.mipt.ru wrote:

&gt; We have 6 node riak cluster.I simple custom erlang application for custom 
&gt; MapReduce job.
&gt; 
&gt; We start MapReduce job using riak\_kv\_mrc\_pipe pipe module,for example - 
&gt; 
&gt; Query = [{map, {modfun,Mod,MapFun},[do\_prereduce,{from,1}], false},{reduce, 
&gt; {modfun,Mod,ReduceFun},[{reduce\_phase\_batch\_size, 1000}], true}],
&gt; riak\_kv\_mrc\_pipe:mapred({index,Bucket,Field,From,To},Query,Timeout).
&gt; 
&gt; But if one of the node down for along time. Response is unpredictable 
&gt; sometimes it's return {ok,GoodResultList}, but sometimes {ok,[]}(empty list).
&gt; We trace riak\_kv and riak\_pipe and found too problem:
&gt; 1. In riak\_kv\_pipe\_index or in riak\_kv\_pipe\_liskeys created fitting\_spec this 
&gt; nval always is 1.
&gt; 2. Actual error is occurred in riak\_pipe\_vnode:remaining\_preflist that retun 
&gt; empty PrefList for some Hash(#fitting\_spec.nval is 1). It use 
&gt; riak\_core\_apl:get\_primary\_apl function.
&gt; 
&gt; But if we use old style map reduce,for example:
&gt; {ok,C} = riak:local\_client(),
&gt; Me = self(),
&gt; Query = [{map, {modfun,Mod,MapFun},[do\_prereduce,{from,1}], 
&gt; false},{reduce, {modfun,Mod,ReduceFun},[{reduce\_phase\_batch\_size, 1000}], 
&gt; true}],
&gt; {ok, {ReqId,FlowPid}} = C:mapred\_stream(Query,Me,Timeout),
&gt; 
&gt; {ok,\_}=riak\_kv\_index\_fsm\_sup:start\_index\_fsm(zont\_riak\_connection:riak\_node(),
&gt; [{raw, ReqId,FlowPid}, [Bucket, none,{range,Field,From,To},Timeout,mapred]]),
&gt; luke\_flow:collect\_output(ReqId, Timeout).
&gt; 
&gt; Query executed well. But problem is that do\_prereduce and 
&gt; {reduce\_phase\_batch\_size, 1000} is ignored,that why execution is slow.
&gt; 
&gt; 
&gt; Can you make some recommendation? May be riak\_pipe\_vnode:remaining\_preflist 
&gt; we need use riak\_core\_apl:get\_apl\_ann or set #fitting\_spec.nval to nval from 
&gt; out Bucket props?
&gt; 
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com


\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

