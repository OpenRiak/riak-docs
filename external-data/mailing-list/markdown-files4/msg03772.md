---
title: "Re: speeding up riaksearch precommit indexing"
description: ""
project: community
lastmod: 2011-06-22T00:34:39-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg03772"
mailinglist_parent_id: "msg03767"
author_name: "Mathias Meyer"
project_section: "mailinglistitem"
sent_date: 2011-06-22T00:34:39-07:00
---


Les,

maybe it's worth looking into Beetle [1] which is a HA messaging solution built 
on RabbitMQ and Redis. It supports multiple brokers and message de-duplication, 
using Redis. It's written in Ruby, but should either way give you some 
inspiration on how something like this could be achieved.

On a different note, you could draw some inspiration from existing 
implementations that build on top of Riak Core like riak\_zab [2] or riak\_id 
[3]. You'd benefit from everything Riak itself is built on and could fashion 
your own implementation on top of that, sort of faking a queue system and using 
Riak KV as a storage backend.

As a final thought, there's a plugin for RabbitMQ [4] to store message directly 
into Riak, again benefitting from the fault-tolerance of Riak, but basically 
baked right into your messaging system. You could run multiple Rabbits, all 
writing messages directly to Riak, and then resort to failover should one of 
the Rabbits go down.

Mathias Meyer
Developer Advocate, Basho Technologies

[1] http://xing.github.com/beetle/
[2] https://github.com/jtuple/riak\_zab
[3] https://github.com/seancribbs/riak\_id
[4] https://github.com/jbrisbin/riak-exchange


On Mittwoch, 22. Juni 2011 at 00:07, Les Mikesell wrote:

&gt; I'd like to have fully redundant feeds with no single point of failure, 
&gt; but avoid the work of indexing the duplicate copy and having it written 
&gt; to a bitcask even if it would eventually be cleaned up.
&gt; 
&gt; 
&gt; On 6/21/2011 4:43 PM, Sylvain Niles wrote:
&gt; &gt; Why not write to a queue bucket with a timestamp and have a queue
&gt; &gt; processor move writes to the "final" bucket once they're over a
&gt; &gt; certain age? It can dedup/validate at that point too.
&gt; &gt; 
&gt; &gt; 
&gt; &gt; On Tue, Jun 21, 2011 at 2:26 PM, Les Mikesell &gt; (mailto:lesmikes...@gmail.com)&gt; wrote:
&gt; &gt; &gt; Where can I find the redis hacks that get close to clustering? Would
&gt; &gt; &gt; membase work with syncronous replication on a pair of nodes for a reliable
&gt; &gt; &gt; atomic 'check and set' operation to dedup redundant data before writing to
&gt; &gt; &gt; riak? Conceptually I like the 'smart client' fault tolerance of
&gt; &gt; &gt; memcache/membase and restricting it to a pair of machines would keep the
&gt; &gt; &gt; client configuration reasonable.
&gt; &gt; &gt; 
&gt; &gt; &gt; -Les
&gt; &gt; &gt; 
&gt; &gt; &gt; 
&gt; &gt; &gt; On 6/18/2011 6:54 PM, John D. Rowell wrote:
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; The "real" queues like HornetQ and others can take care of this without
&gt; &gt; &gt; &gt; a single point of failure but it's a pain (in my opinion) to set them up
&gt; &gt; &gt; &gt; that way, and usually with all the cluster and failover features active
&gt; &gt; &gt; &gt; they get quite slow for writes.We use Redis for this because it's
&gt; &gt; &gt; &gt; simpler and lightweight. The problem is that there is no real clustering
&gt; &gt; &gt; &gt; option for Redis today, even thought there are some hacks that get
&gt; &gt; &gt; &gt; close. When we cannot afford a single point of failure or any downtime,
&gt; &gt; &gt; &gt; we tend to use MongoDB for simple queues. It has full cluster support
&gt; &gt; &gt; &gt; and the performance is pretty close to what you get with Redis in this
&gt; &gt; &gt; &gt; use case.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; OTOH you could keep it all Riak and setup a separate small cluster with
&gt; &gt; &gt; &gt; a RAM backend and use that as a queue, probably with similar
&gt; &gt; &gt; &gt; performance. The idea here is that you can scale these clusters (the
&gt; &gt; &gt; &gt; "queue" and the indexed production data) independently in response to
&gt; &gt; &gt; &gt; your load patterns, and have optimum hardware and I/O specs for the
&gt; &gt; &gt; &gt; different cluster nodes.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; -jd
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; 2011/6/18 Les Mikesell &gt; &gt; &gt; (mailto:lesmikes...@gmail.com)
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; Is there a good way to handle something like this with redundancy
&gt; &gt; &gt; &gt; all the way through? On simple key/value items you could have two
&gt; &gt; &gt; &gt; readers write the same things to riak and let bitcask cleanup
&gt; &gt; &gt; &gt; eventually discard one, but with indexing you probably need to use
&gt; &gt; &gt; &gt; some sort of failover approach up front. Do any of those queue
&gt; &gt; &gt; &gt; managers handle that without adding their own single point of
&gt; &gt; &gt; &gt; failure? Assuming there are unique identifiers in the items being
&gt; &gt; &gt; &gt; written, you might use the CAS feature of redis to arbitrate writes
&gt; &gt; &gt; &gt; into its queue, but what happens when the redis node fails?
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; -Les
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; On 6/17/11 11:48 PM, John D. Rowell wrote:
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; Why not decouple the twitter stream processing from the
&gt; &gt; &gt; &gt; indexing? More than
&gt; &gt; &gt; &gt; likely you have a single process consuming the spritzer stream,
&gt; &gt; &gt; &gt; so you can put
&gt; &gt; &gt; &gt; the fetched results in a queue (hornetq, beanstalk, or even a
&gt; &gt; &gt; &gt; simple Redis
&gt; &gt; &gt; &gt; queue) and then have workers pull from the queue and insert into
&gt; &gt; &gt; &gt; Riak. You could
&gt; &gt; &gt; &gt; run one worker per node and thus insert in parallel into all
&gt; &gt; &gt; &gt; nodes. If you need
&gt; &gt; &gt; &gt; free CPU (e.g. for searches), just throttle the workers to some
&gt; &gt; &gt; &gt; sane level. If
&gt; &gt; &gt; &gt; you see the queue getting bigger, add another Riak node (and
&gt; &gt; &gt; &gt; thus another local
&gt; &gt; &gt; &gt; worker).
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; -jd
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; 2011/6/13 Steve Webb
&gt; &gt; &gt; &gt; &gt;&gt;
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; Ok, I've changed my two VMs to each have:
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; 3 CPUs, 1GB ram, 120GB disk
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; I'm ingesting the twitter spritzer stream (about 10-20
&gt; &gt; &gt; &gt; tweets per second,
&gt; &gt; &gt; &gt; approx 2k of data per tweet). One bucket is storing the
&gt; &gt; &gt; &gt; non-indexed tweets
&gt; &gt; &gt; &gt; in full. Another bucket is storing the indexed tweet
&gt; &gt; &gt; &gt; string, id, date and
&gt; &gt; &gt; &gt; username. A maximum of 20 clients can be hitting the
&gt; &gt; &gt; &gt; 'cluster' at any one time.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; I'm using n\_val=2 so there is replication going on behind
&gt; &gt; &gt; &gt; the scenes.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; I'm using a hardware load-balancer to distribute the work
&gt; &gt; &gt; &gt; amongst the two
&gt; &gt; &gt; &gt; nodes and now I'm seeing about 75% CPU usage as opposed to
&gt; &gt; &gt; &gt; 100% on one node
&gt; &gt; &gt; &gt; and 50% on the replicating-only node.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; I've monitored the VM over the last few days and it seems to
&gt; &gt; &gt; &gt; be mostly
&gt; &gt; &gt; &gt; CPU-bound. The disk I/O is low. The Network I/O is low.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; Q: Can I change the pre-commit to a post-commit trigger or
&gt; &gt; &gt; &gt; something perhaps
&gt; &gt; &gt; &gt; or will that make any difference at all? I'm ok if the
&gt; &gt; &gt; &gt; tweet stuff doesn't
&gt; &gt; &gt; &gt; get indexed immediately and there's a slight lag in indexing
&gt; &gt; &gt; &gt; if it saves on CPU.
&gt; &gt; &gt; &gt; 


\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

