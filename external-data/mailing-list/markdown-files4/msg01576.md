---
title: "MapReduce filtering question"
description: ""
project: community
lastmod: 2010-11-19T11:16:06-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg01576"
author_name: "Parker Thompson"
project_section: "mailinglistitem"
sent_date: 2010-11-19T11:16:06-08:00
---


I'm experimenting with Riak by trying to port a simple a/b testing framework
that's currently SQL backed. Since I'm using Ripple/riak-client my code
below are in Ruby/JS.

The domain model is fairly simple. I have visitors, which get created for
any user who hits the site, visitors see alternatives (currently these are
ActiveRecord objects) and are tracked by creating experiences (the joining
of a alternative ID and a visitor). Finally, as visitors do things we track
events, which are distinguished from one another by their classes.

Here is a simplified version of the model code:

class Riak::Visitor
 include Ripple::Document
 many :events, :class\_name =&gt; "Riak::Event"
end

class Riak::Event
 include Ripple::Document
end

class Riak::ShareEvent &lt; Riak::Event
 include Ripple::Document
end

class Riak::Experience
 include Ripple::Document
 one :visitor, :class\_name =&gt; "Riak::Visitor"
 property :alternative\_id, Integer, :presence =&gt; true
end

My problem is that I'd like to collect the set of visitors who have shared,
or more generally I'd like to return a set of visitors after narrowing down
the list by linking in specific kind of events. Well, my real problem is
that I still don't quite grok MapReduce, but this is what I'm trying to
accomplish.

The riak-client code is included below (see visitors\_who\_shared). It returns
a list of all visitors found in the map phase where keep is true. This isn't
surprising, but I'm not sure how to get the visitors if I don't “keep” them
in that phase.

Thanks in advance for any help. I'm also happy RTFM and would appreciate
specific suggestions for doing nontrivial MR jobs in JavaScript.

class Riak::Alternative #not a riak doc
 attr\_accessor :ar\_id

 def initialize(ar\_id)
 self.ar\_id = ar\_id
 end

 def visitors\_who\_shared
 Riak::MapReduce.new(Ripple.client).
 add("riak\_experiences").
 map(map\_filter\_by\_alternative).
 link(:bucket =&gt; 'riak\_visitors', :keep =&gt; true).
 link(:bucket =&gt; 'riak\_events').
 map("function(v){ return [[v.bucket, v.key]]; }").
 map(map\_share\_events).
 run
 end

 def map\_share\_events
 f = &lt;&lt;FUNCTION
function(v){
 var data = JSON.parse(v.values[0].data);
 if(data.\_type != "Riak::ShareEvent" ){
 return [];
 }else{
 return [[v.bucket, v.key]];
 }
}
FUNCTION
 end

 def map\_filter\_by\_alternative
 f = &lt;&lt;FUNCTION
function(v){
 var data = JSON.parse(v.values[0].data);
 if(data.alternative\_id != #{self.ar\_id} ){
 return [];
 }else{
 return [[v.bucket, v.key]];
 }
}
FUNCTION
 end
end

Riak::Alternative.new(1).visitors\_who\_shared
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

