---
title: "Re: Riak pre-commit hook crashing unexpectedly"
description: ""
project: community
lastmod: 2015-12-30T09:07:47-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg16891"
mailinglist_parent_id: "msg16848"
author_name: "David Rogers"
project_section: "mailinglistitem"
sent_date: 2015-12-30T09:07:47-08:00
---


Your first suggestion solves the problem. signed\_pb:decode\_sign is 
auto-generated by erlang\_protobuffs, and I thought it wanted binary 
input. However, omitting term\_to\_binary fixed the error.


Thanks,
~ David.

On 12/7/15 10:44 AM, Jon Meredith wrote:
Does your signed\_pb:decode\_sign(Msg) function expect the binary to be 
in external term format? I would guess you probably want the direct 
value there without the term to binary - it should already be a binary.


Is your hook expected to work with allow\_mult=true, if so the 
get\_metadata and get\_value calls could get badmatch errors if called 
with siblings.


Jon

On Mon, Dec 7, 2015 at 1:52 AM David Rogers 
&gt; 
wrote:


 Hello,

 I'm using riak {release,"riak","2.1.0","5.10.3",
 [{kernel,"2.16.3",
 "$HOME/src/riak-2.1.1/rel/riak/lib/kernel-2.16.3"} ...}
 on a cluster with 1 Linux 3.16.0-38 and 4 OSX machines.

 I have installed the following pre-commit hook (see end of email) to
 validate protobuf-formatted values whose key should be the
 sha1-hash of
 part of their payload.

 props =
 
{"props":{"allow\_mult":false,"basic\_quorum":false,"big\_vclock":50,"chash\_keyfun":{"mod":"riak\_core\_util","fun":"chash\_std\_keyfun"},"dvv\_enabled":false,"dw":"quorum","last\_write\_wins":false,"linkfun":{"mod":"riak\_kv\_wm\_link\_walker","fun":"mapreduce\_linkfun"},"n\_val":3,"name":"sil/code","notfound\_ok":true,"old\_vclock":86400,"postcommit":[],"pr":0,"precommit":[{"mod":"validate\_hash","fun":"validate"}],"pw":0,"r":"quorum","rw":"quorum","small\_vclock":50,"w":"quorum","write\_once":false,"young\_vclock":20}})

 I attached the failed data element. I'm using the riak-c-client to
 interface.

 Although almost everything I've added to the bucket this way has
 worked so far, a few (like the sample I sent) fail, with riak\_put
 returning only the unhelpful ERIAK\_SERVER\_ERROR ("An error was
 returned
 from the server"). This happens even though manually running the
 validation works fine. It is consistently reproducible on this input.

 In my attempt to track down the error, I added a test at the end of
 riak\_sync\_request (below) that will log all server errors. The only
 problem is that cfg-&gt;log\_fn is always NULL when riak\_log\_error is
 called, rather than what I set it to initially with
 riak\_config\_set\_logging! Gdb can't seem to catch any writes there, so
 maybe cfg gets incompletely copied somewhere?

 Anyway, I can get out the error message from the debugger.

 riak\_sync\_request (rop\_target=rop\_target@entry=0x7fffffffe0b0,
 response=response@entry=0x7fffffffe130)
 at src/riak.c:81
 81 riak\_log\_error(cxn, "%.\*s\n", (int)msg-&gt;len, msg-&gt;data);
 (gdb) print msg-&gt;data
 $13 = (riak\_uint8\_t \*) 0x670a40
 "{precommit\_fail,{hook\_crashed,{validate\_hash,validate,error,badarg}}}"

 so the server error shows only that the precommit hook
 (validate\_hash:validate/1) crashes. Again, manually running doesn't
 crash it...

 Questions:

 First, I don't understand why riak-c-client doesn't call the
 function
 I supplied to riak\_config\_set\_logging. Second, I don't know where to
 look for more details on why the pre-commit hook crashes only when I
 actually try to add this particular key/value. Can anyone spot a
 problem
 in its error handling or suggest a way to debug?

 Note: I get slightly more info. when posting from curl,
 $ curl -XPOST
 http://127.0.0.1:8098/types/default/buckets/sil%2Fcode/keys/$hash -H
 'Content-Type: application/octet-stream' --data-binary @"$hash"
 500 Internal Server
 ErrorInternal Server Error
=====================

The server
 encountered an error while processing this request:  

```
{error,
         {error,badarg,
             [{erlang,iolist_to_binary,
    [{hook_crashed,{validate_hash,validate,error,badarg}}],
                  []},
    {wrq,append_to_response_body,2,[{file,"src/wrq.erl"},{line,215}]},
              {riak_kv_wm_object,handle_common_error,3,
    [{file,"src/riak_kv_wm_object.erl"},{line,1178}]},
              {webmachine_resource,resource_call,3,
    [{file,"src/webmachine_resource.erl"},{line,186}]},
              {webmachine_resource,do,3,
    [{file,"src/webmachine_resource.erl"},{line,142}]},
              {webmachine_decision_core,resource_call,1,
    [{file,"src/webmachine_decision_core.erl"},{line,48}]},
              {webmachine_decision_core,decision,1,
    [{file,"src/webmachine_decision_core.erl"},{line,490}]},
              {webmachine_decision_core,handle_request,2,
    
[{file,"src/webmachine_decision_core.erl"},{line,33}]}]}}
```


---

mochiweb+webmachine
 web server



 Sincerely,
 ~ David M. Rogers

 signed.proto:
 ```
 message sign {
 required bytes signer = 1;
 required uint32 dig\_alg = 2;
 required bytes sign = 3;
 required uint64 ctime = 4;
 optional uint32 flags = 5;

 optional bytes obj = 10;
 }
 ```


 validate\_hash.erl:
 ```
 -module(validate\_hash).
 -export([validate/1, ck\_hash/2, start/0]).
 %-on\_load(load\_proto/0).

 -author("David M. Rogers &gt;").

 %load\_proto() -&gt;
 % protobuffs\_compile:scan\_file("signed.proto").

 validate(Object) -&gt;
 try
 dict:is\_key(&lt;&lt;"X-Riak-Deleted"&gt;&gt;,
 riak\_object:get\_metadata(Object)) of
 true -&gt; Object;
 false -&gt; correct\_hash(Object)
 catch
 error:Error -&gt;
 {fail, "Invalid Commit: " ++
 binary\_to\_list(list\_to\_binary(io\_lib:format("~p", [Error])))}
 end.

 correct\_hash(Object) -&gt;
 Msg = term\_to\_binary(riak\_object:get\_value(Object)),
 Hash = binary\_to\_list(riak\_object:key(Object)),
 case ck\_hash(Hash, Msg) of
 true -&gt; Object;
 false -&gt; {fail, "Invalid Commit: Bad hash value."}
 end.

 %% Hash : string of 40 hex chars
 %% Msg : protocol buffer sign message (signed.proto)
 %% returns bool
 ck\_hash(Hash, Msg) -&gt;
 Obj = signed\_pb:decode\_sign(Msg), %% signed and sobject come from
 file naming
 Digest = crypto:hash(sha, element(7,Obj)),
 bin\_to\_hexstr(Digest) == Hash
 .

 bin\_to\_hexstr(Bin) -&gt;
 lists:flatten([io\_lib:format("~2.16.0b", [X]) ||
 X &lt;- binary\_to\_list(Bin)]).

 hexstr\_to\_bin(S) -&gt;
 hexstr\_to\_bin(S, []).
 hexstr\_to\_bin([], Acc) -&gt;
 list\_to\_binary(lists:reverse(Acc));
 hexstr\_to\_bin([X,Y|T], Acc) -&gt;
 {ok, [V], []} = io\_lib:fread("~16u", [X,Y]),
 hexstr\_to\_bin(T, [V | Acc]).

 start() -&gt;
 Hash = "fc144f6728c994a10309a922d0fd9758b9999cc4",
 {ok, Msg} = file:read\_file(Hash),
 Ret = ck\_hash(Hash, Msg),
 io:fwrite( "Returned: ~p.~n", [Ret] ).
 ```


 \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
 riak-users mailing list
 riak-users@lists.basho.com 
 http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com



\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

