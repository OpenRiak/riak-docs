---
title: "Re: Read Before Writes on Distributed Counters"
description: ""
project: community
lastmod: 2013-10-17T10:05:15-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg12672"
mailinglist_parent_id: "msg12661"
author_name: "Russell Brown"
project_section: "mailinglistitem"
sent_date: 2013-10-17T10:05:15-07:00
---



On 17 Oct 2013, at 17:21, Jeremiah Peschka  wrote:

&gt; When you 'update' a counter, you send in an increment operation. That's added 
&gt; to an internal list in Riak. The operations are then zipped up to provide the 
&gt; correct counter value on read. The worst that you'll do is add a large(ish) 
&gt; number of values to the op list inside Riak. 

Just to borrow some Cribbs-brand pedantry here:- That isn't true. We read the 
data from disk, increment an entry in what is essentially a version vector, and 
write it back, (then replicate the result to N-1 vnodes.) The size of the 
counter depends on the number of actors that have incremented it (typically N) 
not the number of operations.

&gt; 
&gt; Siblings will be created, but they will not be visible to the end user who is 
&gt; reading from the counter.

There won't be siblings on disk (we do create a temporary one in memory, does 
that count?) \_unless\_

1. you also write an object to that same key in a normal riak kv way (don't do 
that)
2. AAE or MDC cause a sibling to be created (this is because we use the 
operation of incrementing a counter to identify a key as counter, to the rest 
of riak it is just a riak object)

In that last case, an increment operation to the key will resolve the 
sibling(s).

Cheers

Russell

&gt; 
&gt; Check out this demo of the new counter types from Sean Cribbs: 
&gt; https://vimeo.com/43903960
&gt; 
&gt; ---
&gt; Jeremiah Peschka - Founder, Brent Ozar Unlimited
&gt; MCITP: SQL Server 2008, MVP
&gt; Cloudera Certified Developer for Apache Hadoop
&gt; 
&gt; 
&gt; On Thu, Oct 17, 2013 at 9:55 AM, Daniil Churikov  wrote:
&gt; Correct me if I wrong, but when you blindly do update without previous read,
&gt; you create a sibling, which should be resolved on read. In case if you make
&gt; a lot of increments for counter and rarely reads it will lead to siblings
&gt; explosion.
&gt; 
&gt; I am not familiar with new counters datatypes, so I am curious.
&gt; 
&gt; 
&gt; 
&gt; --
&gt; View this message in context: 
&gt; http://riak-users.197444.n3.nabble.com/Read-Before-Writes-on-Distributed-Counters-tp4029492p4029498.html
&gt; Sent from the Riak Users mailing list archive at Nabble.com.
&gt; 
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt; 
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com


\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

