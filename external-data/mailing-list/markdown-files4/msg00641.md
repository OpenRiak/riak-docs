---
title: "Re: riak_multi_backend and bitcask"
description: ""
project: community
lastmod: 2010-06-23T11:17:36-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg00641"
mailinglist_parent_id: "msg00640"
author_name: "Dan Reverri"
project_section: "mailinglistitem"
sent_date: 2010-06-23T11:17:36-07:00
---


Hi Tamas,

You can find the public bug tracker here:
https://issues.basho.com/

Regarding using Bitcask with multiple backends, the only issue I've seen is
trying to setup multiple bitcask backends. Bitcask defines options using the
"bitcask" application specification which is globally set for the node; this
prevents multiple instances of the bitcask backend from running on a single
node:
https://issues.basho.com/show\_bug.cgi?id=210

You should be able to run a bitcask backend along side other backend types
such as dets.

I did not completely follow your description; what issues did you see after
setting bitcask as a backend in the multibackend options? Were keys not
stored? Did you see errors in the log files? Did you try to setup multiple
bitcask backends?

Thanks,
Dan

Daniel Reverri
Developer Advocate
Basho Technologies, Inc.
d...@basho.com


On Wed, Jun 23, 2010 at 1:45 PM, Tamas Nagy  wrote:

&gt; Hi,
&gt;
&gt; I'm pretty new to the list (and riak) so please forgive my ignorance but I
&gt; didn't manage to find a public bugtracker for riak. Hence I'm posting my
&gt; problem here. (Bitbucket and Internet Explorer(using it not by choice) do
&gt; not mix well. So that might be the problem why I didn't find it).
&gt;
&gt; I've tried to use riak\_kv\_multi\_backend with one of the backends being the
&gt; riak\_kv\_bitcask\_backend. This does not seem to work with riak-0.11.0. I
&gt; checked tip as well, and I do not think it would work either. The problem
&gt; boils to these few lines (code snippets from tip):
&gt;
&gt; riak\_kv\_vnode:
&gt;
&gt; handle\_info({Mod, Msg}, StateName, #state { mod = Mod } = StateData) -&gt;
&gt; Mod:handle\_info(StateData#state.modstate, Msg),
&gt; {next\_state, StateName, StateData, ?TIMEOUT}.
&gt;
&gt; riak\_kv\_bitcask\_backend:
&gt;
&gt; start(Partition, \_Config) -&gt;
&gt; %% Schedule sync (if necessary)
&gt; case application:get\_env(bitcask, sync\_strategy) of
&gt; {ok, {seconds, Seconds}} -&gt;
&gt; SyncIntervalMs = timer:seconds(Seconds),
&gt; erlang:send\_after(SyncIntervalMs, self(),
&gt; {?MODULE, {sync, SyncIntervalMs}});
&gt; \_ -&gt; ok end,
&gt; %% Schedule merge checks
&gt; erlang:send\_after(?MERGE\_CHECK\_INTERVAL, self(), {?MODULE,
&gt; merge\_check}),
&gt;
&gt;
&gt; riak\_kv\_multi\_backend:
&gt;
&gt; handle\_info(State, Msg) -&gt;
&gt; F = fun(\_Name, Module, SubState) -&gt;
&gt; Module:handle\_info(SubState, Msg)
&gt; end, [F(X) || X &lt;- State#state.backends],
&gt; ok.
&gt;
&gt; If riak\_kv\_multi\_backend is configured in riak\_kv\_vnode the state's mod is
&gt; riak\_kv\_multi\_backend but the messages scheduled in riak\_kv\_bitcask\_backend
&gt; are going to have riak\_kv\_bitcask\_backend as their Mod tag.
&gt;
&gt; With my limited understanding about the rest of the sytem it seems to me
&gt; that adding this case to riak\_kv\_vnode would fix the problem:
&gt; handle\_info({Mod, Msg}, StateName, #state { mod = riak\_kv\_multi\_backend } =
&gt; StateData) -&gt;
&gt; riak\_kv\_multi\_backend:handle\_info(StateData#state.modstate, Msg),
&gt; {next\_state, StateName, StateData, ?TIMEOUT};
&gt;
&gt; It is a bit wasteful because all the configured backends will get called
&gt; with this message, but it is the best I can think of without leaking too
&gt; much information about the specific backends into the generic code.
&gt;
&gt; Modifying the handle\_info case would work as well however one check would
&gt; need to disappear:
&gt;
&gt; handle\_info({\_ModTag, Msg}, StateName, #state { mod = Mod } = StateData) -&gt;
&gt; Mod:handle\_info(StateData#state.modstate, Msg),
&gt; {next\_state, StateName, StateData, ?TIMEOUT}.
&gt;
&gt; There are a plethora of other ways to fix this like passing the Mod tag to
&gt; riak\_kv\_multi\_backend so that it can filter based on it (this is probably my
&gt; favourite as it is not wasteful and there aren't many code changes needed
&gt; either):
&gt; riak\_kv\_vnode:
&gt; handle\_info({Mod, Msg}, StateName, #state { mod = riak\_kv\_multi\_backend } =
&gt; StateData) -&gt;
&gt; riak\_kv\_multi\_backend:handle\_info(StateData#state.modstate, {Mod, Msg}),
&gt; {next\_state, StateName, StateData, ?TIMEOUT};
&gt;
&gt; riak\_kv\_multi\_backend:
&gt; handle\_info(State, {Mod, Msg}) -&gt;
&gt; F = fun(\_Name, Module, SubState) -&gt;
&gt; Module:handle\_info(SubState, Msg)
&gt; end, [F(X) || X = {\_, Module, \_} &lt;- State#state.backends, Module
&gt; =:= Mod],
&gt; ok.
&gt;
&gt; Code is not tested, but should compile. :)
&gt;
&gt; Regards,
&gt; Tamas
&gt;
&gt; --
&gt; Tamas Nagy
&gt; Erlang Solutions Ltd.
&gt; http://www.erlang-solutions.com
&gt; ---------------------------------------------------
&gt;
&gt; ---------------------------------------------------
&gt;
&gt; WE'VE CHANGED NAMES!
&gt;
&gt; Since January 1st 2010 Erlang Training and Consulting Ltd. has become
&gt; ERLANG SOLUTIONS LTD.
&gt;
&gt; www.erlang-solutions.com
&gt;
&gt;
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

