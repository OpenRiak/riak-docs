---
title: "Re: Security risk of clients having access to vector clocks"
description: ""
project: community
lastmod: 2013-01-18T06:41:21-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg09837"
mailinglist_parent_id: "msg09834"
author_name: "Jon Meredith"
project_section: "mailinglistitem"
sent_date: 2013-01-18T06:41:21-08:00
---


There is no equivalent of an SQL injection attack on the vector clock. 

If the client is able to tamper with it the only three issues I can think of are

1) deliberately corrupting it so that the put operation crashes which would end 
up with a timeout. If the application required the store and did not check 
before continuing it could be a problem. 

2) a more sophisticated version would replace the vector clock with one that 
was considered an ancestor which would generate a sibling if allow mult is set 
yes. If you didn't resolve then you could make large objects. 

3) similarly you could add fake entires to the clock which would make more work 
for the resolution code and slow things down until the clock was truncated by 
riak. 

If successfully decoded the information contained is a list of tuples with an 8 
byte vnode id, and update count and a last update fine for the vnode. The 
only information leak I can see is an estimate of the number of updates. 

Jon

On Jan 17, 2013, at 7:29 PM, Gregory Haskins  wrote:

&gt; 
&gt; On Jan 17, 2013, at 9:06 PM, Brian Picciano  wrote:
&gt; 
&gt;&gt; Are there any ways we could combat this?
&gt; 
&gt; I can't comment on what might be at risk from a Riak perspective, but as a 
&gt; general comment you could combat client-side tampering using crypto (perhaps 
&gt; you have already considered this option, I am not sure). 
&gt; 
&gt; For instance, you could attach an HMAC to the vector clock before returning 
&gt; it client side as a token, and then validate the HMAC when the token is 
&gt; passed back to you in the future. This will add overhead for both generating 
&gt; and validating the token, but it could alleviate exposure against db 
&gt; tampering. (Note that an HMAC alone will not protect you from replay of a 
&gt; previously issued vclock+HMAC, however. For that you will need to be more 
&gt; clever). Generally, I prefer to handle this stuff server side attached to 
&gt; the session, which I know isn't "RESTful", but it is easier to solve the 
&gt; security problems this way.
&gt; 
&gt; Good luck!
&gt; -Greg
&gt; 
&gt; 
&gt; 
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

