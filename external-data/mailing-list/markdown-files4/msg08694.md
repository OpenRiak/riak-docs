---
title: "Re: data modeling question"
description: ""
project: community
lastmod: 2012-09-25T14:16:44-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg08694"
mailinglist_parent_id: "msg08662"
author_name: "Charlie Bowman"
project_section: "mailinglistitem"
sent_date: 2012-09-25T14:16:44-07:00
---


You actually hit on several nuances regarding the app that I left out of
the original email to keep things simple. I go a little deeper now, and I
have a question regarding the link walking

"should make PlayerMessage PlayerMessages"
 I agree, I was actually referencing my model name, which I always
singularize.

"It's going to be some work updating 1M+ PlayerMessages objects when a
"mass message" is sent."
 You can't actually "send" a message to 1M recipients. What I actually is
"send" the message to players who match certain criteria. When a player
logs in, I look to see if they match the criteria for an incoming message.
 If they do I add the message id to their "inbox". That way I'm never
actually iterating over 1M records to add the id. Very similar to your
idea actually

"If you need to read PlayerMessage and corresponding Messages in one go,
you can model the relation from PlayerMessage to Message with Riak Links,
and avoid a database roundtrip by using link walking."
 If I do this, would I need to keep a second array in the PlayerMessage
object to then also map which messages have been read? Would link walking
be much faster? Currently I would need to have a separate query to load
the message objects? Can I load 10 message objects in






On Mon, Sep 24, 2012 at 4:17 AM, Rune Skou Larsen  wrote:

&gt; Looks good! A couple of observations:
&gt;
&gt; The relation from PlayerMessage to Message introduces the possibility of
&gt; inconsistency by either dead references to Message or orphan Messages.
&gt; Thats managable - just an inconvinience.
&gt; If you need to read PlayerMessage and corresponding Messages in one go,
&gt; you can model the relation from PlayerMessage to Message with Riak Links,
&gt; and avoid a database roundtrip by using link walking.
&gt; The PlayerMessage object could also include refs for sent messages if you
&gt; need that.
&gt; You should probably rename "PlayerMessage" -&gt; "PlayerMessages", as it
&gt; contains an array of messages. Or just "Player".
&gt; It's going to be some work updating 1M+ PlayerMessages objects when a
&gt; "mass message" is sent. Consider modelling the mass messages differently,
&gt; with a recipient group or recipient filter. So when you search for a
&gt; recipient's messages, you look up separately if there are some mass
&gt; messages for him. You can still flag when a mass message has been read by a
&gt; player in his PlayerMessages object.
&gt;
&gt; Good luck with the game! Can I ask you, what game you're making?
&gt;
&gt; - Rune
&gt;
&gt; Trifork
&gt;
&gt; --
&gt;
&gt; Best regards / Venlig hilsen
&gt; \*Rune Skou Larsen\*
&gt; Trifork Public A/S / Team Riak
&gt; Margrethepladsen 4, 8000 Århus C, Denmark
&gt; Phone: +45 3160 2497 Skype: runeskoularsen twitter: @RuneSkouLarsen
&gt;
&gt;
&gt;
&gt; On 21-09-2012 23:37, Charlie Bowman wrote:
&gt;
&gt; +riak list
&gt;
&gt; My current plan is to use something very similar to your second idea
&gt; (bulk messages in 1 object). Here's my current idea, I would love to hear
&gt; your opinion on this! Sometimes a message will be sent to over 1M
&gt; recipients, so I think I'll store the message contents in its own model.
&gt; My player objects are stored in a relational db, so I can use their id's
&gt; in my player\_message and deleted\_player\_message keys for easy lookup.
&gt;
&gt; Message (actually have 3 different message types, but they're all fairly
&gt; similar to this)
&gt; ---------
&gt; {
&gt; :subject =&gt; 'fdsa'
&gt; :body =&gt; 'fdsa'
&gt; :sent\_at =&gt; Time
&gt; }
&gt;
&gt; PlayerMessage (key will include the player id so I can look this model
&gt; up by player
&gt; --------------
&gt; array of:
&gt; {
&gt; :id =&gt; message\_id,
&gt; :type =&gt; message type
&gt; :read =&gt; boolean
&gt; }
&gt;
&gt;
&gt; DeletedPlayerMessage (key will include the player id so I can look this
&gt; model up by player)
&gt; --------------
&gt; array of:
&gt; {
&gt; :id =&gt; message\_id
&gt; :type =&gt; message\_type
&gt; }
&gt;
&gt; I'm definitely optimizing for the recipient, I want to be able to load
&gt; all or just unread messages as fast as possible. I will not need to look
&gt; up a message and see a list of all recipients.
&gt;
&gt;
&gt; My idea is that when I load the "inbox", I'll load the PlayerMessage
&gt; object for the given player, then separate the read from the unread emails
&gt; inside the application. From my quick testing, this works great with
&gt; relatively small numbers of messages. I'm capping the stored messages at
&gt; ~1000, and the process is nearly instantaneous. When a user deletes a
&gt; message, I copy the message hash from the PlayerMessage model to the
&gt; DeletedMesssage model for storage. There's a business requirement to store
&gt; all old emails.
&gt;
&gt; What do you think?
&gt;
&gt; On Fri, Sep 21, 2012 at 5:18 AM, Rune Skou Larsen  wrote:
&gt;
&gt;&gt; The best data model always depends on the structure of data and the
&gt;&gt; access pattern. The natural access pattern for your messages is likely
&gt;&gt; lookup from two sides: sender and receiver. And you might need to support
&gt;&gt; message expiry too. This means that you need on-disk indeces if you want
&gt;&gt; more messages than will fit in memory.
&gt;&gt;
&gt;&gt; In Riak you can do it quite simply with any of the ordered backends
&gt;&gt; (leveldb, hanoidb, lowkeydb):
&gt;&gt;
&gt;&gt; One message = one Riak object. Example: {sender='321', recipient='123',
&gt;&gt; timestamp = 1234567, text= 'bla bla'}
&gt;&gt; Key is timestamp prefixed.
&gt;&gt; 2i indeces for  and .
&gt;&gt; Consider using a compound index if you often distinguish between
&gt;&gt; read/unread messages. For instance: \_
&gt;&gt;
&gt;&gt; Example query returning keys for all unread messages belonging to
&gt;&gt; recipient with id 123 using compound index:
&gt;&gt; http://myhost:8098/buckets/messages/index/recipient\_bin/unread\_123
&gt;&gt;
&gt;&gt; Example query returning keys for all messages older than a year, so you
&gt;&gt; can delete old messages (not necesary using backends with autoexpiry):
&gt;&gt; http://myhost:8098/buckets/messages/index/$key/0/2011-09-21
&gt;&gt;
&gt;&gt;
&gt;&gt; Here is an alternative approach: You can choose to optimize for the
&gt;&gt; recipient side of the access pattern, by bulking all the messages for a
&gt;&gt; given recipient in one Riak object. This is much faster that retrieving a
&gt;&gt; large number of messages individually, the price being more difficult
&gt;&gt; lookup from the sender side:
&gt;&gt; Key: recipient\_id
&gt;&gt; One Riak Object = all messages for a given recipient. Example:
&gt;&gt; [{sender='321', timestamp = 1234567, text= 'bla bla'},{sender='456',
&gt;&gt; timestamp = 1234569, text= 'bla bla2'}]
&gt;&gt; 2i index for s
&gt;&gt;
&gt;&gt; Example query returning an object with all messages belonging to
&gt;&gt; recipient with id 123:
&gt;&gt; http://myhost:8098/buckets/messages/keys/123
&gt;&gt;
&gt;&gt; If you want text search on for instance message content, you should
&gt;&gt; consider using Riak Search.
&gt;&gt;
&gt;&gt; - Rune
&gt;&gt;
&gt;&gt; Trifork
&gt;&gt;
&gt;&gt;
&gt;&gt; Best regards / Venlig hilsen
&gt;&gt; \*Rune Skou Larsen\*
&gt;&gt; Trifork Public A/S / Team Riak
&gt;&gt; Margrethepladsen 4, 8000 Århus C, Denmark
&gt;&gt; Phone: +45 3160 2497 Skype: runeskoularsen twitter: @RuneSkouLarsen
&gt;&gt;
&gt;&gt;
&gt;&gt; On 20-09-2012 01:33, Charlie Bowman wrote:
&gt;&gt;
&gt;&gt; I'm in the process of designing an in game messaging system that
&gt;&gt; basically replicates the same functionality of email all within the context
&gt;&gt; of the application. I do not have a ton of experience with true key/value
&gt;&gt; db stores so I'm looking to find a good resource for ideas on how to best
&gt;&gt; model this. I have a first version, but I dont want to reinvent the wheel
&gt;&gt; if can help it. I've done the requisite googling, but haven't found
&gt;&gt; anything relevant yet. Are there any guides/tutorials/open source projects
&gt;&gt; that anyone knows of.
&gt;&gt;
&gt;&gt; Thanks!
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;&gt;
&gt;&gt;
&gt;
&gt;
&gt;
&gt;
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

