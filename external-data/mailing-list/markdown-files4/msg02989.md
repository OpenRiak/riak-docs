---
title: "Re: riakpool in production"
description: ""
project: community
lastmod: 2011-04-12T20:49:45-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg02989"
mailinglist_parent_id: "msg02993"
author_name: "David Weldon"
project_section: "mailinglistitem"
sent_date: 2011-04-12T20:49:45-07:00
---


Thanks for taking the time to review the code Ryan. All three of those
issues have been bothering me.

1) I haven't been very concerned about growing the pool in case of a
spike since client creation isn't particularly expensive... at least
my tests didn't indicate that was a cause for concern. The fact that
the pool never shrinks does bother me though. Since the connections
rotate in a circular buffer there is unlikely to be a case where they
just go unused. I think the only way to deal with the problem would be
some kind of heuristic, which implies application-specific knowledge.
I'm open to suggestions if someone has an elegant solution.

2) I can't let execute/1 throw an exception because then the check-in
won't happen. Maybe the code should do something like: catch error:E
-&gt; {error, E}. I'm cool with having the function return {ok, any()} |
{error, any()}.

3) I find this the most objectionable part of the app, but I don't
have a good answer. Because I have no idea what the user is going to
do with his/her Fun, I can't make any guarantees about the return
values without wrapping them. If someone can point out a flaw in this
logic I'm psyched to change the code.

Dave

On Tue, Apr 12, 2011 at 7:38 PM, Ryan Zezeski  wrote:
&gt; Dave,
&gt; First off, I want to say that I think it's awesome that you've started a
&gt; riakc pool implementation and shared it with everyone!  It's certainly a
&gt; missing piece and we could all benefit from having a canonical
&gt; implementation.  That said, I have a few comments:
&gt; 1) Growth of the pool: Since the pool has no ceiling things could get out of
&gt; control under the right conditions.  Just as important, I don't see any
&gt; functionality to shrink the pool when things are quiescent (default behavior
&gt; of riakc is to not timeout the conn).  Also, you may want to grow by more
&gt; than 1 to handle spikes better.
&gt; 2) Concealing errors:  I like how you made a HOF (execute) to deal with conn
&gt; checkin/checkout but I don't like how it covers up the cause of an error, I
&gt; would let it escape.  E.g. if someone fat fingers the module name they will
&gt; get 'error' back instead of the much more helpful 'undefined ...'.
&gt; 3) Wrapping the return value: You wrap the return val like `{ok,F(C)}`.  I'd
&gt; just return the value of F(C) so existing clients don't have to change their
&gt; patterns.  Plus `{ok,{ok,Obj}}` feels funny.
&gt; Anyways, these are just some thoughts after browsing the code a little.  I'm
&gt; no expert in building conn pools--not even a beginner for that matter.  I
&gt; think it's a good start and I hope you continue working on it and improving
&gt; it.  I may even send some pull requests your way in the future.
&gt; Please keep us updated on your use of Riak in production.  It's always nice
&gt; to hear :)
&gt; Thanks,
&gt; -Ryan
&gt; P.S.  I've been wanting to checkout mailrank's Haskell pool.  Those darn
&gt; Haskell folks always seem to build good stuff.

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

