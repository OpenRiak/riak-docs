---
title: "Re: oddness when using java client within storm"
description: ""
project: community
lastmod: 2014-04-14T08:52:15-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg14070"
mailinglist_parent_id: "msg14069"
author_name: "Sean Allen"
project_section: "mailinglistitem"
sent_date: 2014-04-14T08:52:15-07:00
---


We fire off 100 requests for the items in the batch and wait on the futures
to complete.


On Mon, Apr 14, 2014 at 11:40 AM, Alexander Sicular wrote:

&gt; I'm not sure what "looking up entries... in batches of 100 from Riak"
&gt; devolves into in the java client but riak doesn't have a native multiget.
&gt; It either does 100 get ops or a [search&gt;]mapreduce. That might inform some
&gt; of your performance issues.
&gt;
&gt; -Alexander
&gt;
&gt; @siculars
&gt; http://siculars.posthaven.com
&gt;
&gt; Sent from my iRotaryPhone
&gt;
&gt; &gt; On Apr 14, 2014, at 8:26, Sean Allen 
&gt; wrote:
&gt; &gt;
&gt; &gt; I'm seeing something very odd trying to scale out part of code I'm
&gt; working on.
&gt; &gt;
&gt; &gt; It runs inside of Storm and lookups up entries from 10 node riak cluster.
&gt; &gt; I've hit a wall that we can't get past. We are looking up entries (json
&gt; representation of a job)
&gt; &gt; in batches of 100 from Riak, each batch gets handled by a bolt in Storm,
&gt; adding more
&gt; &gt; bolts (an instance of the bolt class with a dedicated thread) results in
&gt; no increase
&gt; &gt; in performance. I instrumted the code and saw that waiting for all riak
&gt; futures to finish
&gt; &gt; increases as more bolts are added. Thinking that perhaps there was
&gt; contention around the
&gt; &gt; RiakCluster object that we were sharing per jvm, I tried giving each
&gt; bolt instance its own
&gt; &gt; cluster object and there wasn't any change.
&gt; &gt;
&gt; &gt; Note that changing Thread spool size given to withExecutor not
&gt; withExecutionAttempts value
&gt; &gt; has any impact.
&gt; &gt;
&gt; &gt; We're working off of the develop branch for the java client. We've been
&gt; using d3cc30d but I also tried with cef7570 and had the same issue.
&gt; &gt;
&gt; &gt; A simplied version of the scala code running this:
&gt; &gt;
&gt; &gt; // called once upon bolt initialization.
&gt; &gt; def prepare(config: JMap[\_, \_],
&gt; &gt; context: TopologyContext,
&gt; &gt; collector: OutputCollector): Unit = {
&gt; &gt; ...
&gt; &gt;
&gt; &gt; val nodes = RiakNode.Builder.buildNodes(new RiakNode.Builder, (1 to
&gt; 10).map(n =&gt; s"riak-beavis-$n").toList.asJava)
&gt; &gt; riak = new RiakCluster.Builder(nodes)
&gt; &gt; // varying this has made no difference
&gt; &gt; .withExecutionAttempts(1)
&gt; &gt; // nor has varying this
&gt; &gt; .withExecutor(new ScheduledThreadPoolExecutor(200))
&gt; &gt; .build()
&gt; &gt; riak.start
&gt; &gt;
&gt; &gt; ...
&gt; &gt; }
&gt; &gt;
&gt; &gt; private def get(jobLocationId: String):
&gt; RiakFuture[FetchOperation.Response] = {
&gt; &gt; val location = new
&gt; Location("jobseeker-job-view").setBucketType("no-siblings").setKey(jobLocationId)
&gt; &gt; val fop = new
&gt; FetchOperation.Builder(location).withTimeout(75).withR(1).build
&gt; &gt;
&gt; &gt; riak.execute(fop)
&gt; &gt; }
&gt; &gt;
&gt; &gt; def execute(tuple: Tuple): Unit = {
&gt; &gt; val indexType = tuple.getStringByField("index\_type")
&gt; &gt; val indexName = tuple.getStringByField("index\_name")
&gt; &gt; val batch = tuple.getValueByField("batch").asInstanceOf[Set[Payload]]
&gt; &gt;
&gt; &gt; var lookups: Set[(Payload, RiakFuture[FetchOperation.Response])] =
&gt; Set.empty
&gt; &gt;
&gt; &gt; // this always returns in a standard time based on batch size
&gt; &gt; time("dispatch-calls") {
&gt; &gt; lookups = batch.filter(\_.key.isDefined).map {
&gt; &gt; payload =&gt; {(payload, get(payload.key.get))}
&gt; &gt; }
&gt; &gt; }
&gt; &gt;
&gt; &gt; val futures = lookups.map(\_.\_2)
&gt; &gt;
&gt; &gt; // this is what takes longer and longer when more bolts are added.
&gt; &gt; // it doesnt matter what the sleep time is.
&gt; &gt; time("waiting-on-futures") {
&gt; &gt; while (futures.count(!\_.isDone) &gt; 0) {
&gt; &gt; Thread.sleep(25L)
&gt; &gt; }
&gt; &gt; }
&gt; &gt;
&gt; &gt;
&gt; &gt; // everything from here to the end returns in a fixed amount of time
&gt; &gt; // and doesn't change with the number of bolts
&gt; &gt; ...
&gt; &gt;
&gt; &gt; }
&gt; &gt;
&gt; &gt;
&gt; &gt; It seems like we are running into contention somewhere in the riak java
&gt; client.
&gt; &gt; My first thought was the LinkedBlockingQueue that serves as the retry
&gt; queue in RiakCluster
&gt; &gt; but, I've tried running with only a single execution attempt as well as
&gt; a custom client
&gt; &gt; version where I removed all retries from the codebase and still
&gt; experience the same problem.
&gt; &gt;
&gt; &gt; I'm still digging through the code looking for possible points of
&gt; contention.
&gt; &gt;
&gt; &gt; Any thoughts?
&gt; &gt;
&gt; &gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; &gt; riak-users mailing list
&gt; &gt; riak-users@lists.basho.com
&gt; &gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;



-- 

Ce n'est pas une signature
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

