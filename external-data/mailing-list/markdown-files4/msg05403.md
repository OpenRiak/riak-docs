---
title: "Re: Race condition reading objects"
description: ""
project: community
lastmod: 2011-10-31T22:15:02-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg05403"
mailinglist_parent_id: "msg05392"
author_name: "Elias Levy"
project_section: "mailinglistitem"
sent_date: 2011-10-31T22:15:02-07:00
---


On Mon, Oct 31, 2011 at 2:01 PM, Rusty Klophaus  wrote:

&gt; Thanks for your excellent description of the problem. We haven't seen this
&gt; before to my knowledge, and this isn't expected behavior.
&gt; Also, if you can share your code, or if you have a small script that can
&gt; reproduce the failure, that would be extremely helpful.
&gt;

I created a small test script that reliable reproduces the issue, but I
created another version that creates truly independent clients (distinct
processes) and I could not reproduce it. So there issue must lie somewhere
in my Fiber based client software stack. Somewhere within em-synchrony or
EventMachine some shared state must be getting clobbered at high processing
rates, or the high rate is causing EventMachine to return a short read
under some circumstances.

Apologies for the false alarm.

In case anyone is using Ruby and would like a Fiber based client for some
parallelism, this is the code:

#!/opt/ruby/bin/ruby

require 'em-synchrony'
require 'riak'
require 'json'

# Riak's PB client uses Thread local storage. We change it to store the
socket in the client.
module Riak
 class Client
 class ProtobuffsBackend
 def socket
 @riakpbc\_socket ||= new\_socket
 end
 def reset\_socket
 socket.close
 @riakpbc\_socket = nil
 end
 end
 end
end

# Riak's PB client mishandles encodings when storing multibyte character
strings. If tries
# to transcode to binary, which it can do as its multibyte, rather than
force binary encoding.
# It already correctly records the original encoding and forces it back
when loading the
# object. Here we monkey patch the offending function. Can't simply
define it within its module,
# as the module is included by the BeefcakeProtobuffsBackend and Ruby won't
include twice a module.
# So we defined it within the class that includes it.
# Fixed on latest beta version of gem.
Riak::Client::BeefcakeProtobuffsBackend.class\_exec {
 def maybe\_encode(string)
 ENCODING ? string.force\_encoding('BINARY') : string
 end
}


# replace default Socket code to use EventMachine Sockets instead
TCPSocket = EventMachine::Synchrony::TCPSocket

hosts = [ "riak1", "riak2", "riak3" ]
num\_hosts = hosts.size

key = 'test\_key'.encode('US-ASCII')

EM.synchrony do
 concurrency = 12
 fibers = []
 concurrency.times do |i|
 fibers &lt;&lt; Fiber.new do
 # set up our client
 puts "Creating client to #{hosts[i%num\_hosts]}"
 c = Riak::Client.new :host =&gt; hosts[i%num\_hosts], :protocol =&gt; "pbc"
 puts "Client created"
 raise "Could not connect to Riak." unless c.ping
 puts "Client ready."

 bucket = c['concur\_test']
 EM::Synchrony.sleep(1)
 while true
 begin
 s = { rand(100000) =&gt; rand(100000) }
 o = bucket.get\_or\_new(key, :r =&gt; 2)
 # Here there be blowups.
 s = JSON.parse(o.raw\_data).merge(s) if o.raw\_data
 o.content\_type = 'application/json'
 o.raw\_data = s.to\_json.encode('UTF-8')
 o.store(:returnbody =&gt; false, :w =&gt; 2, :dw =&gt; 0)
 rescue StopIteration
 break
 end
 end
 end
 end

 # Ruby has not method to wait for a set of fibers to all finish
 # so we just iterate over them, resuming them until they are all
 # done.
 puts "Starting up clients."
 fibers.each { |fiber| fiber.resume }
 EM::Synchrony.sleep(1)
 puts "Waiting for them to finish"
 while not fibers.empty?
 #puts "Iterating over fibers"
 fibers.each do |fiber|
 if not fiber.alive?
 puts "Found finished fiber."
 fibers.delete fiber
 end
 end
 #puts "Iterated over fibers."
 EM::Synchrony.sleep(1)
 end
 EventMachine.stop
end
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

