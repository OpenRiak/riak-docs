---
title: "Re: Mysterious JavaScript MapReduce crashes and timeouts with 0.14.2"
description: ""
project: community
lastmod: 2011-06-24T12:36:57-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg03818"
mailinglist_parent_id: "msg03816"
author_name: "Mathias Meyer"
project_section: "mailinglistitem"
sent_date: 2011-06-24T12:36:57-07:00
---


David,

given your description of the error behaviour and the MapReduce job shown 
below, here's an outline of what's happening in your cluster when you fire that 
job 208 times in quick succession:

\* All nodes in the cluster go through their keys using the filter you supplied, 
that's 208 times of going through all 75k keys.
\* Listing keys (which key filters still technically do) is a blocking 
operation, blocking the vnode responsible for a particular partition, and 
therefore, set of keys. It's an expensive operation, and again, you're running 
hundreds of jobs in quick succession, enforcing 208 key listings in a very 
short period of time.
\* Then 208 MapReduce jobs have to be spread across the cluster to the 
respective nodes having the data, each job is queued to be run by one of the 
JavaScript VM processes.
\* Then all nodes with keys matching your criteria load all the objects matching 
the key filter from their respective disks, again, 208 times multiplied by the 
number of objects that match the criteria.
\* The reduce phase is run only on one node, in your case riak01, that's 208 
times again. This is only CPU bound obviously, but requires all the data to be 
gathered on that particular node from all the jobs that just ran the map 
functions, again, 208 times.

The intention here is certainly not to excuse Riak for the behaviour it's 
showing. It's to give you an idea that you're putting a considerable load on 
your cluster. The problem is that you're also not running an SMP-enabled 
version of Erlang, therefore everything utilizes just one CPU/core, slowing 
things down even more. The process you're seeing should be beam.smp and not 
just beam. Make sure your Erlang is compiled with --enable-smp if you're on a 
multi-core/multi-CPU system.

Other things you should/could try to reduce the risk of crashing Riak:

\* Instead of rapid-fire, limit the amount of concurrent MapReduce jobs.
\* Ditch JavaScript, use Erlang instead. From looking at your code, the logic 
seams to be straight forward and should not be that hard to implement in 
Erlang. This is not a must, but you'll gain tremendously by not relying on the 
JavaScript VM, which involves lots of JSON serialization and call-outs to 
external libraries.
\* Reduce the need for key filters, or simply avoid them entirely. If you need 
range queries or queries looking for values starting with a particular string, 
which seems to be the case here, consider using Riak Search instead.
\* Spread the request more evenly across your cluster, reducing the coordination 
load on just one of the nodes. This won't help with the entire pain though, as 
it only reduces the load of the last step in your MapReduce job, so it's more 
of a general practice.

Mathias Meyer
Developer Advocate, Basho Technologies


On Freitag, 24. Juni 2011 at 20:43, David Mitchell wrote:

&gt; I am doing 208 MapReduce jobs in rapid-fire succession using anonymous 
&gt; JavaScript functions. I am sending the MapReduce jobs to a single node, 
&gt; riak01. There are about 75,000 keys in the bucket.
&gt; Erlang: R13B04
&gt; Riak: 0.14.2
&gt; 
&gt; When I had my MapReduce timeout set to 120,000 ("timeout":120000), I was 
&gt; getting 
&gt; mapexec\_error, {error,timeout}
&gt; This first timeout wrote to the error log after seven seconds. The second and 
&gt; third wrote to the error log after five seconds. The four timeout wrote the 
&gt; error log after eight seconds. The beam process never crashed.
&gt; 
&gt; So, I increased the value to 30,000,000 ("timeout":30000000). In the first 
&gt; run, all MapReduce jobs completed without error, each one taking about 1 to 3 
&gt; seconds to complete.
&gt; The CPU usage on riak01 was about 50 percent for all 208 jobs.
&gt; Below is a sample output from iostat -x
&gt; avg-cpu: %user %nice %system %iowait %steal %idle
&gt; 51.00 0.00 5.01 0.10 0.00 43.89
&gt; 
&gt; Device: rrqm/s wrqm/s r/s w/s rsec/s wsec/s avgrq-sz avgqu-sz await svctm 
&gt; %util
&gt; hda 0.00 8.22 0.00 3.21 0.00 91.38 28.50 0.01 2.62 2.12 0.68
&gt; 
&gt; In the second run, on the 53rd MapReduce job, the job was still waiting to 
&gt; complete after 10 minutes. So, there was never a timeout, and nothing was 
&gt; written to the error logs. However, the beam process obviously crashed. On 
&gt; raik01, I executed the following commands:
&gt; ./riak-admin status
&gt; Node is not running!
&gt; ./riak ping
&gt; Node 'riak@10.0.60.208 (mailto:riak@10.0.60.208)' not responding to pings.
&gt; ./riak attach
&gt; Node is not running!
&gt; 
&gt; However, ps and top showed the process running.
&gt; ps output:
&gt; 1003 31807 1.0 8.7 172080 132584 pts/1 Rsl+ Jun22 28:53 
&gt; /home/DMitchell/riak2/riak/rel/riak/erts-5.7.5/bin/beam -K true -A 64 -- 
&gt; -root /home/DMitchell/riak2/riak/rel/riak -progname riak -- -home 
&gt; /home/DMitchell -- -boot 
&gt; /home/DMitchell/riak2/riak/rel/riak/releases/0.14.2/riak -embedded -config 
&gt; /home/DMitchell/riak2/riak/rel/riak/etc/app.config -name riak@10.0.60.208 
&gt; (mailto:riak@10.0.60.208) -setcookie riak -- console
&gt; 
&gt; top output:
&gt; PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
&gt; 31807 DMitchel 25 0 168m 129m 4360 R 99.3 8.7 30:46.08 beam
&gt; 
&gt; Below is a sample output from iostat -x when beam was in the crashed state:
&gt; avg-cpu: %user %nice %system %iowait %steal %idle
&gt; 100.00 0.00 0.00 0.00 0.00 0.00
&gt; 
&gt; Device: rrqm/s wrqm/s r/s w/s rsec/s wsec/s avgrq-sz avgqu-sz await svctm 
&gt; %util
&gt; hda 0.00 1.82 0.00 0.61 0.00 19.45 32.00 0.00 2.00 2.00 0.12
&gt; 
&gt; Note the 100 percent CPU usage for the beam process. I terminated the beam 
&gt; process with: kill -s TERM 31807. Then, I restarted riak.
&gt; 
&gt; There were no errors on the other two nodes, except for:
&gt; =ERROR REPORT==== 24-Jun-2011::12:29:36 ===
&gt; \*\* Node 'riak@10.0.60.208 (mailto:riak@10.0.60.208)' not responding \*\*
&gt; \*\* Removing (timedout) connection \*\*
&gt; 
&gt; The MapReduce job is not that complex. I am using a key filter. The map phase 
&gt; looks for an "LoadRange", and creates a new variable (e.g., "Load1", if there 
&gt; is a match. The reduce phase counts the matches.
&gt; {
&gt; "inputs" : {
&gt; "bucket" : "names-51013",
&gt; "key\_filters" : [["starts\_with", "22204-1-3"]]
&gt; },
&gt; "query" : [{
&gt; "map" : {
&gt; "keep" : false,
&gt; "language" : "javascript",
&gt; "arg" : null,
&gt; "source" : "function(value,keyData,arg){var 
&gt; data=Riak.mapValuesJson(value)[0];if(data.LoadRange&&data.LoadRange==1) 
&gt; return[{\"data.Load1\":1}];else if(data.LoadRange&&data.LoadRange==2) 
&gt; return[{\"data.Load2\":1}];else if(data.LoadRange&&data.LoadRange==3) 
&gt; return[{\"data.Load3\":1}];else if(data.LoadRange&&data.LoadRange==4) 
&gt; return[{\"data.Load4\":1}];else if(data.LoadRange&&data.LoadRange==5) 
&gt; return[{\"data.Load5\":1}];else if(data.LoadRange&&data.LoadRange==6) 
&gt; return[{\"data.Load6\":1}];else if(data.LoadRange&&data.LoadRange==7) 
&gt; return[{\"data.Load7\":1}];else if(data.LoadRange&&data.LoadRange==8) 
&gt; return[{\"data.Load8\":1}];else if(data.LoadRange&&data.LoadRange==9) 
&gt; return[{\"data.Load9\":1}];else if(data.LoadRange&&data.LoadRange==10) 
&gt; return[{\"data.Load10\":1}];else return[];}"
&gt; }
&gt; }, {
&gt; "reduce" : {
&gt; "keep" : true,
&gt; "language" : "javascript",
&gt; "arg" : null,
&gt; "source" : "function(v){var s={};for(var i in v){for(var n in v[i]){if(n in 
&gt; s) s[n]+=v[i][n];else s[n]=v[i][n];}} return[s];}"
&gt; }
&gt; }
&gt; ],
&gt; "timeout" : 30000000
&gt; }
&gt; 
&gt; 
&gt; The MapReduce timeout seem to be happening at different places, e.g., during 
&gt; the map phase, during the reduce phase and during the key filtering phase 
&gt; (#Fun,[],[]}).
&gt; 
&gt; See the URL below for the complete sasl-error.log right before a recent beam 
&gt; crash.
&gt; https://gist.github.com/1045386
&gt; 
&gt; Can anyone shed any light on why I am getting timeouts and crashes?
&gt; 
&gt; David
&gt; 
&gt; 
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com (mailto:riak-users@lists.basho.com)
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com



\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

