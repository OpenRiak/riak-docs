---
title: "Re: loading erlang terms"
description: ""
project: community
lastmod: 2010-10-26T21:59:10-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg01386"
mailinglist_parent_id: "msg01382"
author_name: "Seth Falcon"
project_section: "mailinglistitem"
sent_date: 2010-10-26T21:59:10-07:00
---


On Tue, Oct 26, 2010 at 9:37 AM, Charles Blair  wrote:
&gt; Btw, the documentation has this:
&gt;
&gt; encode\_term(Object, Term) -&gt;
&gt;    riakc\_obj:update\_value(Object, term\_to\_binary(Term, [compressed]),
&gt;                           &lt;&lt;"application/x-erlang-term"&gt;&gt;).
&gt;

&gt; This gave me the idea that perhaps by encoding the content type as
&gt; application/x-erlang-term I could get things to work as I envisioned
&gt; they might, but I couldn't.

I think the content-type is used to help clients treat data
appropriately. I don't think Riak does any auto-magic transformations
itself.

Storing the result of term\_to\_binary makes more sense to me; you could
still have a simple escript that loads a file on disk into Riak using
the HTTP interface if that keeps things convenient.

If storing the text content of a file containing Erlang terms (as you
would use with file:consult/1) is what you want, then you can do that
too. I think you almost had a working solution, but got tripped up by
erl\_parse:parse\_term expecting tokens for a single term, not many
terms. Below is an example that gets around this by breaking up the
list of tokens returned by erl\_scan:string by breaking on term
boundaries ({dot, \_}). A regex using the re module would be
expedient, but error-prone because "." can appear in a number of ways
in which it does not represent a term terminator.

-module(ep).

-compile([export\_all]).

test(File) -&gt;
 {ok, Bin} = file:read\_file(File),
 {ok, Tokens, \_} = erl\_scan:string(binary\_to\_list(Bin)),
 lists:map(fun(T) -&gt;
 {ok, Term} = erl\_parse:parse\_term(T),
 Term
 end, split\_by\_terms(Tokens)).

pop\_term(T) -&gt;
 pop\_term(T, []).

pop\_term([T | Rest], Acc) -&gt;
 case T of
 {dot, \_} -&gt;
 {lists:reverse([T|Acc]), Rest};
 \_Else -&gt;
 pop\_term(Rest, [T|Acc])
 end;
pop\_term([], Acc) -&gt;
 {lists:reverse(Acc), []}.

split\_by\_terms(Tokens) -&gt;
 split\_by\_terms(Tokens, []).

split\_by\_terms(Tokens = [\_H|\_T], Acc) -&gt;
 {TermTokens, Rest} = pop\_term(Tokens),
 split\_by\_terms(Rest, [TermTokens|Acc]);
split\_by\_terms([], Acc) -&gt;
 lists:reverse(Acc).


-- 
Seth Falcon | @sfalcon | http://userprimary.net/

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

