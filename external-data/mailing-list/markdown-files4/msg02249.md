---
title: "Re: Storing large collections in Riak (or any distributed store)"
description: ""
project: community
lastmod: 2011-02-09T10:12:46-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg02249"
mailinglist_parent_id: "msg02248"
author_name: "Jeremiah Peschka"
project_section: "mailinglistitem"
sent_date: 2011-02-09T10:12:46-08:00
---


Incidentally, this is also how flickr handles writes - when you upload a photo 
it gets written to wherever your other photos go. When someone tags it or adds 
it to a group, it gets copied into that group.

Unless, of course, it's all changed since the last time I looked for 
information about how flickr actually works.

-- 
Jeremiah Peschka
Sent with Sparrow
On Wednesday, February 9, 2011 at 10:09 AM, Alexander Sicular wrote: 
&gt; The only way this is functional is if you implement a uniformly random
&gt; hash function so that you know which key any given address will hash
&gt; to. Separately, churn will eat you up if you constantly need to take
&gt; addys out of your keys. Also, as mentioned elsewhere, Riak links won't
&gt; work at these numbers.
&gt; 
&gt; Check out more tech slides/blogs on how twitter does this. Basically
&gt; double/reverse/reciprocal look up lists with recipient notification.
&gt; When @aplusk tweets twitter does like 4million (or however many
&gt; followers he has) writes. I recommend @rk's qcon sf 2010 talk on nosql
&gt; at twitter.
&gt; 
&gt; Best, alexander
&gt; 
&gt; On 2011-02-09, Scott Lystig Fritchie  wrote:
&gt; &gt; Nathan Sobo  wrote:
&gt; &gt; 
&gt; &gt; ns&gt; Is a key-value store actually inappropriate for this problem?
&gt; &gt; 
&gt; &gt; No. One way to do it is to use a single KV key to store multiple
&gt; &gt; addresses worth of info. Pick a relatively big number, 50K
&gt; &gt; subscribers/key, though it may vary. Use a key naming scheme so that
&gt; &gt; you can pre-calculate all keys for a given list, e.g. bucket =
&gt; &gt; list-subscribers, key = name + range index #, or perhaps list name
&gt; &gt; + start-of-hash-range + end-of-hash-range.
&gt; &gt; 
&gt; &gt; How do you know the range index # or start & ends of range? One method
&gt; &gt; would be hashing, MD5 or SHA1 or whatever. If you store all addresses
&gt; &gt; for a list with a fixed number of hash hunks, e.g. 100, then each hash
&gt; &gt; hunk will have roughly 20K entries for a 2M subscriber list. To find
&gt; &gt; all subscribers, fetch 100 known keys.
&gt; &gt; 
&gt; &gt; If you want to keep addresses in sorted order, it's more work but also
&gt; &gt; doable. A naive plan is to make your hash function F(addr) = first
&gt; &gt; letter of 'addr'. Keys get clumpy that way, but only slightly more
&gt; &gt; creativity can get around it.
&gt; &gt; 
&gt; &gt; To find a particular subscriber, hash that subscriber's address and
&gt; &gt; fetch 1 key. You're also getting a lot of uninteresting data with that
&gt; &gt; key's value, but if event is uncommon, it's not a problem. (If that
&gt; &gt; event actually is common, consider moving the commonly-queried data
&gt; &gt; elsewhere. Or duplicate that info in another smaller key somewhere
&gt; &gt; else.) Similar logic for list maintenance events (add subscriber,
&gt; &gt; delete subscriber).
&gt; &gt; 
&gt; &gt; -Scott
&gt; &gt; 
&gt; &gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; &gt; riak-users mailing list
&gt; &gt; riak-users@lists.basho.com
&gt; &gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt; 
&gt; -- 
&gt; Sent from my mobile device
&gt; 
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt; 
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

