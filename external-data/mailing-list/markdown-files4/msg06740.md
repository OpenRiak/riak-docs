---
title: "Re: Possibility of a CAS API"
description: ""
project: community
lastmod: 2012-02-24T19:46:46-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg06740"
mailinglist_parent_id: "msg06739"
author_name: "Reid Draper"
project_section: "mailinglistitem"
sent_date: 2012-02-24T19:46:46-08:00
---



On Feb 24, 2012, at 10:21 PM, Armon Dadgar wrote:

&gt; It sounds like the "If-Unmodified-Since" and "If-None-Match" flags could do 
&gt; what I
&gt; need, but the docs specify "it is possible for the condition to evaluate to 
&gt; true for
&gt; multiple requests if the requests occur at the same time."
&gt; 
&gt; From my understanding, the KV vnode's process their requests in a serial 
&gt; fashion.
&gt; I'm not sure I fully understand how It could be that the request evaluates to 
&gt; true
&gt; for multiple requests, if the PUTs are handled serially.
&gt; 
&gt; If it is a matter of the vnodes being interleaved, would it be solvable by
&gt; setting w = r = n?
The problem is that amongst all replicas for a particular key,
operations are not serializable. Put another way, if there
are concurrent writes to three replicas,
there is no way to figure out a total ordering for the actions.

It's also important to note that even when you set W=N
for a write, it's possible that 1 write could succeed
and 2 could fail. The succeeding write is \_not\_ "rolled back"
when this happens. The user will see an error message
that the write didn't succeed on all replicas.
&gt; 
&gt; I'm not convinced that a CAS operation is inevitably subject to data races.
&gt; There are proven techniques for avoiding races at the cost of latency,
&gt; which is acceptable in certain situations.
Correct, but as far as I know, there is no way to build a CAS system
on top of the primitives provided by the Riak public API. You need
a point of serialization amongst all of the replicas (for a particular key),
which Riak does not provide, for availability reasons.
&gt; 
&gt; I will take a look at Zab, thanks for the reference!
Zab and Paxos are going to be your best references.
It's also worth noting that if you don't need high availability,
there are other ways of gaining durability that will give
you strong consistency and the ability to do CAS operations.
&gt; 
&gt; Best Regards,
&gt; 
&gt; Armon Dadgar
&gt; 
&gt; On Feb 24, 2012, at 6:09 PM, Dietrich Featherston wrote:
&gt; 
&gt;&gt; If you need CAS semantics, then coordinate that outside of riak. Any 
&gt;&gt; check-then-act type of operation where atomicity is important is going to 
&gt;&gt; leave some room for a data race in a system with the distribution semantics 
&gt;&gt; of riak. Would suggest thinking about the problem in such a way that 
&gt;&gt; handling of siblings is tolerant of duplicate writes and eventually the 
&gt;&gt; correct value bubbles up to the readers. That or do the coordination of 
&gt;&gt; unique indexes in something not dynamo shaped.
&gt;&gt; 
&gt;&gt; I can't say I'm intimately familiar with the work yet, but others have 
&gt;&gt; prototyped/postulated consistency layers on top of riak (a la zab) that 
&gt;&gt; might more closely match what you're trying to do. None of this is in a 
&gt;&gt; released / supported version of riak to my knowledge though.
&gt;&gt; 
&gt;&gt; Thanks,
&gt;&gt; D
&gt;&gt; 
&gt;&gt; 
&gt;&gt; On Fri, Feb 24, 2012 at 4:41 PM, Armon Dadgar  wrote:
&gt;&gt; As part of a new feature we are working on, we've run into
&gt;&gt; a situation where it would be incredibly convenient to have a 
&gt;&gt; check-and-set (CAS) API for Riak KV. In short, we are trying to build
&gt;&gt; a unique index of a bucket, using a second bucket which acts as a 
&gt;&gt; reverse index.
&gt;&gt; 
&gt;&gt; The CAS API would operate in the same manner as a PUT, except it
&gt;&gt; should take a "last vclock". The new value + last vclock are submitted
&gt;&gt; to the responsible vnodes. The vnodes respond if the last vclock
&gt;&gt; for the key matches the specified last value. If we get "r" nodes responding
&gt;&gt; that the last value matches, then we should commit the write. This method
&gt;&gt; is basically a two-phase commit.
&gt;&gt; 
&gt;&gt; It would also be great if no-value sentinel could be specified to indicate
&gt;&gt; the CAS should only succeed if there is not already a key. We need this
&gt;&gt; to make sure uniqueness constraints are not violated.
&gt;&gt; 
&gt;&gt; I wanted to gauge the interest from the community in something like this,
&gt;&gt; and see if I could get thoughts from the Basho team on if this could be
&gt;&gt; implemented.
&gt;&gt; 
&gt;&gt; Best Regards,
&gt;&gt; 
&gt;&gt; Armon Dadgar
&gt;&gt; 
&gt;&gt; 
&gt;&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;&gt; 
&gt;&gt; 
&gt; 
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

