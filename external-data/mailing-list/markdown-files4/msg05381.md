---
title: "Re: atomically updating multiple keys"
description: ""
project: community
lastmod: 2011-10-30T12:09:48-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg05381"
mailinglist_parent_id: "msg05373"
author_name: "Justin Karneges"
project_section: "mailinglistitem"
sent_date: 2011-10-30T12:09:48-07:00
---


Yes, this is one I just thought of and was going to ask if it made sense. In 
order to write A first, you'd need B's key id to be generated outside of Riak 
(e.g. client generated UUID or snowflake or something). Then you can use a job 
queue with retries that can simply mash the writing of B until it succeeds. 
"Eventually" the A-&gt;B relationship would exist, and in the meantime the 
application would need to cope with a possible dangling pointer (A pointing to 
a nonexistent key).

On Sunday, October 30, 2011 09:49:00 AM Aphyr wrote:
&gt; One easy way to solve an atomic a-&gt;b relationship in an eventually
&gt; consistent way is to require the existence of both A and B in order to
&gt; consider the write valid, to write A first, and use a message queue to
&gt; retry writes until both A and B exist. There are other approaches for
&gt; agreement between objects, but they add complexity. Paxos, 2PC, etc.
&gt; 
&gt; --Kyle
&gt; 
&gt; On 10/30/2011 09:42 AM, Les Mikesell wrote:
&gt; &gt; On Sun, Oct 30, 2011 at 10:43 AM, Alexander Sicular 
wrote:
&gt; &gt;&gt; Greetings Justin,
&gt; &gt;&gt; 
&gt; &gt;&gt; IMHO, AFAIK, IANAL, etc. "is it ok?" really boils down to whatever
&gt; &gt;&gt; you're ok with, can program, can understand, is within you're budget,
&gt; &gt;&gt; can implement and/or do all of the above within your own timeline. I
&gt; &gt;&gt; think it is always true that the number of opinions you will get is
&gt; &gt;&gt; more than the number of participants in the conversation. Ergo, filter
&gt; &gt;&gt; all contributions through the lense of: Go with what you know. Coming
&gt; &gt;&gt; here for advice is fine but like preventing wildfires, only you know
&gt; &gt;&gt; your use case.
&gt; &gt;&gt; 
&gt; &gt;&gt; That said, you may want to check out using a message queue to control
&gt; &gt;&gt; the asynchronous, eventually consistent data model I feel you feel you
&gt; &gt;&gt; are leaning towards.
&gt; &gt; 
&gt; &gt; I don't see how pushing the problem elsewhere helps. Even if your
&gt; &gt; message queue orders a set of updates in the right sequence, riak does
&gt; &gt; not have a mechanism to ensure that they go into the db in that order
&gt; &gt; and a delete might happen before the insert intended to be done first
&gt; &gt; but actually happening concurrently - unless you make the writes wait
&gt; &gt; for all nodes on every operation. I think riak has a concept of a
&gt; &gt; partition 'owner' node, but it is used only in the data migration
&gt; &gt; process for failover and node adds/removes, not to give ordinary
&gt; &gt; writes an atomic property.
&gt; 
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

