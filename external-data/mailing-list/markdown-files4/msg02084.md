---
title: "Re: Getting all the Keys"
description: ""
project: community
lastmod: 2011-01-23T11:15:03-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg02084"
mailinglist_parent_id: "msg02077"
author_name: "Eric Moritz"
project_section: "mailinglistitem"
sent_date: 2011-01-23T11:15:03-08:00
---


After thinking about it. A b-tree in a bucket wouldn't provide any
functionality that I couldn't get from riak search... so that's probably a
bad idea.
On Jan 22, 2011 3:28 PM, "Eric Moritz"  wrote:
&gt; I have a pipe dream of doing a distibuted b-tree with a bucket who's value
&gt; is a node in the tree containing a list of keys to another bucket and left
&gt; and right links to children nodes.
&gt;
&gt; It feels right in my head, though it is probably horribly flawed in some
&gt; way. I'm certain more clever data nerds than me have thought of this and
&gt; dismissed it for some obvious reason that I'm too green to see.
&gt;
&gt; Eric.
&gt; On Jan 22, 2011 2:46 PM, "Gary William Flake"  wrote:
&gt;&gt; This is a really big pain point for me as well and -- at the risk of
&gt;&gt; prematurely being overly critical of Riak's overall design -- I think it
&gt;&gt; points to a major flaw of Riak in its current state.
&gt;&gt;
&gt;&gt; Let me explain....
&gt;&gt;
&gt;&gt; Riak is bad at enumerating keys. We know that. I am happy to manage a
list
&gt;&gt; of keys myself. Fine. How do I do that in Riak?
&gt;&gt;
&gt;&gt; Well, the obvious solution is to have a special object that you maintain
&gt;&gt; that is a list of the keys that you need. So, each time you insert a new
&gt;&gt; object, you effectively append a new key to the end of a list, that is
&gt;&gt; itself a value to a special index key.
&gt;&gt;
&gt;&gt; But what is an append in Riak? The only way to implement a list append is
&gt;&gt; to:
&gt;&gt;
&gt;&gt; 1. read in the entire value of your list object.
&gt;&gt; 2. append to this list at the application layer.
&gt;&gt; 3. reinsert the new value back into the list.
&gt;&gt;
&gt;&gt; This is a horrible solution for at least three reasons. First, inserting
N
&gt;&gt; new keys and maintaining your own list is now O(N\*N) runtime complexity
&gt;&gt; because each append has to do I/O proportional to the size of the entire
&gt;&gt; list for each append. Second, this operation should be happening entirely
&gt;&gt; at the data layer and not between the data and app layer. Third, it
&gt;&gt; introduces write contentions in that two clients may try to append at
&gt;&gt; approximately the same time, giving you a list that is now inconsistent.
&gt;&gt;
&gt;&gt; The conclusion for me is that you can't efficiently enumerate keys with
&gt; Riak
&gt;&gt; even if you roll your own key index with Riak (in anything close to an
&gt; ideal
&gt;&gt; way).
&gt;&gt;
&gt;&gt; To overcome this problem, Riak desperately needs to either maintain its
&gt; own
&gt;&gt; key index efficiently, or it needs to support atomic mutations on values.
&gt;&gt;
&gt;&gt; For an example of the latter approach, see Redis which I think handles
&gt; this
&gt;&gt; beautifully.
&gt;&gt;
&gt;&gt; In the end, you may need to think about redesigning your data model so
&gt; that
&gt;&gt; there never is a need to enumerate keys. I am trying this and I use a
&gt;&gt; combination of:
&gt;&gt;
&gt;&gt; 1. Standard KV approaches,
&gt;&gt; 2. Riak search for being able to enumerate some records in order,
&gt;&gt; 3. Transactions logs stored in a special bucket,
&gt;&gt; 4. Batched M/R phases on the Transaction logs to avoid write contention,
&gt; and
&gt;&gt; 5. Batched rebuilding of "views" in a view bucket.
&gt;&gt;
&gt;&gt; Given that Riak search is loudly proclaimed as being beta, this makes me
&gt;&gt; fairly anxious.
&gt;&gt;
&gt;&gt; I am very close to not needing to enumerate keys the bad way now.
However,
&gt;&gt; I would have killed for an atomic mutator like Redis.
&gt;&gt;
&gt;&gt; BTW, I would love for someone from Basho to disabuse me of my conclusions
&gt; in
&gt;&gt; this note.
&gt;&gt;
&gt;&gt; -- GWF
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt; On Sat, Jan 22, 2011 at 10:40 AM, Alexander Staubo &gt;wrote:
&gt;&gt;
&gt;&gt;&gt; On Sat, Jan 22, 2011 at 19:34, Alexander Staubo 
&gt;&gt;&gt; wrote:
&gt;&gt;&gt; &gt; On Sat, Jan 22, 2011 at 18:23, Thomas Burdick
&gt;&gt;&gt; &gt;  wrote:
&gt;&gt;&gt; &gt;&gt; So really whats the solution to just having a list of like 50k keys
&gt; that
&gt;&gt;&gt; can
&gt;&gt;&gt; &gt;&gt; quickly be appended to without taking seconds to then retrieve later
&gt; on.
&gt;&gt;&gt; Or
&gt;&gt;&gt; &gt;&gt; is this just not a valid use case for riak at all? That would suck
&gt; cause
&gt;&gt;&gt; &gt;&gt; again, I really like the notion of an AP oriented database!
&gt;&gt;&gt; &gt;
&gt;&gt;&gt; &gt; I have been struggling with the same issue. You may want to look at
&gt;&gt;&gt; &gt; Cassandra, which handles sequential key range traversal very well.
&gt;&gt;&gt; &gt; Riak also has a problem with buckets sharing the same data storage
&gt;&gt;&gt; &gt; (buckets are essentially just a way to namespace keys), so if you have
&gt;&gt;&gt; &gt; two buckets and fill up one of them, then enumerating the keys of the
&gt;&gt;&gt; &gt; empty bucket will take a long time even though it
&gt;&gt;&gt;
&gt;&gt;&gt; I accidentally "Send". Again: I have been struggling with the same
&gt;&gt;&gt; issue. You may want to look at Cassandra, which handles sequential key
&gt;&gt;&gt; range traversal very well. Riak also has a problem with buckets
&gt;&gt;&gt; sharing the same data storage (buckets are essentially just a way to
&gt;&gt;&gt; namespace keys), so if you have two buckets and fill up one of them,
&gt;&gt;&gt; then enumerating the keys of the empty bucket will take a long time
&gt;&gt;&gt; even though it's empty. Cassandra does not have a problem with this,
&gt;&gt;&gt; since Cassandra's keyspaces are separate data structures. I like Riak,
&gt;&gt;&gt; but it only works well with single-key/linked traversal, not this kind
&gt;&gt;&gt; of bucket-wide processing.
&gt;&gt;&gt;
&gt;&gt;&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt;&gt;&gt; riak-users mailing list
&gt;&gt;&gt; riak-users@lists.basho.com
&gt;&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;&gt;&gt;
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

