---
title: "Re: allow_mult vs. 2i"
description: ""
project: community
lastmod: 2013-09-26T16:10:59-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg12420"
mailinglist_parent_id: "msg12399"
author_name: "Brady Wetherington"
project_section: "mailinglistitem"
sent_date: 2013-09-26T16:10:59-07:00
---


Oh, I get what the siblings/allow\_mult business is for, just wondering if I
can use it off-label a little, and eventually do 'conflict resolution'
which would make the results be much more reasonable.

But it sounds like I shouldn't do that. That's totally fine.

Since I'm doing a write-once, update-never environment - I don't see how
allow\_mult would help me otherwise? A new write will always be to a new
key. There will never be an update. So if that's the case - no need for
allow\_mult. Does that sound right?

-B.


On Wed, Sep 25, 2013 at 6:30 PM, Jeremiah Peschka &lt;
jeremiah.pesc...@gmail.com&gt; wrote:

&gt; inline.
&gt;
&gt; ---
&gt; Jeremiah Peschka - Founder, Brent Ozar Unlimited
&gt; MCITP: SQL Server 2008, MVP
&gt; Cloudera Certified Developer for Apache Hadoop
&gt;
&gt;
&gt; On Wed, Sep 25, 2013 at 2:47 PM, Brady Wetherington 
&gt; wrote:
&gt;
&gt;&gt; I've built it a solid proof-of-concept system on leveldb, and use some 2i
&gt;&gt; indexes in order to search for certain things - usually just for counts of
&gt;&gt; things.
&gt;&gt;
&gt;&gt; I have two questions so far:
&gt;&gt;
&gt;&gt; First off, why is Bitcask the default? Is it just because it is faster?
&gt;&gt; Or is it considered more 'stable' or something?
&gt;&gt;
&gt;
&gt; Long ago, when bitcask was elected as the default, LevelDB was not a
&gt; thing.
&gt;
&gt; Databases strive for stability and the principle of least surprise.
&gt; Changing anything can potentially introduce performance regressions,
&gt; stability problems, and any host of other undesirable and reputation
&gt; destroying things.
&gt;
&gt; Changing the storage back end is high up on the list of things I'd never
&gt; want to do in a database. Why do you think MySQL still defaults to MyISAM?
&gt;
&gt;
&gt;&gt;
&gt;&gt; Next, I've learned about the allow\_mult feature you can set on buckets. I
&gt;&gt; wonder if I should use this for my most heavily-used primary-purpose
&gt;&gt; queries? Is there a limit to how many 'siblings' you can have for an entry?
&gt;&gt; Is it inadvisable to do what I'm talking about? Would fetching all of the
&gt;&gt; siblings end up being a disastrous nightmare or something?
&gt;&gt;
&gt;
&gt; The upper limit will depend on the size of your objects. You don't want to
&gt; have object sizes (including siblings) much beyond 6MB. You'll have a lot
&gt; of network congestion. You certainly \*could\* have bigger object + sibling
&gt; collections, but you'd want to beef up the network backend to something
&gt; like 10GbE, 40GbE, or InfiniBand to deal with the increased gossip.
&gt;
&gt; Fetching all of your siblings is bad if you never resolve siblings since
&gt; you'll have a lot of data.
&gt;
&gt; Allow\_mult is typically turned on for production clusters. This is set off
&gt; by default to help new users get a handle on Riak quickly without having to
&gt; worry about siblings. Once you get the hang of how Riak behaves, turning on
&gt; siblings is usually a good thing.
&gt;
&gt; Depending on resolution, it's probably best to read your data, resolve
&gt; siblings, and send that garbage collected object back to Riak - even if
&gt; you're performing a "read only" query. The new Riak DT features eliminate
&gt; some of the worry about siblings by pushing the responsibility back down to
&gt; Riak. Those features are only available if you're building from source, but
&gt; hopefully Riak 2.0 will be out soon.
&gt;
&gt;
&gt;&gt; I \*assume\* - and I could be wrong - that a 2i query would be slower than
&gt;&gt; a fetch-of-siblings for a particular key - is that wrong?
&gt;&gt;
&gt;&gt; If I switch from using 2i indexes to using allow\_mult and siblings, we'd
&gt;&gt; be talking a few hundred thousand to low millions for a sibling-count.
&gt;&gt;
&gt;
&gt; I do not think 'siblings' means what you think it means.
&gt;
&gt; A sibling would occur if two clients, A and B, read v1 of an object and
&gt; then issue writes.
&gt;
&gt; Client A updates object and sets preferences to ['cat pictures', 'ham
&gt; sandwiches']
&gt; Client B updates object and sets preferences to ['knitting with bacon']
&gt;
&gt; With allow\_mult enabled you'd have two versions of the object. These are
&gt; siblings.
&gt;
&gt; If you're thinking of some kind of index created by your application, you
&gt; could look at 2i vs using siblings to build a secondary index:
&gt; http://basho.com/index-for-fun-and-for-profit/ Even when you're creating
&gt; your own secondary index, you still want to perform garbage collection on
&gt; the data you're storing in Riak.
&gt;
&gt;
&gt;&gt; Thanks for making an excellent product! Can't wait to get this bad boy
&gt;&gt; into production and really see what it can do!
&gt;&gt;
&gt;&gt; -B.
&gt;&gt;
&gt;&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;&gt;
&gt;&gt;
&gt;
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;
&gt;
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

