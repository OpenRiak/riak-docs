---
title: "Re: Looking for Riak recommendations for modeling data with N:1	references"
description: ""
project: community
lastmod: 2012-06-04T14:54:21-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg07611"
mailinglist_parent_id: "msg07546"
author_name: "Mark Phillips"
project_section: "mailinglistitem"
sent_date: 2012-06-04T14:54:21-07:00
---


Hi,

Assuming I'm understanding your use case correctly, the first option seems
like your best bet.

Primary key lookups are where Riak really shines, and if you're only
GET-ing one key and then manipulating the associated json-dict with some
app code, things should perform quite well (assuming your objects aren't
huge).

Does that make sense? Or did I misunderstand things?

Mark

On Sun, May 27, 2012 at 5:45 PM, elij  wrote:

&gt; Hello,
&gt;
&gt; I am evaluating Riak for a project, and am looking for some
&gt; recommendations on modeling data for optimal performance. The data is a
&gt; single 'object' (henceforth named 'Widget') that needs to be looked up via
&gt; N possible attributes, and should have a reference to theses keys. There
&gt; will be many hundreds of millions of such Widgets (keys will not fit in
&gt; cluster ram). Currently this data is housed in a RDBMS, but we are looking
&gt; at a few alternatives due to single node scaling issue, the desire for
&gt; easier operations, and growth to more datacenters.
&gt;
&gt; Consider the following example Widget object..
&gt;
&gt; Widget:
&gt; vendorAkey: "widget001"
&gt; vendorBkey: "bluewidget6"
&gt; vendorCkey: "sprocket42"
&gt; widgetData: 
&gt;
&gt; My ideas so far are to:
&gt;
&gt; 1) have 'reference lookups' performed application side, with a 'widget'
&gt; bucket at the end.
&gt;
&gt; widget001 = 282ec0a1-a842-11e1-83cd-34159e0284ea
&gt; bluewidget6 = 282ec0a1-a842-11e1-83cd-34159e0284ea
&gt; sprocket42 = 282ec0a1-a842-11e1-83cd-34159e0284ea
&gt;
&gt; then finally the 'real widget'
&gt; 282ec0a1-a842-11e1-83cd-34159e0284ea = 
&gt;
&gt; With the idea being that the application code would fetch the uuid1 value
&gt; by vendor key, and then perform another fetch of the actual widget data
&gt; based on the response of the first (if found). The widget json dict would
&gt; contain the vendor keys as well (for any needed cleanup down the road,
&gt; cross reference, etc).
&gt;
&gt; 2) Use secondary indexes and have each vendor 'key' be a secondary index.
&gt; I heard[1] that secondary indexes are slow though.
&gt;
&gt; 3) use layout of the first solution, but with links instead of application
&gt; side lookups. I also hear[2] that links are slow too.
&gt;
&gt; I am leaning towards #1, but would like to hear of any better
&gt; recommendations.
&gt;
&gt; Thanks.
&gt;
&gt; [1]: http://basho.com/blog/technical/2012/05/25/Scaling-Riak-At-Kiip/
&gt; [2]: http://www.infoq.com/presentations/Case-Study-Riak-on-Drugs
&gt;
&gt;
&gt;
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

