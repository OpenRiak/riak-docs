---
title: "Re: Java client - conflict resolver on both fetch() and store()?"
description: ""
project: community
lastmod: 2013-08-11T19:54:28-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg11975"
mailinglist_parent_id: "msg11963"
author_name: "Matt Painter"
project_section: "mailinglistitem"
sent_date: 2013-08-11T19:54:28-07:00
---


Guys, thanks so much for your prompt and details responses. Much
appreciated. Re-engineering, here I come!

M


On 12 August 2013 05:11, Brian Roach  wrote:

&gt; Matt,
&gt;
&gt; The original design of StoreObject (which is what Bucket.store()
&gt; returns) was that it would encapsulate the entire read/modify/write
&gt; cycle in a very Java-y / enterprise-y way. This is why it takes a
&gt; Resolver and a Mutator; it does a fetch, resolves conflicts, passes
&gt; the resolved object to the Mutator, then stores the result of the
&gt; mutation to Riak.
&gt;
&gt; Several users put in requests to make the fetch/resolve portion of
&gt; that optional as they had a workflow where that wasn't ideal and
&gt; didn't wanted to store a previously fetched value without fetching it
&gt; again. This is why the 'withoutFetch()' method was introduced along
&gt; with the @RiakVClock annotation.
&gt;
&gt; When using withoutFetch() no fetch is performed, and no conflict
&gt; resolution occurs. Any ConflictResolver you pass in is simply not used
&gt; / ignored ... except possibly if you're using returnBody()
&gt;
&gt; Your code here:
&gt;
&gt;
&gt; bucket.store(record).returnBody(true).withoutFetch().withResolver(myConflictResolver);
&gt;
&gt; is not doing a fetch or conflict resolution before storing your data.
&gt; It's just storing `record` in Riak. If that POJO has a vclock from a
&gt; previous fetch available via a @RiakVClock annotated field it will be
&gt; used. Otherwise, you're doing a store without a vclock.
&gt;
&gt; I suspect where your confusion is stemming from is that you've also
&gt; specified 'returnBody()' and you're creating a sibling in that store
&gt; operation. When that's the case the "body" is going to be multiple
&gt; objects (all the siblings) which require resolution as
&gt; StoreObject.execute() only returns a single object back to the caller.
&gt; The same Resolver used if you had done the pre-fetch is employed. If
&gt; you haven't passed in a Resolver then the DefaultResolver is used
&gt; which ... isn't really a "resolver" - it simply passes through an
&gt; object if there's only one, or throws an exception if there's multiple
&gt; (siblings) present.
&gt;
&gt; Thanks,
&gt; - Roach
&gt;
&gt;
&gt;
&gt;
&gt; On Sun, Aug 11, 2013 at 5:41 AM, Guido Medina 
&gt; wrote:
&gt; &gt; Hi Matt,
&gt; &gt;
&gt; &gt; Like Sean said, you should have a mutator if you are dealing with
&gt; conflict
&gt; &gt; resolution in domain objects; a good side effect of using a mutator is
&gt; that
&gt; &gt; Riak Java client will fetch-modify-write so your conflict resolver will
&gt; be
&gt; &gt; called once(?), if you don't use mutators, you get the effect you are
&gt; &gt; describing(?) or in other words, you have to treat the operations as
&gt; &gt; non-atomic and do things twice.
&gt; &gt;
&gt; &gt; There are two interfaces for mutations: Mutation and
&gt; &gt; ConditionalStoreMutation, the 2nd interface will write only if the object
&gt; &gt; was actually mutated, you must return true or false to state if it was
&gt; &gt; mutated or not, which can be helpful if you are "mutating" an object and
&gt; you
&gt; &gt; discover the change you are requesting to make was already in place,
&gt; then to
&gt; &gt; save I/O, siblings creation and all implied on a write operation you
&gt; decide
&gt; &gt; not to write back.
&gt; &gt;
&gt; &gt; Mutation and conflict resolution are two separate concerns, but if you
&gt; &gt; specify a mutator and a conflict resolver, conflict resolution will
&gt; happen
&gt; &gt; after the object is fetched and it is ready to be modified, which will
&gt; &gt; emulate an atomic operation if you use a domain object.
&gt; &gt;
&gt; &gt; If you use a raw RiakObject, you must fetch, resolve the conflicts and on
&gt; &gt; the write operation pass the VClock which is not a trivial nor easy to
&gt; &gt; understand in code.
&gt; &gt;
&gt; &gt; HTH,
&gt; &gt;
&gt; &gt; Guido.
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt; On 11/08/13 03:32, Sean Cribbs wrote:
&gt; &gt;
&gt; &gt; I'm sure Roach will correct me if I'm off-base, but I believe the store
&gt; &gt; operation does a fetch and resolve before writing. I think the ideal way
&gt; to
&gt; &gt; do that is to create a Mutation (T being your POJO) as well, in which
&gt; &gt; case it's less of a "store" and more of a "fetch-modify-write". The way
&gt; to
&gt; &gt; skip the fetch/modify is to use the withoutFetch() option on the
&gt; operation
&gt; &gt; builder.
&gt; &gt;
&gt; &gt;
&gt; &gt; On Sat, Aug 10, 2013 at 6:50 PM, Matt Painter  wrote:
&gt; &gt;&gt;
&gt; &gt;&gt; Hi,
&gt; &gt;&gt;
&gt; &gt;&gt; I've just rolled up my sleeves and have started to make my application
&gt; &gt;&gt; more robust with conflict resolution.
&gt; &gt;&gt;
&gt; &gt;&gt; I am currently using a @RiakVClock in my POJO (I need to think more
&gt; about
&gt; &gt;&gt; whether the read/modify/write approach is preferable or whether I'd
&gt; have to
&gt; &gt;&gt; rearchitect things).
&gt; &gt;&gt;
&gt; &gt;&gt; I read in the Riak Handbook the recommendation that conflicts are best
&gt; &gt;&gt; resolved on read - not write - however the example App.java snipping
&gt; on the
&gt; &gt;&gt; Storing data in Riak page in the Java client's doco uses a resolver on
&gt; both
&gt; &gt;&gt; the store() and fetch() operations.
&gt; &gt;&gt;
&gt; &gt;&gt; Indeed, if I don't specify my conflict resolver in my store(), things
&gt; blow
&gt; &gt;&gt; up (in my unit test, mind - I'm still getting my head around the whole
&gt; area
&gt; &gt;&gt; so my test may be a bit contrived).
&gt; &gt;&gt;
&gt; &gt;&gt; However when I use it in both places, my conflicts are being resolved
&gt; &gt;&gt; twice. Is this anticipated?
&gt; &gt;&gt;
&gt; &gt;&gt; My store is:
&gt; &gt;&gt;
&gt; &gt;&gt;
&gt; &gt;&gt;
&gt; bucket.store(record).returnBody(true).withoutFetch().withResolver(myConflictResolver);
&gt; &gt;&gt;
&gt; &gt;&gt; and my fetch is:
&gt; &gt;&gt;
&gt; &gt;&gt; bucket.fetch(id,
&gt; Record.class).withResolver(myConflictResolver).execute();
&gt; &gt;&gt;
&gt; &gt;&gt; The order of operations in my test is:
&gt; &gt;&gt;
&gt; &gt;&gt; Store new record
&gt; &gt;&gt; Fetch the record as firstRecord
&gt; &gt;&gt; Fetch the record as secondRecord
&gt; &gt;&gt; Modify a field on firstRecord and secondRecord
&gt; &gt;&gt; Save firstRecord
&gt; &gt;&gt; Save secondRecord - this invokes my resolver with two siblings
&gt; &gt;&gt; Read record - this also invokes my resolver with the two siblings
&gt; &gt;&gt;
&gt; &gt;&gt; Am I missing something? Or is this what's supposed to happen? I'm not
&gt; too
&gt; &gt;&gt; worried - the double-handling is hardly that intensive - but I'm keen
&gt; to get
&gt; &gt;&gt; it right.
&gt; &gt;&gt;
&gt; &gt;&gt; Thanks in advance,
&gt; &gt;&gt; Matt
&gt; &gt;&gt;
&gt; &gt;&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; &gt;&gt; riak-users mailing list
&gt; &gt;&gt; riak-users@lists.basho.com
&gt; &gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt; &gt;&gt;
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt; --
&gt; &gt; Sean Cribbs 
&gt; &gt; Software Engineer
&gt; &gt; Basho Technologies, Inc.
&gt; &gt; http://basho.com/
&gt; &gt;
&gt; &gt;
&gt; &gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; &gt; riak-users mailing list
&gt; &gt; riak-users@lists.basho.com
&gt; &gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; &gt; riak-users mailing list
&gt; &gt; riak-users@lists.basho.com
&gt; &gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt; &gt;
&gt;



-- 
Matt Painter
m...@deity.co.nz
+64 21 115 9378
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

