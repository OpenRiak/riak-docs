---
title: "Re: On siblings"
description: ""
project: community
lastmod: 2013-05-15T07:24:59-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg11074"
mailinglist_parent_id: "msg11073"
author_name: "John Daily"
project_section: "mailinglistitem"
sent_date: 2013-05-15T07:24:59-07:00
---


Thanks for the kind words, Jeremiah.

Jeremy, if you find anything that's wrong with that description of sibling
behavior, please let me know. It's always possible I missed something
important.

-John

On Wednesday, May 15, 2013, Jeremiah Peschka wrote:

&gt; John Daily (@macintux) wrote a great blog post that covers sibling
&gt; behavior [1]
&gt;
&gt; In short, though, because you're supplying an older vector clock, and you
&gt; have allow\_mult turned on, Riak makes the decision that since a vector
&gt; clock is present that conflicts with what's already on disk a sibling
&gt; should be created.
&gt;
&gt; As I understand it, the only way to write into Riak and not get siblings
&gt; is to set allow\_mult to false - even leaving out vector clocks will lead to
&gt; siblings if allow\_mult is true. Or so John Daily's chart claims.
&gt;
&gt; [1]: http://basho.com/riaks-config-behaviors-part-2/
&gt;
&gt; ---
&gt; Jeremiah Peschka - Founder, Brent Ozar Unlimited
&gt; MCITP: SQL Server 2008, MVP
&gt; Cloudera Certified Developer for Apache Hadoop
&gt;
&gt;
&gt; On Tue, May 14, 2013 at 10:48 PM, Jeremy Ong 
&gt; 
&gt; &gt; wrote:
&gt;
&gt;&gt; To clarify, I am using the erlang client. From the looks of it, the
&gt;&gt; vector clock transition to the new value is opaque to the client so the
&gt;&gt; only way to streamline this use case is to pass the `return\_body` option
&gt;&gt; (My use case is one read, many subsequent writes while updating in memory).
&gt;&gt;
&gt;&gt; In this case however, I already have the value in memory, so it seems
&gt;&gt; inefficient to have to get the entire riakc\_obj back when I really just
&gt;&gt; need the metadata to construct the new object. Is this correct?
&gt;&gt;
&gt;&gt;
&gt;&gt; On Tue, May 14, 2013 at 9:06 PM, Jeremy Ong 
&gt;&gt; 
&gt;&gt; &gt; wrote:
&gt;&gt;
&gt;&gt;&gt; Suppose I have an object X.
&gt;&gt;&gt;
&gt;&gt;&gt; I make an update to X and store it as X1. I perform a put operation
&gt;&gt;&gt; using X1.
&gt;&gt;&gt;
&gt;&gt;&gt; The same client then makes a modification to X1 and stores it as X2.
&gt;&gt;&gt; Then, I perform a put operation using X2.
&gt;&gt;&gt;
&gt;&gt;&gt; This will create two siblings X1 and X2 if allow\_mult is true. Is there
&gt;&gt;&gt; any way I can avoid this? To me, the vector clock should have incremented
&gt;&gt;&gt; once when transitioning from X to X1, then once more when transitioning
&gt;&gt;&gt; from X1 to X2. This way, I shouldn't need to issue a get before I have to
&gt;&gt;&gt; perform another write since my data is already in memory.
&gt;&gt;&gt;
&gt;&gt;&gt; I probably am misunderstanding something about vector clocks. Does
&gt;&gt;&gt; anybody care to clarify this?
&gt;&gt;&gt;
&gt;&gt;&gt; Thanks,
&gt;&gt;&gt; Jeremy
&gt;&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com &gt; 'riak-users@lists.basho.com');&gt;
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;&gt;
&gt;&gt;
&gt;
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

