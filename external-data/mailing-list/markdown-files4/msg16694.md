---
title: "RE: Using Bucket Data Types slowed insert performance"
description: ""
project: community
lastmod: 2015-10-21T13:32:06-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg16694"
mailinglist_parent_id: "msg16680"
author_name: "Mark Schmidt"
project_section: "mailinglistitem"
sent_date: 2015-10-21T13:32:06-07:00
---




Hi Russell,

I think we were getting ahead of ourselves with our use of CRDTs within Riak
for this case, we're still very new to the platform so we're still climbing
the learning curve. 

We'll be maintaining a set schema of registers, so your comments below makes
a lot of sense. Based off of everyone's feedback and further research by our
dev's, we'll be dropping our use of Riak data types for this case.

However... From a general operations standpoint, I'm still curious why we
saw a drastic throughput performance hit when incorporating the use of
CRDTs. We're setting up some additional monitoring points and various
comparison tests to see if we can pinpoint the bottleneck.

I'll update everyone with our test scenarios and findings once we have
something to share.

Thank you all,

- Mark Schmidt



-----Original Message-----
From: Russell Brown [mailto:russell.br...@me.com] 
Sent: Wednesday, October 21, 2015 12:39 AM
To: Dennis Nicolay 
Cc: Christopher Mancini ; Mark Schmidt
; Alexander Sicular ; riak-users

Subject: Re: Using Bucket Data Types slowed insert performance

Honestly, right now we need to work on optimising the Map. We do have a
smaller/faster map in a branch that we're working on shipping soon, as well
as other optimisation planned.

Does your use case have you adding and removing registers, or is this
basically a set schema of registers per key? If you're not
removing/re-adding registers, I would use a CRDT not in Riak, but in your
application.

CRDTs in Riak make sense for causal data types: where the actor management
is onerous for the client. What you're modelling using the map looks like
Last Write Wins element Set. This is a pretty simple CRDT to make in your
own programming language/application, and you can write this data type
yourself, and simply store the binary representation of it in riak, using
riak's siblings (allow\_mult=true.) hen your application gets siblings
values, simply run you application code's merge function.

There are details of the last write elements set here
https://github.com/soundcloud/roshi, but all you need to is store a pair
(element, TS) for each member in the set. If you're going to store removing
registers it gets more complex.are you?

Cheers

Russell

On 20 Oct 2015, at 20:25, Dennis Nicolay  wrote:

&gt; 
&gt; ResultObject cdr;
&gt; while (queued.TryDequeue(out cdr))
&gt; {
&gt; long beforeProcessing = DateTime.Now.Ticks;
&gt; UpdateMap.Builder builder = BuildMapObject(bucket,
cdr);
&gt; UpdateMap cmd = builder.Build();
&gt; RiakResult rslt = client.Execute(cmd);
&gt; 
&gt; 
&gt; 
&gt; 
&gt; private static UpdateMap.Builder BuildMapObject(string bucketname,
ResultObject cdr )
&gt; {
&gt; 
&gt; var builder = new UpdateMap.Builder()
&gt; .WithBucketType("maps")
&gt; .WithBucket(bucketname)
&gt; .WithKey(cdr.CdrKey); 
&gt; var mapOperation = new UpdateMap.MapOperation();
&gt; mapOperation.SetRegister("FileTimeStamp",
cdr.CdrValue.FileTimeStamp.ToString());
&gt; mapOperation.SetRegister("AuditId",
cdr.CdrValue.AuditId.ToString());
&gt; mapOperation.SetRegister("CdrId",
cdr.CdrValue.CdrId.ToString());
&gt; mapOperation.SetRegister("IsBillable",
cdr.CdrValue.IsBillable.ToString());
&gt; mapOperation.SetRegister("SwitchId",
cdr.CdrValue.SwitchId.ToString());
&gt; mapOperation.SetRegister("SwitchDescription",
cdr.CdrValue.SwitchDescription.ToString());
&gt; mapOperation.SetRegister("SequenceNumber",
cdr.CdrValue.SequenceNumber.ToString());
&gt; mapOperation.SetRegister("CallDirection",
cdr.CdrValue.CallDirection.ToString());
&gt; mapOperation.SetRegister("CallTypeId",
cdr.CdrValue.CallTypeId.ToString());
&gt; mapOperation.SetRegister("Partition",
cdr.CdrValue.Partition.ToString());
&gt; mapOperation.SetRegister("CustomerTrunkId",
cdr.CdrValue.CustomerTrunkId.ToString());
&gt; mapOperation.SetRegister("OrigIpAddress",
cdr.CdrValue.OrigIpAddress.ToString());
&gt; mapOperation.SetRegister("OrigPort",
cdr.CdrValue.OrigPort.ToString());
&gt; mapOperation.SetRegister("SupplierTrunkId",
cdr.CdrValue.SupplierTrunkId.ToString());
&gt; mapOperation.SetRegister("TermIpAddress",
cdr.CdrValue.TermIpAddress.ToString());
&gt; mapOperation.SetRegister("TermPort",
cdr.CdrValue.TermPort.ToString());
&gt; mapOperation.SetRegister("Ani", cdr.CdrValue.Ani.ToString());
&gt; mapOperation.SetRegister("OutpulseNumber",
cdr.CdrValue.OutpulseNumber.ToString());
&gt; mapOperation.SetRegister("SubscriberNumber",
cdr.CdrValue.SupplierTrunkId.ToString());
&gt; mapOperation.SetRegister("CallingNoa",
cdr.CdrValue.CallingNoa.ToString());
&gt; mapOperation.SetRegister("DialedNoa",
cdr.CdrValue.DialedNoa.ToString());
&gt; mapOperation.SetRegister("OutpulseNoa",
cdr.CdrValue.OutpulseNumber.ToString());
&gt; mapOperation.SetRegister("TreatmentCode",
cdr.CdrValue.TreatmentCode.ToString());
&gt; mapOperation.SetRegister("CompletionCode",
cdr.CdrValue.CompletionCode.ToString());
&gt; mapOperation.SetRegister("CustomerName",
cdr.CdrValue.CustomerName.ToString());
&gt; mapOperation.SetRegister("CustId",
cdr.CdrValue.CustId.ToString());
&gt; mapOperation.SetRegister("CustContractId",
cdr.CdrValue.CustContractId.ToString());
&gt; mapOperation.SetRegister("CustCountryCode",
cdr.CdrValue.CustCountryCode.ToString());
&gt; mapOperation.SetRegister("CustDuration",
cdr.CdrValue.CustDuration.ToString());
&gt; mapOperation.SetRegister("Price",
cdr.CdrValue.Price.ToString());
&gt; mapOperation.SetRegister("BasePrice",
cdr.CdrValue.BasePrice.ToString());
&gt; mapOperation.SetRegister("BillingDestinationName",
cdr.CdrValue.BillingDestinationName.ToString());
&gt; mapOperation.SetRegister("BillingGroupId",
cdr.CdrValue.BillingGroupId.ToString());
&gt; mapOperation.SetRegister("SupplierName",
cdr.CdrValue.SupplierName.ToString());
&gt; mapOperation.SetRegister("SuppId",
cdr.CdrValue.SuppId.ToString());
&gt; mapOperation.SetRegister("SuppContractId",
cdr.CdrValue.SuppContractId.ToString());
&gt; mapOperation.SetRegister("SuppCountryCode",
cdr.CdrValue.SuppCountryCode.ToString());
&gt; mapOperation.SetRegister("SuppDuration",
cdr.CdrValue.SuppDuration.ToString());
&gt; mapOperation.SetRegister("Cost",
cdr.CdrValue.Cost.ToString());
&gt; mapOperation.SetRegister("BaseCost",
cdr.CdrValue.BaseCost.ToString());
&gt; mapOperation.SetRegister("RoutingDestinationName",
cdr.CdrValue.RoutingDestinationName.ToString());
&gt; mapOperation.SetRegister("RoutingGroupId",
cdr.CdrValue.RoutingGroupId.ToString());
&gt; mapOperation.SetRegister("RouteToCountryCode",
cdr.CdrValue.RouteToCountryCode.ToString());
&gt; mapOperation.SetRegister("Pdd", cdr.CdrValue.Pdd.ToString());
&gt; mapOperation.SetRegister("RealDuration",
cdr.CdrValue.RealDuration.ToString());
&gt; mapOperation.SetRegister("StartTime",
cdr.CdrValue.StartTime.ToString());
&gt; mapOperation.SetRegister("EndTime",
cdr.CdrValue.EndTime.ToString());
&gt; mapOperation.SetRegister("NumberCalled",
cdr.CdrValue.NumberCalled.ToString());
&gt; mapOperation.SetRegister("CallingLataOcn",
cdr.CdrValue.CallingLataOcn.ToString());
&gt; mapOperation.SetRegister("DialedLataOcn",
cdr.CdrValue.DialedLataOcn.ToString());
&gt; mapOperation.SetRegister("LrnLataOcn",
cdr.CdrValue.LrnLataOcn.ToString());
&gt; mapOperation.SetRegister("CustomerPrefix",
cdr.CdrValue.CustomerPrefix.ToString());
&gt; mapOperation.SetRegister("SupplierPrefix",
cdr.CdrValue.SupplierPrefix.ToString());
&gt; mapOperation.SetRegister("OriginationCountryCode",
cdr.CdrValue.OriginationCountryCode.ToString());
&gt; mapOperation.SetRegister("OriginationCost",
cdr.CdrValue.OriginationCost.ToString());
&gt; mapOperation.SetRegister("FixedPricePerCall",
cdr.CdrValue.FixedPricePerCall.ToString());
&gt; mapOperation.SetRegister("FixedCostPerCall",
cdr.CdrValue.FixedCostPerCall.ToString());
&gt; mapOperation.SetRegister("InvoiceId",
cdr.CdrValue.InvoiceId.ToString());
&gt; mapOperation.SetRegister("BusinessId",
cdr.CdrValue.BusinessId.ToString());
&gt; 
&gt; builder.WithMapOperation(mapOperation);
&gt; return builder;
&gt; }
&gt; 
&gt; 
&gt; From: Christopher Mancini [mailto:cmanc...@basho.com] 
&gt; Sent: Tuesday, October 20, 2015 11:52 AM
&gt; To: Mark Schmidt; Alexander Sicular; Dennis Nicolay
&gt; Cc: riak-users@lists.basho.com
&gt; Subject: Re: Using Bucket Data Types slowed insert performance
&gt; 
&gt; Hi Mark / Dennis,
&gt; 
&gt; Can you provide the snippet of the code that puts a 5k record onto Riak as
a map?
&gt; 
&gt; Chris
&gt; 
&gt; On Tue, Oct 20, 2015 at 11:30 AM Mark Schmidt 
wrote:
&gt; Hi folks, sorry for the confusion.
&gt; 
&gt; Our scenario is as follows:
&gt; 
&gt; We have a 6 node development cluster running on its own network segment
using HAProxy to facilitate load-balancing across the nodes. A single
Riak-dot-NET client service is performing the insert operations from
dedicated hardware located within the same network segment. We have basic
network throughput capabilities of 100 Mbit with an average speed achievable
of 75 Mbit.
&gt; 
&gt; The data we are attempting to insert is composed of phone call record
receipts from telephone carriers. These records are batched and written to a
flat file for incorporation into our reporting engine. 1) Our Riak client
process takes a flat file (In this case, a 40MB collection of records, each
record being approximately 5k in size) and parses the entire file so each
record can be added to a local .NET queue.
&gt; 2) Once the entire file has been parsed and each record loaded into the
local queue, 20 threads are spawned and connections are opened to our Riak
nodes via the HAProxy.
&gt; 3) Each thread will pull a 5k record from the queue on a first come first
served basis and perform a put to the Riak environment.
&gt; 
&gt; When first testing our client insert process, we were pushing the 5K
records as whole strings into the Riak environment. Network throughput
topped out at around 80 Mbits with a total load time of 90 seconds for 149k
records. When the client process was modified (same queuing and de-queuing
methods) so that a map datatype bucket would be created and keys stored as
registers, we saw network throughput drop to around 10 Mbit with total
upload time increase to around 270 seconds for the 149k records. 
&gt; 
&gt; It appears as though we've either encountered a potential bottleneck
unrelated to network throughput, or we're just seeing an expected processing
penalty for our use of Riak datatypes. Please note, we're configuring Zabbix
so we can monitor disk IO on each node as processor and memory resources
don't appear to be the culprit either.
&gt; 
&gt; If the reduction in processing speed is a natural consequence to utilizing
Riak data types, is the inter-node network the optimum place to increase
resources? Our eventual datacenter implementation will support speeds of
over 40 Gbit for inter-node communication. We're just trying to identify
which levers from an operational standpoint we can throw to boost
performance, or if our client implementation is suspect.
&gt; 
&gt; You bring up some excellent points regarding our use of CRDTs. In our
case, the call data records are mutable as they are subject to changes by
phone carriers for billing error corrections, incorrect data and a host of
other reasons. We may be better served by treating the records as immutable
and performing wide scale record removal and "reprocessing" in the event
changes to existing records are received/requested.
&gt; 
&gt; Thank you,
&gt; 
&gt; Mark Schmidt
&gt; 
&gt; From: Alexander Sicular [mailto:sicul...@gmail.com] 
&gt; Sent: Tuesday, October 20, 2015 10:55 AM
&gt; To: Dennis Nicolay 
&gt; Cc: Christopher Mancini ; riak-users@lists.basho.com;
Mark Schmidt 
&gt; 
&gt; Subject: Re: Using Bucket Data Types slowed insert performance
&gt; 
&gt; Let's talk about Riak data types for a moment. Riak data types are
collectively implementations of what academia refer to as CRDT's (convergent
or conflict free replicated data types.) The key benefit a CRDT offers, over
a traditional KV by contrast, is in automatic conflict resolution. The
various CRDT's provided in Riak have specific conflict resolution
strategies. This does not come for free. There is a computational cost
associated with CRDT's. If your use case requires automated conflict
resolution strategies than CRDT's are a good fit. Internally CRDT's rely on
vector clocks (see DVV's in the documentation) to resolve conflict. 
&gt; 
&gt; Considering your ETL use case I'm going to presume that your data is
immutable (I could very well be wrong here.) If your data is immutable I
would consider simply using a KV and not paying the CRDT computational
penalty (and possibly even the write once bucket.) The CRDT penalty you pay
is obviously subjective to your use case, configuration, hw deployment etc. 
&gt; 
&gt; Hope that helps!
&gt; -Alexander 
&gt; 
&gt; 
&gt; @siculars
&gt; http://siculars.posthaven.com
&gt; 
&gt; Sent from my iRotaryPhone
&gt; 
&gt; On Oct 20, 2015, at 12:39, Dennis Nicolay  wrote:
&gt; 
&gt; Hi Alexander,
&gt; 
&gt; I'm parsing the file and storing each row with own key in a map datatype
bucket and each column is a register. 
&gt; 
&gt; Thanks,
&gt; Dennis
&gt; 
&gt; From: Alexander Sicular [mailto:sicul...@gmail.com] 
&gt; Sent: Tuesday, October 20, 2015 10:34 AM
&gt; To: Dennis Nicolay
&gt; Cc: Christopher Mancini; riak-users@lists.basho.com
&gt; Subject: Re: Using Bucket Data Types slowed insert performance
&gt; 
&gt; Hi Dennis,
&gt; 
&gt; It's a bit unclear what you are trying to do here. Are you 1. uploading
the entire file and saving it to one key with the value being the file? Or
are you 2. parsing the file and storing each row as a register in a map? 
&gt; 
&gt; Either of those approaches are not appropriate in Riak KV. For the first
case I would point you to Riak S2 which is designed to manage large binary
object storage. You can keep the large file as a single addressable entity
and access it via Amazon S3 or Swift protocol. For the second case I would
consider maintaining one key (map) per row in the file and have a register
per column in the row. Or not use Riak data types (maps, sets, registers,
flags and counters) and simply keep each row in the file as a KV in Riak
either as a raw string or as a serialized json string. ETL'ing out of
relational databases and into Riak is a very common use case and often
implemented in the fashion I described. 
&gt; 
&gt; As Chris mentioned, soft upper bound on value size should be 1MB. I say
soft because we won't enforce it although there are settings in the config
that can be changed to enforce it (default 5MB warning, 50MB reject I
believe.) 
&gt; 
&gt; Best,
&gt; Alexander
&gt; 
&gt; 
&gt; 
&gt; @siculars
&gt; http://siculars.posthaven.com
&gt; 
&gt; Sent from my iRotaryPhone
&gt; 
&gt; On Oct 20, 2015, at 10:22, Christopher Mancini  wrote:
&gt; 
&gt; Hi Dennis,
&gt; 
&gt; I am not the most experienced, but what I do know is that a file that size
causes a great deal of network chatter because it has to handoff that data
to the other nodes in the network and will cause delays in Riak's ability to
send and confirm consistency across the ring. Typically we recommend that
you try to structure your objects to around 1mb or less to ensure consistent
performance. That max object size can vary of course based on your network /
server specs and configuration.
&gt; 
&gt; I hope this helps.
&gt; 
&gt; Chris
&gt; 
&gt; On Tue, Oct 20, 2015 at 8:18 AM Dennis Nicolay 
wrote:
&gt; Hi,
&gt; 
&gt; I'm using .net RiakClient 2.0 to insert a 44mb delimited file with 139k
rows of data into riak. I switched to a map bucket data type with
registers. It is taking about 3 times longer to insert into this bucket vs
non data typed bucket. Any suggestions?
&gt; 
&gt; Thanks in advance,
&gt; Dennis
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com


\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

