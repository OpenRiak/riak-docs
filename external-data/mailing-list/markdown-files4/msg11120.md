---
title: "Re: Java client and siblings question"
description: ""
project: community
lastmod: 2013-05-20T09:34:17-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg11120"
mailinglist_parent_id: "msg11119"
author_name: "Y N"
project_section: "mailinglistitem"
sent_date: 2013-05-20T09:34:17-07:00
---


Hi Brian,

Thanks for the response. 

I am not using the default JSONConverter, but have my own. The way I am 
currently resolving siblings is as follows:

Create a new object
Merge fields (using whatever logic)
Return new object with merged fields

In this case, what should I use for the vclock for the newly created object 
that was resolved? Do I randomly pick from one of the objects being resolved, 
or is there some order or precedence I should use?

On a side note, I am not sure if you are responsible for the Riak Java client. 
If so, I don't see an option to allow me to use my own converter for objects 
obtained via a MapReduce query (through the Java client). Is this feature 
currently available, or is this something that will be added at some point?

A .withConverter(blah) would be nice for mapreduce queries as well.

Thanks!



\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
 From: Brian Roach 
To: Y N  
Cc: "riak-users@lists.basho.com"  
Sent: Monday, May 20, 2013 7:42 AM
Subject: Re: Java client and siblings question
 

Hello!

When you do your fetch (read) and resolve any conflicts, you're going
to get a vector clock along with each sibling. If you're using the
default JSONConverter it will be stored in your POJO's @RiakVClock
annotated field. That's the vector clock you're going to use when you
do your store (write) later - the modified object you're passing to
Bucket.store() should contain it.

The withoutFetch() option simply allows you to break this into two
separate actions. Without it, when you called StoreObject.execute()
that's exactly what would be happening.

Thanks!
- Roach

On Sat, Apr 27, 2013 at 5:35 PM, Y N  wrote:
&gt; Hi,
&gt;
&gt; I am currently using the latest java client, and I have a question regarding
&gt; updating data in a bucket where siblings are allowed (i.e. allowSiblings =
&gt; true).
&gt;
&gt; I finally understand the whole read-resolve-mutate-write cycle, and also
&gt; doing an update / store using previously fetched data (i.e. not in the same
&gt; "transaction").
&gt;
&gt; This question is regarding the latter case (updating previously fetched
&gt; data). My read uses a resolver. My data class has a @RiakVClock field
&gt; defined.
&gt;
&gt; The problem is when I do the store(blah).withoutFetch(). It seems to be
&gt; generating siblings. I just realized that's probably because my resolver
&gt; (during the read) is creating a new object and then merging then siblings
&gt; into the new object, however it's not setting the vclock field.
&gt;
&gt; My question is, during the read resolve stage, what should I use for the
&gt; vlock? Should I just copy it from one of the other siblings, or is there
&gt; some specific sort order I should use to pick a particular vlock for the new
&gt; object?
&gt;
&gt; Thanks.
&gt;
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

