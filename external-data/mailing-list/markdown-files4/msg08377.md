---
title: "Re: Schema design - version history and time travel"
description: ""
project: community
lastmod: 2012-08-28T02:47:14-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg08377"
mailinglist_parent_id: "msg08374"
author_name: "Patrik Sundberg"
project_section: "mailinglistitem"
sent_date: 2012-08-28T02:47:14-07:00
---


On Tue, Aug 28, 2012 at 7:11 AM, Mark Phillips  wrote:

&gt; Hi Patrik,
&gt;
&gt; Sorry for the late response here.
&gt;
&gt; On Fri, Aug 17, 2012 at 9:37 AM, Patrik Sundberg
&gt;  wrote:
&gt; &gt; Hi,
&gt; &gt;
&gt; &gt; I'll simplify the case to something easier to follow. The typical
&gt; question I
&gt; &gt; have is: find piece of data X as of time Y. A piece of data X has a start
&gt; &gt; time and end time, can think of as positive integers (that I could have
&gt; 2i
&gt; &gt; indices for). I'm trying to find the version of X whose start and end
&gt; time
&gt; &gt; integer range includes the integer Y.
&gt; &gt;
&gt; &gt; I don't see how I make the query with 2i, and doing it via Search seems
&gt; &gt; wrong since don't need the overhead of converting to text etc. Do I need
&gt; to
&gt; &gt; do a 2step procedure where I get all the possible X versions (think
&gt; &gt; intervals) via a 2i query (I can organize that easily), then a map
&gt; reduce on
&gt; &gt; those results to find the right interval covering Y? The number of
&gt; versions
&gt; &gt; for the map reduce will typically be in the range of 10s to 1000s at the
&gt; &gt; maximum, not more.
&gt; &gt;
&gt;
&gt; My initial thoughts (based on a quick reading of this email) is that a
&gt; 2i range query that feeds the resulting keys to a M/R job [0] would do
&gt; the trick.
&gt;
&gt;
I came to same conclusion for the design where each version is a different
key. I may go with a single key for all versions design though, see below.


&gt; What type of response times are you looking for with these queries?
&gt; When you say "The number of versions for the map reduce will typically
&gt; be in the range of 10s to 1000s at the maximum" do you mean that the
&gt; total number of keys you'll be map-reduce'ing over will be in the 10s
&gt; to 1000s range? Or the result set you'll be producing with that M/R
&gt; job will be on the order of that?
&gt;
&gt;
I meant that for object with ID X, there will be 10s to 1000s version of
that object over time. So 2i result would be 10s to 1000s and it'd be 10s
to 1000s inputs to M/R, with just 1 result.

Response times are not my main concern, I doubt they can be too bad unless
I mess up completely to become huge M/R jobs for everything. Ease of use
and low complexity scoring higher for time being.

However, I'm now thinking that including all versions in the value for a
single key is the way to go for me, will be easier and estimating I don't
think values will become too big. And I can add in some archiving if it
becomes apparent that I need to later. Since ordered by time I've got the
natural archiving by time where far back data will be used less often so
the hit of double dispatch to trawl archives not that important. Include
all those 10s to 1000s version of the object with ID X in one value, hold
the version sorted by time and have an easy way to find the right version
in application logic.

Thanks for the input!


&gt; Hope that helps.
&gt;
&gt; Mark
&gt; ricon2012.com
&gt;
&gt; [0] All the way at the bottom of this ---&gt;
&gt;
&gt; http://wiki.basho.com/Secondary-Indexes---Configuration-and-Examples.html#Index-Lookups
&gt;
&gt; &gt; Any input would be great!
&gt; &gt;
&gt; &gt; On Wed, Aug 15, 2012 at 11:54 AM, Patrik Sundberg
&gt; &gt;  wrote:
&gt; &gt;&gt;
&gt; &gt;&gt; Hi,
&gt; &gt;&gt;
&gt; &gt;&gt; I have a domain where I want to be able to "time travel". I don't have
&gt; &gt;&gt; many of updates (many more reads), but when there is an update I need to
&gt; &gt;&gt; preserve history and create new versions. Setting my local "application
&gt; &gt;&gt; time" determines which version of a particular piece of data is
&gt; fetched, and
&gt; &gt;&gt; I can go back in time and recreate how things looked previously. One
&gt; can't
&gt; &gt;&gt; change the past, just create new versions in the "future" relative to
&gt; last
&gt; &gt;&gt; version. Using a model of "starting point + replaying deltas" to get to
&gt; a
&gt; &gt;&gt; given time is not a good idea, it's an ever evolving state where
&gt; snapshots
&gt; &gt;&gt; are cheap enough to store and reduces complexity a lot.
&gt; &gt;&gt;
&gt; &gt;&gt; My domain objects are in the order of a couple of hundred types, each
&gt; type
&gt; &gt;&gt; having some pure data properties (10s, up to hundreds, easily
&gt; represented as
&gt; &gt;&gt; JSON blobs) and in the order of tens, maximum hundreds of has\_one and
&gt; &gt;&gt; has\_many type relationships to other objects (which can be of different
&gt; &gt;&gt; type). The relationships only require one direction, always from parent
&gt; to
&gt; &gt;&gt; child (sourced to destination). An object has a given unique ID, and a
&gt; &gt;&gt; version of that object has a given unique valid time period (with the
&gt; latest
&gt; &gt;&gt; version having an implicit "infinity" end of period).
&gt; &gt;&gt;
&gt; &gt;&gt; The queries are mostly to find a data property or a relationship for a
&gt; &gt;&gt; given object. A few special cases may be for range queries and exact
&gt; queries
&gt; &gt;&gt; on properties, easily taken care of by 2i queries.
&gt; &gt;&gt;
&gt; &gt;&gt; I'm trying to think of if and how my domain would be fitted into a riak
&gt; &gt;&gt; "schema". My hunch of starting point:
&gt; &gt;&gt; - map object types to buckets
&gt; &gt;&gt; - make the unique object IDs the keys in the bucket to represent the
&gt; &gt;&gt; concept of that object
&gt; &gt;&gt; - not sure how to represent the links to versions of that particular
&gt; &gt;&gt; object
&gt; &gt;&gt; - the versions themselves may be either in the same bucket or in a
&gt; another
&gt; &gt;&gt; bucket (think "cars" and "car-versions" or using "cars" for both)
&gt; &gt;&gt; - a version has a JSON value with its properties, some 2i for any
&gt; possible
&gt; &gt;&gt; exact and range queries I need
&gt; &gt;&gt; - the has\_one and has\_many links i could do in several ways. first
&gt; &gt;&gt; decision is if to point them to the object identity or directly to a
&gt; &gt;&gt; specific version. then can use Link, can use 2i, can store IDs in the
&gt; JSON
&gt; &gt;&gt; and do a 2 query fetch to get there
&gt; &gt;&gt; - 99% of read operations are of the type "given the time of X, give me
&gt; the
&gt; &gt;&gt; property or relation Y of object with ID Z"
&gt; &gt;&gt;
&gt; &gt;&gt; Anyone having built something similar with a time snapshot/version angle
&gt; &gt;&gt; with experience to share? Any input in general appreciated.
&gt; &gt;&gt;
&gt; &gt;&gt; Thanks,
&gt; &gt;&gt; Patrik
&gt; &gt;&gt;
&gt; &gt;
&gt; &gt;
&gt; &gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; &gt; riak-users mailing list
&gt; &gt; riak-users@lists.basho.com
&gt; &gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt; &gt;
&gt;
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

