---
title: "Re: Question: Object Not Saved After Save/Delete/Save"
description: ""
project: community
lastmod: 2011-06-03T15:08:30-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg03547"
mailinglist_parent_id: "msg03546"
author_name: "Keith Bennett"
project_section: "mailinglistitem"
sent_date: 2011-06-03T15:08:30-07:00
---


Aphyr & Andrew -

Thanks for your responses. I'm trying to wrap my head around the issues you 
raised, and I must confess it's difficult. Anyway, some questions for you...

On Jun 3, 2011, at 5:12 PM, Andrew Thompson wrote:

&gt; On Fri, Jun 03, 2011 at 02:00:23PM -0700, Aphyr wrote:
&gt;&gt; Riak can't use the vclock for conflict resolution on a fresh object,
&gt;&gt; i.e. one without a vclock. Deletes are writes. You should use get or
&gt;&gt; reload before writing to help Riak sequence your writes correctly.

If the caller doesn't have a handle to the RObject in the Ruby framework, or 
the metadata of an HTTP response, but is only accessing the data by bucket and 
key values, is there any way to use reload? And if the object has been deleted 
is there any way to use get?

&gt;&gt; 
&gt;&gt; On top of this, Riak has some weirdness around very quick sequences
&gt;&gt; of deletes/writes due, IIRC, to deletes not being tagged with a
&gt;&gt; vector clock. I... think... this will be addressed in an upcoming
&gt;&gt; release.

I tried inserting a 20 second pause between each read/write, but there was no 
change in the behavior. Should it be longer than that?

&gt;&gt; 
&gt; 
&gt; Ah, my favorite bug. This is indeed mostly solved on master by exposing
&gt; the vclocks for tombstones so they can be cleanly overwritten by the new
&gt; object rather than merged into a frankenobject that has the metadata of
&gt; the tombstone but the value of the new object (which is then subject to
&gt; real deletion).
&gt; 
&gt; So the fix for the issue was to add a new type of return value for a get
&gt; that finds a tombstone, {error, {deleted, Vclock}} instead of always
&gt; returning {error, notfound} on a true notfound or when a tombstone is
&gt; encountered.
&gt; 

That sounds like exactly what I need. Can I simulate that fix in my Ruby code? 
 Any pointers about that? Any chance we could get that into the Ruby client? 
I'd be willing to put a little effort into that, but I don't really understand 
the issues well enough yet.


&gt; An example of how to safely delete for all 3 APIs can be found at
&gt; 
&gt; https://gist.github.com/965376
&gt; 
&gt; Note the new deletedvclock option. The REST API will always use this
&gt; option on gets and will return a X-Riak-Vclock header along with any 404
&gt; that is actually a tombstone.
&gt; 
&gt; Some further reading can be found here:
&gt; 
&gt; https://issues.basho.com/show\_bug.cgi?id=260
&gt; https://issues.basho.com/show\_bug.cgi?id=555
&gt; 
&gt; So, long story short; either upgrade to master and use the deletedvclock
&gt; option or avoid doing rapid put/delete/put cycles.

You're suggesting I use mercurial to pull down the HEAD and use that, right?

Thanks again,
Keith


\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

