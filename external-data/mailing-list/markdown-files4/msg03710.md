---
title: "Re: Problem with deleting keys"
description: ""
project: community
lastmod: 2011-06-16T08:54:45-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg03710"
mailinglist_parent_id: "msg03709"
author_name: "Andrew Thompson"
project_section: "mailinglistitem"
sent_date: 2011-06-16T08:54:45-07:00
---


On Thu, Jun 16, 2011 at 08:40:45AM -0700, Greg Nelson wrote:
&gt; Well, it is kind of Riak specific. An implementation that treated DELETEs 
&gt; like PUTs (tombstones w/ vector clocks for ordering), then this would not be 
&gt; an issue, right? When no primary nodes are down, the tombstones can be 
&gt; physically deleted on the backend. A logical delete could never reappear if 
&gt; that were how it worked.
&gt; 
&gt; Is this essentially what is on the current master branch (not yet released)?
&gt; 

Yes, this is essentially how its supposed to work on master. A tombstone
is put and then an async get is fired off and if the async get finds all
the primary nodes in the preflist are up, it does the delete. If not,
the next time the key is fetched, it does the same check again and will
do the delete then if the downed node is up.

Some issues still remain with this however, specifically how to override
tombstones (since notfounds do not include a vector clock). I've also
added a 'deletedvclock' GET option to change the return behaviour for
when a tombstone is found to instead return {deleted, VClock} so you can
safely override a tombstone, instead of triggering a merge (or creating
siblings).

This isn't perfect and we're discussing better solutions, but it does
make things significantly better.

Andrew

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

