---
title: "Re: short length hash key generation for riak keys?"
description: ""
project: community
lastmod: 2013-09-30T11:30:45-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg12439"
mailinglist_parent_id: "msg12438"
author_name: "Jeremiah Peschka"
project_section: "mailinglistitem"
sent_date: 2013-09-30T11:30:45-07:00
---


Howdy Alex!

It's not ludicrous at all since changes in Riak 2.0 should reduce that
overhead to about 13 bytes per key, IIRC.

In these situations, you could always use an external identity generation
process. Here's where I plug Rustflakes [1] which can generate unsigned
64-bit, decimal, or BigInteger numbers based on a combination of time since
an epoch, a machine identifier, and an internally cycling identifier that
resets every millisecond.

I can't lay claim to the idea, but I can lay claim to writing parts of it
in C#.

[1]: https://github.com/peschkaj/rustflakes

---
Jeremiah Peschka - Founder, Brent Ozar Unlimited
MCITP: SQL Server 2008, MVP
Cloudera Certified Developer for Apache Hadoop


On Mon, Sep 30, 2013 at 11:25 AM, Alex Rice  wrote:

&gt; Although with 40 bytes per key overhead, which I just read about,
&gt; perhaps this is somewhat of a ridiculous optimization for me to be
&gt; attempting to shorten the key size ? :)
&gt;
&gt; On Mon, Sep 30, 2013 at 12:20 PM, Alex Rice  wrote:
&gt; &gt; Hi all, coming from a traditional database background of course my
&gt; &gt; first tendency was wanting to auto\_increment a primary key somewhere.
&gt; &gt; Not possible with Riak, obviously! :)
&gt; &gt;
&gt; &gt; I was wondering if anyone has a good link or white paper about short
&gt; &gt; length hash key creation. I want to keep my keys short to save memory
&gt; &gt; with bitcask storage. (using super low-end commodity hardware with
&gt; &gt; limited RAM)
&gt; &gt;
&gt; &gt; One method that seems like it would be OK: just to use some
&gt; &gt; unique/random SHA function on the client side, and then take the first
&gt; &gt; few characters from the start of the string
&gt; &gt;
&gt; &gt; SHA output = 55ca6286e3e4f4fba5d0448333fa99fc5a404a73
&gt; &gt;
&gt; &gt; check if 55ca key exists -&gt; (not exist) -&gt; use it
&gt; &gt; -&gt; exist -&gt; check 55ca6 -&gt; (not exist) -&gt; use it
&gt; &gt; -&gt; exist -&gt; check 55ca62 -&gt; (not exist) -&gt; use it
&gt; &gt; -&gt; exist -&gt; check 55ca62 -&gt; (not exist) -&gt; use it
&gt; &gt; -&gt; exist -&gt; check 55ca628 -&gt; (not exist) -&gt; use it
&gt; &gt; -&gt; exist -&gt; check 55ca6286 -&gt; (not exist) -&gt; use it
&gt; &gt; -&gt; exist -&gt; check 55ca6286e -&gt; (not exist) -&gt; use it
&gt; &gt; -&gt; etc...
&gt; &gt;
&gt; &gt; But that could involve a lot of back and forth with the server as the
&gt; &gt; key space gets used up...
&gt; &gt; So I thought I would ask on here if there are any nifty ways of
&gt; &gt; generating \*short\* keys for Riak! Using C# btw, not that it matters :0
&gt; &gt;
&gt; &gt; Sorry if this is a FAQ I didnt see it on the website :)
&gt; &gt;
&gt; &gt; Thanks,
&gt; &gt; Alex
&gt;
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

