---
title: "Re: Constant vnode crashes after disk corruption"
description: ""
project: community
lastmod: 2012-04-19T03:31:05-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg07231"
mailinglist_parent_id: "msg07222"
author_name: "Nico Meyer"
project_section: "mailinglistitem"
sent_date: 2012-04-19T03:31:05-07:00
---



Hi Bogunov!

Simple truncation of the bitcask files won't trigger this error, since 
bitcask will notice that the last written entry is truncated and ignore 
it. In this case a 'not found' is returned to the layer above bitcask. 
If on the other hand, an entry (not necessarily the last one written) 
has the right length but the checksum that bitcask writes with each 
entry does not match this error is returned as such. The layer above 
bitcask (riak\_kv\_vnode) doesn't handle this case, and therefore chrashes.
Of course a checksum error in the middle of the file means the file is 
corrupted. But if the only way to resolve the problem, is to delete the 
whole file, bitcask might a well pretend the key was not found (an maybe 
delete it internally). That way at least the rest of the file might be 
still usable.


I think what happend in my case, is that the file had the right length 
to fully contain the last entry, but the data was not fully written. 
This is what you get and rightly deserve for using ext4 as the 
filesystem :-(.


But still I would think chrashing the vnode if the bitcask files are 
corrupted is always the wrong behaviour. At the very least an error 
should be returned to the node performing the get, to fail fast in the 
case where R is set to N. Otherwise the request hangs until the timeout 
is reached, wich is 60 second by default.


Cheers,
Nico

Am 19.04.2012 11:19, schrieb Bogunov:
Actually you get same error if you try to copy bitcask directory while 
writing in it, so i assume any not completely-written bitcask file can 
cause it. Easy way looks like dropping bitcask directory .


On Wed, Apr 18, 2012 at 2:26 PM, Nico Meyer &gt; wrote:


 Oh, I forgot to mention:

 My workaround was to patch riak\_kv\_bitcask\_backend to map all
 errors to {error,not\_found}. Which begs the question if the
 'get/3' function of any backend should ever return anything other than
 {ok, Value, State} and {error, not\_found, State} if it isn't
 handled by riak\_kv\_vnode.

 BTW: I think the -spec() for get/3 is wrong both in
 riak\_kv\_bitcask\_backend and riak\_kv\_eleveldb\_backend. It states a
 possible return value of the form '{ok, not\_found, state()}' for
 the not\_found case, instead of the actually returned form '{error,
 not\_found, state()}'

 Cheers,
 Nico

 Am 18.04.2012 12:18, schrieb Nico Meyer:

 Hello,

 I just encountered a problem with one of our Riak nodes, which
 is caused by a bug in either the disk controller or the
 firmware of our SSD disks.
 Anyway, the obvious symptom is, that all writes to the disks
 suddenly fail, which of course leads to truncated bitcask
 files. However, this time the files got corrupted in a way,
 that lead to CRC errors while fetching keys from bitcask. This
 in turn leads to a crash of the vnode everytime such a key is
 read. So the log is filled with these messages:

 11:55:52.621 [error] CRASH REPORT Process &lt;0.23175.3&gt; with 0
 neighbours crashed with reason: no case clause matching
 
{error,bad\_crc,{state,#Ref&lt;0.0.0.196598&gt;,"262613575457896618114724618378707105094425378816",[{async\_folds,true},[{vnode\_vclocks,false},{included\_applications,[]},{allow\_strfun,false},{reduce\_js\_vm\_count,6},{storage\_backend,riak\_kv\_bitcask\_backend},{legacy\_keylisting,false},{pb\_ip,"0.0.0.0"},{hook\_js\_vm\_count,2},{listkeys\_backpressure,false},{mapred\_name,"mapred"},{stats\_urlpath,"stats"},{legacy\_stats,true},{js\_thread\_stack,16},{riak\_kv\_stat,true},{add\_paths,[]},{http\_url\_encoding,on},{map\_js\_vm\_count,...},...],...],...}}
 in riak\_kv\_vnode:prepare\_put/3

 Also those keys cannot be (over)written, since a put without
 last\_write\_wins set to true does a get first internally.
 I think the cause of the error should be obvious to anyone
 familiar with the riak internals. Otherwise I can provide more
 information.

 Cheers,
 Nico




\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

