---
title: "Re: Riak doesn't use consistent hashing"
description: ""
project: community
lastmod: 2011-05-26T11:50:36-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg03436"
mailinglist_parent_id: "msg03420"
author_name: "Greg Nelson"
project_section: "mailinglistitem"
sent_date: 2011-05-26T11:50:36-07:00
---


The "not found" issue is a different one, but related. The issue there is that 
when a node joins the ring, the ring state is immediately changed. However, it 
takes time to handoff partitions to new owners. During that time, if a request 
comes in for data which has &gt; r of its replicas on partitions which changed 
ownership, the new owners will reply "not found" if they don't have the data 
yet.

It's possible that \*all\* the partitions in a preflist changed ownership, 
especially in circumstances I described with re-striping. So no r\_val can help 
you there.

And actually, even if only 2 of the 3 (assuming n\_val=3) partitions in the 
preflist moved, a read with r=1 \*still\* won't work because of an optimization 
called "basic quorum". That is, if the majority of replicas come back "not 
found" the coordinator will reply with "not found" instead of waiting to see if 
the other nodes respond with something.

Furthermore, the time it takes for handoffs to finish (or even start) can be a 
long time because vnodes will wait for periods of inactivity before doing 
handoff, and there are also restrictions on how many handoffs can happen at a 
time. You can tune those configurations with the handoff\_concurrency and 
vnode\_inactivity\_timeout parameters in the riak\_core section of app.config.

I believe the next release will have an option for turning off basic quorum. It 
will also have options that will allow your client to tell the difference 
between a real "not found" and one where r was not satisfied. And a further out 
release will have a proper fix for this whole issue. Probably involving 
forwarding of requests to old owners in cases where the handoff hasn't finished.

-Greg
On Thursday, May 26, 2011 at 7:21 AM, Ben Tilly wrote:
Performance is fine. However requests get a "not found" response for an 
extended period of time. See 
http://lists.basho.com/pipermail/riak-users\_lists.basho.com/2011-May/thread.html#4078
 for previous discussion of what sounds like the same issue.
&gt; 
&gt; On Thu, May 26, 2011 at 6:57 AM, Jonathan Langevin 
&gt;  wrote:
&gt; &gt; That sounds quite disconcerting. What happens to the performance of the 
&gt; &gt; cluster when this occurs?
&gt; &gt; 
&gt; &gt; 
&gt; &gt; Jonathan Langevin
&gt; &gt; Systems Administrator
&gt; &gt; Loom Inc.
&gt; &gt; Wilmington, NC: (910) 241-0433 - jlange...@loomlearning.com - 
&gt; &gt; www.loomlearning.com - Skype: intel352 
&gt; &gt; 
&gt; &gt; 
&gt; &gt; On Thu, May 26, 2011 at 1:54 AM, Greg Nelson  wrote:
&gt; &gt; I've been doing some digging through the details of how a node joins a 
&gt; &gt; cluster. When you hear that Riak uses consistent hashing, you'd expect it 
&gt; &gt; to distribute keys to nodes by hashing keys onto the ring AND hashing nodes 
&gt; &gt; onto the ring. Keys belong to the closest node on the ring, in the 
&gt; &gt; clockwise direction. Add a node, it hashes onto the ring and takes over 
&gt; &gt; some keys. Ordinarily the node would hash onto the ring in several places, 
&gt; &gt; to achieve better spread. Some data (roughly 1 / #nodes) moves to the new 
&gt; &gt; node from each of the other nodes, and everything else stays the same. 
&gt; &gt; &gt; 
&gt; &gt; &gt; In what Amazon describes as operationally simpler (strategy 3 in the 
&gt; &gt; &gt; Dynamo paper), the ring is instead divided into equally-sized partitions. 
&gt; &gt; &gt; Nodes are hashed onto the ring, and preflists are calculated by walking 
&gt; &gt; &gt; clockwise from a partition, skipping partitions on already visited nodes. 
&gt; &gt; &gt; Riak does something similar: it divides the ring into equally-sized 
&gt; &gt; &gt; partitions, then nodes "randomly" claim partitions. However, the skipping 
&gt; &gt; &gt; bit isn't part of Riak's preflist calculation. Instead, nodes claim 
&gt; &gt; &gt; partitions in such a way as to be spaced out by target\_n\_val, to obviate 
&gt; &gt; &gt; the need for skipping. 
&gt; &gt; &gt; 
&gt; &gt; &gt; Now, getting back to what happens when a node joins. The new node 
&gt; &gt; &gt; calculates a new ring state that maintains the target\_n\_val invariant, as 
&gt; &gt; &gt; well as trying to keep even spread of partitions per node. The algorithm 
&gt; &gt; &gt; (default\_choose\_claim) is heuristic and greedy in nature, and recursively 
&gt; &gt; &gt; transfers partitions to the new node until optimal spread is achieved, 
&gt; &gt; &gt; maintaining target\_n\_val along the way. But if -- during one of those 
&gt; &gt; &gt; recursive calls -- it can't meet the target\_n\_val, it will throw up its 
&gt; &gt; &gt; hands and completely re-do the whole ring (by calling claim\_rebalance\_n). 
&gt; &gt; &gt; Striping the partitions across nodes, in a round-robin fashion. When that 
&gt; &gt; &gt; happens, most of the data needs to be handed off between nodes. 
&gt; &gt; &gt; 
&gt; &gt; &gt; This happens a lot, with many ring sizes. With ring\_creation\_size=128 
&gt; &gt; &gt; (i.e., 128 partitions), it will happen when adding node 9 (87.5% of data 
&gt; &gt; &gt; moves), adding node 12 (82%), adding node 15 (80%), adding node 19 (94%). 
&gt; &gt; &gt; It happens with all ring sizes &gt;= 128 (256, 512, 1024, ...). It appears 
&gt; &gt; &gt; that any ring\_creation\_size (64 by default) is safe for growing to 8 
&gt; &gt; &gt; nodes or so. But if you want to go beyond that... A ring size of &gt;= 128 
&gt; &gt; &gt; with more than 8 nodes doesn't seem all that unusual, surely someone has 
&gt; &gt; &gt; hit this before? I've filed a bug report here: 
&gt; &gt; &gt; https://issues.basho.com/show\_bug.cgi?id=1111 
&gt; &gt; &gt; 
&gt; &gt; &gt; Anyway, this feels like a bit of a departure from consistent hashing. In 
&gt; &gt; &gt; fact, could this not be replaced by normal hashing + a lookup table 
&gt; &gt; &gt; mapping intervals of the hash space to nodes? And isn't that simply 
&gt; &gt; &gt; sharding? 
&gt; &gt; &gt; 
&gt; &gt; &gt; At any rate, I believe the claim algorithm can be improved to avoid those 
&gt; &gt; &gt; "throw up hands and stripe everything" scenarios. In fact, here is such 
&gt; &gt; &gt; an implementation: https://github.com/basho/riak\_core/pull/55. It is 
&gt; &gt; &gt; still heuristic and greedy, but it seems to do a better job of avoiding 
&gt; &gt; &gt; re-stripe. Test results are attached in a zip on the bug linked above. 
&gt; &gt; &gt; I'd love to get the riak\_core gurus at Basho to look at this and help 
&gt; &gt; &gt; validate it. It probably could use some cleaning up, but I want to make 
&gt; &gt; &gt; sure there aren't other invariants or considerations I'm leaving out -- 
&gt; &gt; &gt; besides maintaining target\_n\_val, keeping optimal partition spread, and 
&gt; &gt; &gt; minimizing handoff between ring states. 
&gt; &gt; &gt; 
&gt; &gt; &gt; -Greg 
&gt; &gt; &gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; &gt; &gt; riak-users mailing list
&gt; &gt; &gt; riak-users@lists.basho.com
&gt; &gt; &gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt; &gt; &gt; 
&gt; &gt; 
&gt; &gt; 
&gt; &gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; &gt; riak-users mailing list
&gt; &gt; riak-users@lists.basho.com
&gt; &gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt; &gt; 
&gt; 
&gt; 
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

