---
title: "Re: deleting keys"
description: ""
project: community
lastmod: 2011-06-01T07:33:22-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg03517"
mailinglist_parent_id: "msg03516"
author_name: "Eric Moritz"
project_section: "mailinglistitem"
sent_date: 2011-06-01T07:33:22-07:00
---


Depending on what you need the date for, you may be able to skip the
parsing step. If you're using it for sorting or comparison, ISO8601
can be compared lexicographically and usually no parsing is needed,
"earlier\_isodate &lt; later\_isodate" will be true in Javascript even
though they're strings. I just wanted to point that out in case you
over looked this property of ISO8061 formatted strings.

Eric.


On Wed, Jun 1, 2011 at 9:45 AM, Sean Cribbs  wrote:
&gt; Rob,
&gt;
&gt; Yes, you can use the provided iso8601.js file (only generated for you in a 
&gt; Rails 3 project, unfortunately, but you can grab it from inside the gem or on 
&gt; github) to parse ISO8601 Dates. You'll need to set the js\_source\_dir in 
&gt; app.config to point to the directory where this lives.
&gt;
&gt; If we upgrade erlang\_js to a later version of Spidermonkey in the future, the 
&gt; iso8601.js file will no longer be needed (1.8.5 supports ISO8601).  You can 
&gt; also choose to use RFC822-style dates by setting Ripple.date\_format = :rfc822.
&gt;
&gt; Sean Cribbs 
&gt; Developer Advocate
&gt; Basho Technologies, Inc.
&gt; http://basho.com/
&gt;
&gt; On Jun 1, 2011, at 9:37 AM, Dingwell, Robert A. wrote:
&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt; Thanks,
&gt;&gt;
&gt;&gt; I was trying to use the number of keys as an indication of how many objects 
&gt;&gt; there were in a bucket but I see that is not the smartest approach.  I 
&gt;&gt; didn't see anything that was an indication of the number of items in a 
&gt;&gt; bucket , is there anything if riak like this or do I need to create a map 
&gt;&gt; reduce job for this?
&gt;&gt;
&gt;&gt;
&gt;&gt; This is totally off the original topic but another question I have is 
&gt;&gt; related to javascript Date objects.  In ripple if I have a field that is a 
&gt;&gt; Time field it serializes to riak as a iso8601 string representation of the 
&gt;&gt; object.   When performing a map reduce job on the bucket related to the 
&gt;&gt; ripple class I have if I attempt to create a javascript Date object from the 
&gt;&gt; string in the stored object I get an Invalid Date error.   Is this just due 
&gt;&gt; to a limitation in the version of spider monkey being used?
&gt;&gt;
&gt;&gt; Thanks
&gt;&gt;
&gt;&gt; Rob
&gt;&gt;
&gt;&gt; On May 31, 2011, at 8:44 PM, Sean Cribbs wrote:
&gt;&gt;
&gt;&gt;&gt; Robert,
&gt;&gt;&gt;
&gt;&gt;&gt; What Keith said is misleading -- that key cache was solely in the Ruby 
&gt;&gt;&gt; client driver and not part of Riak itself.
&gt;&gt;&gt;
&gt;&gt;&gt; In Riak, deletes have two phases; in the first, so-called "tombstones" are 
&gt;&gt;&gt; written to the partitions that own replicas of the key.  The tombstone has 
&gt;&gt;&gt; special metadata marking it as such and an empty value, but has a 
&gt;&gt;&gt; descendant vector clock from the last known value. In the second phase, the 
&gt;&gt;&gt; tombstones are read back from the replicas, and iff they all are tombstones 
&gt;&gt;&gt; (that is, all replicas respond, and all are tombstones), a reaping command 
&gt;&gt;&gt; is sent such that they will be cleared from the backend.
&gt;&gt;&gt;
&gt;&gt;&gt; In your case, what may have occurred is that the replica chosen for 
&gt;&gt;&gt; key-listing did not receive the tombstone write (only 1/n\_val of all 
&gt;&gt;&gt; partitions are consulted for key-lists), or had not yet received the 
&gt;&gt;&gt; reaping command. When you read the key again, you obviously get a "not 
&gt;&gt;&gt; found" because the other replicas will resolve to a tombstone. Eventually 
&gt;&gt;&gt; your read requests will invoke read-repair, updating the stale partition 
&gt;&gt;&gt; and causing the value to be reaped.
&gt;&gt;&gt;
&gt;&gt;&gt; The moral of the story here is, again, don't rely on key-listings for 
&gt;&gt;&gt; strong indications of cluster state.
&gt;&gt;&gt;
&gt;&gt;&gt; Sean Cribbs 
&gt;&gt;&gt; Developer Advocate
&gt;&gt;&gt; Basho Technologies, Inc.
&gt;&gt;&gt; http://basho.com/
&gt;&gt;&gt;
&gt;&gt;&gt; On May 31, 2011, at 8:12 PM, Keith Bennett wrote:
&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Robert -
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Until a source code change a few days ago, riak would by default cache the 
&gt;&gt;&gt;&gt; keys reported to be in a bucket, so after fetching them once they would 
&gt;&gt;&gt;&gt; not be updated after deletions, additions, etc.  The key is indeed gone, 
&gt;&gt;&gt;&gt; but the keys API did not report the change.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; If you go to the message archive at 
&gt;&gt;&gt;&gt; http://lists.basho.com/pipermail/riak-users\_lists.basho.com/2011-May/thread.html,
&gt;&gt;&gt;&gt; and search for "Riak cleint resources", you'll see the ruckus that I 
&gt;&gt;&gt;&gt; started a week and a half ago about this very subject. ;)
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; There is an option to force the reloading of keys but I forget what it is, 
&gt;&gt;&gt;&gt; and anyway it is now gone from the current code base since the strategy 
&gt;&gt;&gt;&gt; was changed.  Be warned that using the keys method is, anyway, as Sean 
&gt;&gt;&gt;&gt; Cribbs pointed out to me, in general an awful idea, and almost always 
&gt;&gt;&gt;&gt; should be avoided.  This is because it's a very expensive operation -- in 
&gt;&gt;&gt;&gt; order to accomplish it, all keys in the data store need to be accessed.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; My guess is that testing for the exception you encountered is probably the 
&gt;&gt;&gt;&gt; best way to test for existence/absence of a key, but hopefully those more 
&gt;&gt;&gt;&gt; knowledgeable than I will enlighten us on that.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; - Keith
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; On May 31, 2011, at 7:23 PM, Dingwell, Robert A. wrote:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; Hi,
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; When deleting a key from a bucket I'm noticing that the object associated 
&gt;&gt;&gt;&gt;&gt; with the key is gone but the key itself is still sticking around.  I loop 
&gt;&gt;&gt;&gt;&gt; though all of the keys in a bucket and then call delete on each one, the 
&gt;&gt;&gt;&gt;&gt; object for the key is then gone so if I try to get the object for that 
&gt;&gt;&gt;&gt;&gt; key I get a 404 as expected.  But if I look at the bucket in the browser 
&gt;&gt;&gt;&gt;&gt; with the  keys=true parameter, all of the keys are still there.  Is this 
&gt;&gt;&gt;&gt;&gt; normal and if so how do I get rid of the keys?
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; Thanks\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt;&gt;&gt;&gt;&gt; riak-users mailing list
&gt;&gt;&gt;&gt;&gt; riak-users@lists.basho.com
&gt;&gt;&gt;&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt;&gt;&gt;&gt; riak-users mailing list
&gt;&gt;&gt;&gt; riak-users@lists.basho.com
&gt;&gt;&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;&gt;&gt;
&gt;&gt;
&gt;
&gt;
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

