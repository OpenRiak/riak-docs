---
title: "Re: mapreduce timeout"
description: ""
project: community
lastmod: 2013-07-15T06:51:35-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg11526"
mailinglist_parent_id: "msg11519"
author_name: "Christian Dahlqvist"
project_section: "mailinglistitem"
sent_date: 2013-07-15T06:51:35-07:00
---


Hi Deyan,

When running mapreduce jobs, reduce phases often end up being the bottleneck. 
This is especially true when all input data needs to be gathered on the 
coordinating node before it can be executed, as is the case if the 
reduce\_phase\_only\_1 flag is enabled. Having this flag set will cause the 
mapreduce job to not scale very well.

Depending on your exact requirements, it may be worthwhile considering 
gathering the histogram data periodically, e.g. per hour and/or day. These 
aggregates can then be stored in separate buckets with a key that describes the 
content, e.g. \_\_ . Once this has been done, you can 
efficiently retrieve a limited number of objects that cover the period you want 
to get statistics for directly through the descriptive keys, and process these 
in the application layer. Even though this periodically requires a bit more 
work, it will most likely be much more efficient at query time and scale better.

Best regards,

Christian


On 14 Jul 2013, at 12:16, Deyan Dyankov  wrote:

&gt; Hi everyone,
&gt; 
&gt; first time here. Thanks in advance.
&gt; 
&gt; I am experiencing issues with MapReduce and it seems to timeout after a 
&gt; certain volume data threshold is reached. The reducer is only one and here is 
&gt; the mapreduce initiation script:
&gt; #!/usr/bin/env ruby
&gt; […]
&gt; @client = Riak::Client.new(
&gt; :nodes =&gt; [
&gt; {:host =&gt; 'db1', :pb\_port =&gt; 8087, :http\_port =&gt; 8098},
&gt; {:host =&gt; 'db2', :pb\_port =&gt; 8087, :http\_port =&gt; 8098},
&gt; {:host =&gt; 'db3', :pb\_port =&gt; 8087, :http\_port =&gt; 8098}
&gt; ],
&gt; :protocol =&gt; 'pbc'
&gt; )
&gt; 
&gt; start\_key = "#{cust}:#{setup}:#{start\_time}"
&gt; end\_key = "#{cust}:#{setup}:#{end\_time}"
&gt; 
&gt; result = Riak::MapReduce.new(@client).
&gt; index(bucket\_name, index\_name, start\_key..end\_key).
&gt; map('map95th').
&gt; reduce('reduce95th', :arg =&gt; { 'reduce\_phase\_only\_1' =&gt; true }, :keep =&gt; 
&gt; true).
&gt; run()
&gt; 
&gt; puts result
&gt; 
&gt; The following is the code for the map95th and reduce95th javascript functions:
&gt; function map95th(v, keyData, arg) {
&gt; var key\_elements = v['key'].split(':');
&gt; var cust = key\_elements[0];
&gt; var setup = key\_elements[1];
&gt; var sid = key\_elements[2];
&gt; var ts = key\_elements[3];
&gt; 
&gt; var result\_key = cust + ':' + setup + ':' + ts;
&gt; var obj = {}
&gt; var obj\_data = Riak.mapValuesJson(v)[0];
&gt; 
&gt; obj\_data['bps'] = (obj\_data['rx\_bytes'] + obj\_data['tx\_bytes']) / 60;
&gt; return\_val = obj\_data['bps'];
&gt; return [ return\_val ];
&gt; }
&gt; 
&gt; // if used, this must be a single reducer! Call from Ruby like this:
&gt; // reduce('reduce95th', :arg =&gt; { 'reduce\_phase\_only\_1' =&gt; true }, :keep =&gt; 
&gt; true).
&gt; function reduce95th(values) {
&gt; var sorted = values.sort(function(a,b) { return a - b; });
&gt; var pct = sorted.length / 100;
&gt; var element\_95th = pct \* 95;
&gt; element\_95th = parseInt(element\_95th, 10) + 1;
&gt; 
&gt; return [ sorted[element\_95th] ];
&gt; }
&gt; 
&gt; 
&gt; 
&gt; Now here is the interesting part. The MR goes through one record per minute. 
&gt; If I run it for a period of less than ~20 days, it executes. Otherwise, it 
&gt; times out:
&gt; [deyandyankov@azobook ~/repos/loshko/mapreduce/ruby (master)]$
&gt; [deyandyankov@azobook ~/repos/loshko/mapreduce/ruby (master)]$ ./95h.rb 
&gt; yellingtone default $((`date +%s` - 20 \* 86400)) `date +%s`
&gt; 125581.51666666666
&gt; [deyandyankov@azobook ~/repos/loshko/mapreduce/ruby (master)]$ ./95h.rb 
&gt; yellingtone default $((`date +%s` - 30 \* 86400)) `date +%s`
&gt; /Users/deyandyankov/.rvm/gems/ruby-1.9.3-p392/gems/riak-client-1.1.1/lib/riak/client/beefcake\_protobuffs\_backend.rb:182:in
&gt; `decode\_response': Expected success from Riak but received 0. 
&gt; {"phase":1,"error":"timeout","input":null,"type":null,"stack":null} 
&gt; (Riak::ProtobuffsFailedRequest)
&gt; from 
&gt; /Users/deyandyankov/.rvm/gems/ruby-1.9.3-p392/gems/riak-client-1.1.1/lib/riak/client/beefcake\_protobuffs\_backend.rb:116:in
&gt; `mapred'
&gt; from 
&gt; /Users/deyandyankov/.rvm/gems/ruby-1.9.3-p392/gems/riak-client-1.1.1/lib/riak/client.rb:325:in
&gt; `block in mapred'
&gt; from 
&gt; /Users/deyandyankov/.rvm/gems/ruby-1.9.3-p392/gems/riak-client-1.1.1/lib/riak/client.rb:435:in
&gt; `block in recover\_from'
&gt; from 
&gt; /Users/deyandyankov/.rvm/gems/ruby-1.9.3-p392/gems/innertube-1.0.2/lib/innertube.rb:127:in
&gt; `take'
&gt; from 
&gt; /Users/deyandyankov/.rvm/gems/ruby-1.9.3-p392/gems/riak-client-1.1.1/lib/riak/client.rb:433:in
&gt; `recover\_from'
&gt; from 
&gt; /Users/deyandyankov/.rvm/gems/ruby-1.9.3-p392/gems/riak-client-1.1.1/lib/riak/client.rb:379:in
&gt; `protobuffs'
&gt; from 
&gt; /Users/deyandyankov/.rvm/gems/ruby-1.9.3-p392/gems/riak-client-1.1.1/lib/riak/client.rb:133:in
&gt; `backend'
&gt; from 
&gt; /Users/deyandyankov/.rvm/gems/ruby-1.9.3-p392/gems/riak-client-1.1.1/lib/riak/client.rb:324:in
&gt; `mapred'
&gt; from 
&gt; /Users/deyandyankov/.rvm/gems/ruby-1.9.3-p392/gems/riak-client-1.1.1/lib/riak/map\_reduce.rb:217:in
&gt; `run'
&gt; from ./95h.rb:29:in `'
&gt; [deyandyankov@azobook ~/repos/loshko/mapreduce/ruby (master)]$
&gt; 
&gt; The records being processed look lie this:
&gt; {"rx\_bytes":3485395.0,"tx\_bytes":1658479.0}
&gt; 
&gt; When running the script with more than 20 days worth of data (two records per 
&gt; minute are processed, which amounts to 2 \* 60 \* 24 \* 20 = more than 57,600 
&gt; processed), the script times out and here are some things from the logs:
&gt; ==&gt; /var/log/riak/erlang.log.1 &lt;==
&gt; Erlang has closed
&gt; 
&gt; ==&gt; /var/log/riak/error.log &lt;==
&gt; 2013-07-14 13:03:51.580 [error] &lt;0.709.0&gt;@riak\_pipe\_vnode:new\_worker:768 Pipe 
&gt; worker startup failed:fitting was gone before startup
&gt; 
&gt; ==&gt; /var/log/riak/console.log &lt;==
&gt; 2013-07-14 13:03:51.584 [error] &lt;0.22049.4326&gt; gen\_fsm &lt;0.22049.4326&gt; in 
&gt; state wait\_for\_input terminated with reason: timeout
&gt; 
&gt; ==&gt; /var/log/riak/error.log &lt;==
&gt; 2013-07-14 13:03:51.584 [error] &lt;0.22049.4326&gt; gen\_fsm &lt;0.22049.4326&gt; in 
&gt; state wait\_for\_input terminated with reason: timeout
&gt; 
&gt; ==&gt; /var/log/riak/console.log &lt;==
&gt; 2013-07-14 13:03:51.940 [error] &lt;0.22049.4326&gt; CRASH REPORT Process 
&gt; &lt;0.22049.4326&gt; with 0 neighbours exited with reason: timeout in 
&gt; gen\_fsm:terminate/7 line 611
&gt; 
&gt; ==&gt; /var/log/riak/crash.log &lt;==
&gt; 2013-07-14 13:03:51 =CRASH REPORT====
&gt; crasher:
&gt; initial call: riak\_pipe\_vnode\_worker:init/1
&gt; pid: &lt;0.22049.4326&gt;
&gt; registered\_name: []
&gt; exception exit: 
&gt; {timeout,[{gen\_fsm,terminate,7,[{file,"gen\_fsm.erl"},{line,611}]},{proc\_lib,init\_p\_do\_apply,3,[{file,"proc\_lib.erl"},{line,227}]}]}
&gt; ancestors: 
&gt; [&lt;0.710.0&gt;,&lt;0.709.0&gt;,riak\_core\_vnode\_sup,riak\_core\_sup,&lt;0.129.0&gt;]
&gt; messages: []
&gt; links: [&lt;0.710.0&gt;,&lt;0.709.0&gt;]
&gt; dictionary: 
&gt; [{eunit,[{module,riak\_pipe\_vnode\_worker},{partition,388211372416021087647853783690262677096107081728},{&lt;0.709.0&gt;,&lt;0.709.0&gt;},{details,{fitting\_details,{fitting,&lt;18125.23420.4566&gt;,#Ref&lt;18125.0.5432.50467&gt;,&lt;&lt;"C�������������������"&gt;&gt;,1},1,riak\_kv\_w\_reduce,{rct,#Fun,{struct,[{&lt;&lt;"reduce\_phase\_only\_1"&gt;&gt;,true}]}},{fitting,&lt;18125.23418.4566&gt;,#Ref&lt;18125.0.5432.50467&gt;,sink,undefined},[{log,sink},{trace,[error]},{sink,{fitting,&lt;18125.23418.4566&gt;,#Ref&lt;18125.0.5432.50467&gt;,sink,undefined}},{sink\_type,{fsm,10,infinity}}],64}}]}]
&gt; trap\_exit: false
&gt; status: running
&gt; heap\_size: 832040
&gt; stack\_size: 24
&gt; reductions: 1456611
&gt; neighbours:
&gt; 
&gt; ==&gt; /var/log/riak/error.log &lt;==
&gt; 2013-07-14 13:03:51.940 [error] &lt;0.22049.4326&gt; CRASH REPORT Process 
&gt; &lt;0.22049.4326&gt; with 0 neighbours exited with reason: timeout in 
&gt; gen\_fsm:terminate/7 line 611
&gt; 
&gt; ==&gt; /var/log/riak/crash.log &lt;==
&gt; 2013-07-14 13:03:52 =SUPERVISOR REPORT====
&gt; Supervisor: {&lt;0.710.0&gt;,riak\_pipe\_vnode\_worker\_sup}
&gt; Context: child\_terminated
&gt; Reason: timeout
&gt; Offender: 
&gt; [{pid,&lt;0.22049.4326&gt;},{name,undefined},{mfargs,{riak\_pipe\_vnode\_worker,start\_link,undefined}},{restart\_type,temporary},{shutdown,2000},{child\_type,worker}]
&gt; 
&gt; 
&gt; ==&gt; /var/log/riak/console.log &lt;==
&gt; 2013-07-14 13:03:52.059 [error] &lt;0.710.0&gt; Supervisor 
&gt; riak\_pipe\_vnode\_worker\_sup had child undefined started with 
&gt; {riak\_pipe\_vnode\_worker,start\_link,undefined} at &lt;0.22049.4326&gt; exit with 
&gt; reason timeout in context child\_terminated
&gt; 
&gt; ==&gt; /var/log/riak/error.log &lt;==
&gt; 2013-07-14 13:03:52.059 [error] &lt;0.710.0&gt; Supervisor 
&gt; riak\_pipe\_vnode\_worker\_sup had child undefined started with 
&gt; {riak\_pipe\_vnode\_worker,start\_link,undefined} at &lt;0.22049.4326&gt; exit with 
&gt; reason timeout in context child\_terminated
&gt; 
&gt; 
&gt; The data is in leveldb and is accessed through secondary indexes. 
&gt; This is a 3 node cluster with 32GB ram, current usage is about 12G per node. 
&gt; n\_val=3. The same issues occurs on a similar 2 node cluster with 8GB of ram 
&gt; (usage is ~6G).
&gt; 
&gt; The following is my app.config:
&gt; [
&gt; {riak\_api, [
&gt; {pb\_ip, "0.0.0.0" },
&gt; {pb\_port, 8087 },
&gt; {pb\_backlog, 100 }
&gt; ]},
&gt; {riak\_core, [
&gt; {default\_bucket\_props, [
&gt; {n\_val, 3},
&gt; {last\_write\_wins, true}
&gt; ]},
&gt; {ring\_state\_dir, "/storage/riak/ring"},
&gt; {ring\_creation\_size, 256},
&gt; {http, [ {"0.0.0.0", 8098 } ]},
&gt; {https, [{ "0.0.0.0", 8069 }]},
&gt; {ssl, [
&gt; {certfile, "/etc/ssl/riak/server.crt"},
&gt; {cacertfile, "/etc/ssl/riak/root.crt"},
&gt; {keyfile, "/etc/ssl/riak/server.key"}
&gt; ]},
&gt; {handoff\_port, 8099 },
&gt; {dtrace\_support, false},
&gt; {enable\_health\_checks, true},
&gt; {platform\_bin\_dir, "/usr/sbin"},
&gt; {platform\_data\_dir, "/storage/riak"},
&gt; {platform\_etc\_dir, "/etc/riak"},
&gt; {platform\_lib\_dir, "/usr/lib/riak/lib"},
&gt; {platform\_log\_dir, "/var/log/riak"}
&gt; ]},
&gt; {riak\_kv, [
&gt; {storage\_backend, riak\_kv\_eleveldb\_backend},
&gt; {anti\_entropy, {on, []}},
&gt; {anti\_entropy\_build\_limit, {1, 3600000}},
&gt; {anti\_entropy\_expire, 604800000},
&gt; {anti\_entropy\_concurrency, 2},
&gt; {anti\_entropy\_tick, 15000},
&gt; {anti\_entropy\_data\_dir, "/storage/riak/anti\_entropy"},
&gt; {anti\_entropy\_leveldb\_opts, [{write\_buffer\_size, 4194304},
&gt; {max\_open\_files, 20}]},
&gt; 
&gt; {mapred\_name, "mapred"},
&gt; {mapred\_2i\_pipe, true},
&gt; {map\_js\_vm\_count, 16 },
&gt; {reduce\_js\_vm\_count, 12 },
&gt; {hook\_js\_vm\_count, 20 },
&gt; {js\_max\_vm\_mem, 8},
&gt; {js\_thread\_stack, 16},
&gt; {js\_source\_dir, "/etc/riak/mapreduce/js\_source"},
&gt; {http\_url\_encoding, on},
&gt; {vnode\_vclocks, true},
&gt; {listkeys\_backpressure, true},
&gt; {vnode\_mailbox\_limit, {1, 5000}}
&gt; ]},
&gt; 
&gt; {riak\_search, [
&gt; {enabled, true}
&gt; ]},
&gt; 
&gt; {merge\_index, [
&gt; {data\_root, "/storage/riak/merge\_index"},
&gt; {buffer\_rollover\_size, 1048576},
&gt; {max\_compact\_segments, 20}
&gt; ]},
&gt; 
&gt; {bitcask, [
&gt; {data\_root, "/storage/riak/bitcask"}
&gt; ]},
&gt; 
&gt; {eleveldb, [
&gt; {cache\_size, 1024},
&gt; {max\_open\_files, 64},
&gt; {data\_root, "/storage/riak/leveldb"}
&gt; ]},
&gt; 
&gt; {lager, [
&gt; {handlers, [
&gt; {lager\_file\_backend, [
&gt; {"/var/log/riak/error.log", error, 10485760, 
&gt; "$D0", 5},
&gt; {"/var/log/riak/console.log", info, 10485760, 
&gt; "$D0", 5}
&gt; ]}
&gt; ] },
&gt; 
&gt; {crash\_log, "/var/log/riak/crash.log"},
&gt; {crash\_log\_msg\_size, 65536},
&gt; {crash\_log\_size, 10485760},
&gt; {crash\_log\_date, "$D0"},
&gt; {crash\_log\_count, 5},
&gt; {error\_logger\_redirect, true}
&gt; ]},
&gt; 
&gt; {riak\_sysmon, [
&gt; {process\_limit, 30},
&gt; {port\_limit, 2},
&gt; {gc\_ms\_limit, 0},
&gt; {heap\_word\_limit, 40111000},
&gt; {busy\_port, true},
&gt; {busy\_dist\_port, true}
&gt; ]},
&gt; 
&gt; {sasl, [
&gt; {sasl\_error\_logger, false}
&gt; ]},
&gt; 
&gt; Sorry to bug you with such a long e-mail but I wanted to be as thorough as 
&gt; possible. I tried raising a few options but it didn't help: map\_js\_vm\_count, 
&gt; reduce\_js\_vm\_count, js\_max\_vm\_mem
&gt; I also tried adding a timeout argument to the map reduce caller code but even 
&gt; if I set it to 60,000 or more (this is milliseconds), the script is 
&gt; terminating with timeout error after 10-12 secs. The same behaviour is 
&gt; observed if I use http instead of pbc.
&gt; 
&gt; What seems to be the problem? Is this a matter of configuration? I am 
&gt; surprised about the fact that the job runs with 20-25 days of data and not 
&gt; more.
&gt; 
&gt; thank you for your efforts,
&gt; Deyan
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

