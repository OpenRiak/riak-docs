---
title: "Re: Nightly Prune"
description: ""
project: community
lastmod: 2013-02-08T00:37:34-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg10042"
mailinglist_parent_id: "msg10039"
author_name: "Stephan Kepser"
project_section: "mailinglistitem"
sent_date: 2013-02-08T00:37:34-08:00
---


Hi Chad,

yes, you're right: the use of secondary indexes requires LevelDB as
backend. How much of an performance penalty this imposes to you I really
don't know. I'd still consider the use of secondary indexes because it is
an architecturally clean solution and hence simple to implement and
maintain. If you experience performance issues you still have the option to
scale out, i.e, use more nodes.

There may yet be another option to speed up write operations, depending on
your demands. You could use the memory backend for about a third of your
nodes and set the write quorum to 1. This turns the memory-only nodes into
something like a cache without any further need to administer this cache.
On the other hand I have to say I'm not sure you can enforce that at least
one replica of each data item goes to a node with LevelDB backend.

Best,

Stephan

2013/2/7 Chad Engler 

&gt; I'm writing the prune script in Node, and the dates are stored as int
&gt; timestamps so that isn't an issue.\*\*\*\*
&gt;
&gt; \*\* \*\*
&gt;
&gt; I was under the impression that secondary indexes only worked on the
&gt; LevelDB backend, we have a solid write throughput (maybe 10ish writes per
&gt; second) and very little read (aside from the prune). Would we see
&gt; significant performance degradation by switching from Bitcask?\*\*\*\*
&gt;
&gt; \*\* \*\*
&gt;
&gt; -Chad\*\*\*\*
&gt;
&gt; \*\* \*\*
&gt;
&gt; \*From:\* riak-users [mailto:riak-users-boun...@lists.basho.com] \*On Behalf
&gt; Of \*Stephan Kepser
&gt; \*Sent:\* Thursday, February 07, 2013 1:50 PM
&gt; \*To:\* riak-users@lists.basho.com
&gt; \*Subject:\* Re: Nightly Prune\*\*\*\*
&gt;
&gt; \*\* \*\*
&gt;
&gt; Hi Chad,
&gt;
&gt; I recommend looking at secondary indexes. You can set up a secondary index
&gt; with the relevant date from your entry. Note that there is no data type
&gt; date, only string or integer. But you can easily convert a date into a
&gt; string or an integer for your query purposes. Secondary indexes even
&gt; provide you with a way to query for date ranges. And they are fast. So, I
&gt; think they'd serve your purpose.
&gt;
&gt; Best,
&gt;
&gt; Stephan
&gt;
&gt; --
&gt; Dr. Stephan Kepser | Senior IT-Consultant
&gt;
&gt; codecentric AG | Merscheider Stra√üe 1 | 42699 Solingen | Deutschland
&gt; tel: +49 (0) 212.23362845 | fax: +49 (0) 212.23362879 | mobil: +49 (0)
&gt; 151.52883635
&gt; www.codecentric.de | blog.codecentric.de | www.meettheexperts.de |
&gt; www.more4fi.de\*\*\*\*
&gt;
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

