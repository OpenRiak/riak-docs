---
title: "Re: AAE problems"
description: ""
project: community
lastmod: 2014-06-19T07:11:28-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg14328"
mailinglist_parent_id: "msg14320"
author_name: "Ryan Zezeski"
project_section: "mailinglistitem"
sent_date: 2014-06-19T07:11:28-07:00
---


On Tue, Jun 17, 2014 at 12:46 PM, Istv√°n  wrote:
&gt;
&gt;
&gt; The entire dataset is idempotent and immutable, so there is not even a
&gt; slightest chance that we are ending up with different values on
&gt; different nodes for the same key in the same bucket. It seems that
&gt; anti-entropy still finds problems:
&gt;
&gt; /var/log/riak/console.log.4:2014-06-11 06:11:41.756 [info]
&gt; &lt;0.6776.6003&gt;@riak\_kv\_exchange\_fsm:key\_exchange:206 Repaired 1 keys
&gt; during active anti-entropy exchange of
&gt; {536645132457440915277915524513010171279912730624,3} between
&gt; {548063113999088594326381812268606132370974703616,'riak@10.1.11.120'}
&gt; and {559481095540736273374848100024202093462036676608,'riak@10.1.11.121'}
&gt;

AAE exchange uses snapshots of the trees. The snapshots on each node will
happen concurrently. If your cluster is servicing writes as these
snapshots are made then there is a chance a snapshot will be made on one
node containing keys X,Y,Z and on the other node which has only seen keys X
& Y.


&gt;
&gt; My question would be:
&gt;
&gt; Is there any reason to let AAE running if we don't mutate the data in
&gt; place?
&gt;

YES.

Immutable data provides nice semantics for your application but does
\_nothing\_ to save you from the whims of the stack your application runs on.
 Operating systems, file systems, and hardware all have subtle ways to
corrupt your data both on disk and in memory. Immutable data also doesn't
help in the more practical case where the network decides to drop packets
and a write only makes it to some of the nodes.



&gt; Is there any way knowing what is causing the difference according to
&gt; AAE between two nodes?


There is but it requires attaching to Riak and running some diagnostic
commands \_when\_ a repair takes place. I'm not sure it will give you any
insight though. It will either say: 1) remote missing, 2) local missing or
3) hashes are different.


&gt; I was thinking about how this could potentially
&gt; happen and I am wondering if the Java client pb interface supports R
&gt; and W values, so I could make sure that a write goes in with W=(the
&gt; number of nodes we have).
&gt;

Doubt this will help with the concurrency problem I discussed above but it
will mean your application has a stronger guarantee of how many copies made
it to the nodes. If you want to make sure they are durable then I would
use DW if Java exposes it [1].

[1]: See the "optional query parameters" for difference between W, DW, and
PW.
http://docs.basho.com/riak/latest/dev/references/http/store-object/#Request

-Z
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

