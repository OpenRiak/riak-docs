---
title: "Re: handling the ETag"
description: ""
project: community
lastmod: 2013-04-25T10:58:46-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg10972"
mailinglist_parent_id: "msg10971"
author_name: "Simon Majou"
project_section: "mailinglistitem"
sent_date: 2013-04-25T10:58:46-07:00
---


Yes thank you Dmitri
Le 25 avr. 2013 19:52, "Dmitri Zagidulin"  a Ã©crit :

&gt; Hi Simon,
&gt;
&gt; You are correct - setting the ETag in the Riak object header when doing a
&gt; PUT or POST does not work (there is no way to specify or change the ETag on
&gt; most riak clients).
&gt;
&gt; The good news is, I think you can solve your particular problem (caching
&gt; users' web pages) without that capability. You don't really need the ETag
&gt; of the riak \_object\_ in which the page is stored to match the ETag of the
&gt; actual web page that the user's browser interacts with. (What etags are
&gt; actually used in Riak for, is with 'If-None-Match' or 'If-Modified-Since'
&gt; conditional HTTP semantics).
&gt;
&gt; The easiest way to implement this caching behavior is - use the Etag of
&gt; the webpage as the key (or part of the key) for the riak object that stores
&gt; the web page. So:
&gt;
&gt; 1) The web page is generated, and sent to the user with an etag 'abcd'.
&gt; 2) Store that web page in Riak using the etag as the key (here, 'abcd') or
&gt; as part of the key (something like 'your-url/index.html-abcd')
&gt; Ignore the fact that the etag in the riak object will be something
&gt; completely different, 'efgh'. You don't really need to use riak's etag.
&gt;
&gt; 3) When subsequent requests for that web page come in from the user's
&gt; browser, make a GET call to Riak for the etag 'abcd' and return it if it
&gt; exists, or else generate it & store it as usual.
&gt;
&gt; (You're probably wondering about cache expiration, and how to clean up all
&gt; those stored web pages. Here, I would recommend using the Bitcask back end
&gt; and setting it to auto-expire (see the Automatic Expiration section of
&gt; http://docs.basho.com/riak/latest/tutorials/choosing-a-backend/Bitcask/). The 
&gt; other alternative is to keep track of the web pages and their
&gt; expiration externally, and to issue explicit DELETE calls as part of a cron
&gt; job.)
&gt;
&gt; Does that make sense?
&gt;
&gt; Dmitri
&gt;
&gt;
&gt;
&gt;
&gt; On Wed, Apr 24, 2013 at 12:30 PM, Simon Majou  wrote:
&gt;
&gt;&gt; Hello,
&gt;&gt;
&gt;&gt; I am building a basic architecture : user / application server / riak.
&gt;&gt; The web pages are generated on the application server, then sent to the
&gt;&gt; user and finally stored (cached) in Riak. I would like the page sent to the
&gt;&gt; user & the page stored in Riak to have the same ETag, so new requests with
&gt;&gt; Etags are handled easily by forwarding them to Riak.
&gt;&gt;
&gt;&gt; I tried to set the ETag header when doing a PUT, but it doesn't have any
&gt;&gt; effect.
&gt;&gt;
&gt;&gt; So how can I do that ? Obviously I don't want to store the page in Riak
&gt;&gt; before sending it to the user as it would add latency.
&gt;&gt;
&gt;&gt; Simon
&gt;&gt;
&gt;&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;&gt;
&gt;&gt;
&gt;
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

