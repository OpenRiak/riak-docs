---
title: "Re: Java client - conflict resolver on both fetch() and store()?"
description: ""
project: community
lastmod: 2013-08-10T19:46:15-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg11957"
mailinglist_parent_id: "msg11956"
author_name: "Matt Painter"
project_section: "mailinglistitem"
sent_date: 2013-08-10T19:46:15-07:00
---


Thanks Sean. I understand that the fetch-modify-write is the approach that
I'm \*not\* taking in this case, as I am using withoutFetch() and setting a
@RiakVClock in my POJO.

I just need to weigh up whether the ideal way is sufficiently better to
rejig bits of my code - but I think that's a different issue :)

M

On 11 August 2013 14:32, Sean Cribbs  wrote:

&gt; I'm sure Roach will correct me if I'm off-base, but I believe the store
&gt; operation does a fetch and resolve before writing. I think the ideal way to
&gt; do that is to create a Mutation (T being your POJO) as well, in which
&gt; case it's less of a "store" and more of a "fetch-modify-write". The way to
&gt; skip the fetch/modify is to use the withoutFetch() option on the operation
&gt; builder.
&gt;
&gt;
&gt; On Sat, Aug 10, 2013 at 6:50 PM, Matt Painter  wrote:
&gt;
&gt;&gt; Hi,
&gt;&gt;
&gt;&gt; I've just rolled up my sleeves and have started to make my application
&gt;&gt; more robust with conflict resolution.
&gt;&gt;
&gt;&gt; I am currently using a @RiakVClock in my POJO (I need to think more
&gt;&gt; about whether the read/modify/write approach is preferable or whether I'd
&gt;&gt; have to rearchitect things).
&gt;&gt;
&gt;&gt; I read in the Riak Handbook the recommendation that conflicts are best
&gt;&gt; resolved on read - not write - however the example App.java snipping on
&gt;&gt; the Storing data in 
&gt;&gt; Riak
&gt;&gt; page
&gt;&gt; in the Java client's doco uses a resolver on both the store() and 
&gt;&gt; fetch()operations.
&gt;&gt;
&gt;&gt; Indeed, if I don't specify my conflict resolver in my store(), things
&gt;&gt; blow up (in my unit test, mind - I'm still getting my head around the whole
&gt;&gt; area so my test may be a bit contrived).
&gt;&gt;
&gt;&gt; However when I use it in both places, my conflicts are being resolved
&gt;&gt; twice. Is this anticipated?
&gt;&gt;
&gt;&gt; My store is:
&gt;&gt;
&gt;&gt; bucket.store(record).returnBody(true).
&gt;&gt; withoutFetch().withResolver(myConflictResolver);
&gt;&gt; and my fetch is:
&gt;&gt;
&gt;&gt; bucket.fetch(id, Record.class).withResolver(myConflictResolver
&gt;&gt; ).execute();
&gt;&gt; The order of operations in my test is:
&gt;&gt;
&gt;&gt; 1. Store new record
&gt;&gt; 2. Fetch the record as firstRecord
&gt;&gt; 3. Fetch the record as secondRecord
&gt;&gt; 4. Modify a field on firstRecord and secondRecord
&gt;&gt; 5. Save firstRecord
&gt;&gt; 6. Save secondRecord - this invokes my resolver with two siblings
&gt;&gt; 7. Read record - this also invokes my resolver with the two siblings
&gt;&gt;
&gt;&gt; Am I missing something? Or is this what's supposed to happen? I'm not too
&gt;&gt; worried - the double-handling is hardly that intensive - but I'm keen to
&gt;&gt; get it right.
&gt;&gt;
&gt;&gt; Thanks in advance,
&gt;&gt; Matt
&gt;&gt;
&gt;&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;&gt;
&gt;&gt;
&gt;
&gt;
&gt; --
&gt; Sean Cribbs 
&gt; Software Engineer
&gt; Basho Technologies, Inc.
&gt; http://basho.com/
&gt;



-- 
Matt Painter
m...@deity.co.nz
+64 21 115 9378
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

