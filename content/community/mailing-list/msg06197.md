---
title: "Re: Newbie question 3/3"
description: ""
project: community
lastmod: 2012-01-09T15:46:20-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg06197"
mailinglist_parent_id: "msg06190"
author_name: "John DeTreville"
project_section: "mailinglistitem"
sent_date: 2012-01-09T15:46:20-08:00
---


Right, I certainly don't want distributed transactions, which I agree would 
destroy availability. (I should add that my system is geographically 
distributed, making everything much worse.)

Still, that leaves open the question of doing what my application needs without 
transactions. Let's consider two situations involving updates.

The first situation is when I can reduce an update to a single write, such as 
by using Riak's secondary indexes. Unfortunately, I don't have a great 
understanding of the performance of secondary indexes, and I don't have a great 
understanding of their failure modes. Can you offer any guidance?

The second situation is when I really need to do multiple writes, in which case 
I must model (some subset of) transactional semantics at the application level. 
One example is implementing my own redo log, as mentioned earlier. Have other 
users ever had such problems? What are the good ways to solve them? Heck, what 
are the bad ways (just so I'll know what to avoid)?

Cheers,
John

On Jan 9, 2012, at 2:54 PM, Ryan Zezeski wrote:

&gt; John,
&gt; 
&gt; As you already seem to understand, Riak doesn't provide a way to make 
&gt; multiple ops atomic. Part of the reason is because Riak's main focus thus 
&gt; far has been availability. Distributed transactions would work, but at the 
&gt; cost of availability. I think a flaw with the redo log approach is that you 
&gt; need to serialize all operations to A & B through \\_one\\_ client to keep from 
&gt; reading an inconsistent state.
&gt; 
&gt; A much simpler option, if you can bend your data, is to combine A and B into 
&gt; one object.
&gt; 
&gt; -Ryan
&gt; 
&gt; On Mon, Jan 9, 2012 at 12:33 AM, John DeTreville  wrote:
&gt; (An earlier post seems not to have gone through. My apologies in the eventual 
&gt; case of a duplicate.)
&gt; 
&gt; I'm thinking of using Riak to replace a large Oracle system, and I'm trying 
&gt; to understand its guarantees. I have a few introductory questions; this is 
&gt; the third of three.
&gt; 
&gt; I would like to do two updates atomically, but of course I cannot. I imagine 
&gt; I could construct my own redo log, and perform a sequence of operations 
&gt; something like:
&gt; 
&gt; write redo log entry (timestamp, A's update, B's update) to redo log
&gt; update A
&gt; update B
&gt; delete redo log entry from redo log
&gt; 
&gt; Asynchronously, I could read dangling entries from the redo log and repeat 
&gt; them, deleting them upon success. (Let's imagine for simplicity that the 
&gt; updates are idempotent and commutative.) This seems doable, but it's not 
&gt; pretty. Is this the best I can do? Or should I think about the problem 
&gt; differently?
&gt; 
&gt; (BTW, I believe that secondary indexes won't help me.)
&gt; 
&gt; Cheers,
&gt; John
 
