---
title: "Re: This sure looks like a bug...?"
description: ""
project: community
lastmod: 2011-04-18T23:02:01-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg03092"
mailinglist_parent_id: "msg03084"
author_name: "Ben Tilly"
project_section: "mailinglistitem"
sent_date: 2011-04-18T23:02:01-07:00
---


To save other people the effort of watching a reasonably long video,
it demonstrates how to show the conflict to the user. In the
application where it is done (a wiki) it is an entirely appropriate
UI.

On Mon, Apr 18, 2011 at 9:01 PM, Eric Moritz  wrote:
&gt; Ben,
&gt;
&gt; There's a little demo app that was written by someone at Basho that
&gt; demostrates a way to accomplish what you're talking about.
&gt;
&gt; http://forms.basho.com/riak-in-action-wriaki-p/
&gt;
&gt; Eric.
&gt;
&gt; On Mon, Apr 18, 2011 at 11:05 PM, Sean Cribbs  wrote:
&gt;&gt; Sorry for being dismissive, I do understand what you're after. I'm just 
&gt;&gt; saying that if your application needs those semantics, build them in -- 
&gt;&gt; don't expect Riak's vector clocks to do the work for you. Keep a list of the 
&gt;&gt; most recent "change" events either in that object or alongside, or keep a 
&gt;&gt; copy of the last-seen version in your object -- whatever works to make those 
&gt;&gt; kinds of merges possible.
&gt;&gt;
&gt;&gt; Interestingly, multiple people have explored the SCM-on-top-of-Riak thing, 
&gt;&gt; so I know it's doable; the key difference there is that multiple, 
&gt;&gt; independently written objects are used to represent the history of a single 
&gt;&gt; conceptual "object". Once written, nothing is overwritten, only new objects 
&gt;&gt; are created.
&gt;&gt;
&gt;&gt; Sean Cribbs 
&gt;&gt; Developer Advocate
&gt;&gt; Basho Technologies, Inc.
&gt;&gt; http://basho.com/
&gt;&gt;
&gt;&gt; On Apr 18, 2011, at 10:46 PM, Ben Tilly wrote:
&gt;&gt;
&gt;&gt;&gt; I'm not missing the point you think I am.  Riak already has the
&gt;&gt;&gt; ability to store more than one value for a key/value pair.  I'd like
&gt;&gt;&gt; an option - possibly named something new, that used this to store a
&gt;&gt;&gt; limited amount of history so that clients could be presented with a
&gt;&gt;&gt; common ancestor when that was required.
&gt;&gt;&gt;
&gt;&gt;&gt; In the case that I gave you, if the common ancestor is:
&gt;&gt;&gt;
&gt;&gt;&gt;  {
&gt;&gt;&gt;    "name": "Jane Doe",
&gt;&gt;&gt;    "occupation": "secretary"
&gt;&gt;&gt;  }
&gt;&gt;&gt;
&gt;&gt;&gt; then a standard three-way merge would say that she got married and the
&gt;&gt;&gt; correct result should be:
&gt;&gt;&gt;
&gt;&gt;&gt;  {
&gt;&gt;&gt;    "name": "Jane Blow",
&gt;&gt;&gt;    "husband": "Joe Blow",
&gt;&gt;&gt;    "occupation": "n/a"
&gt;&gt;&gt;  }
&gt;&gt;&gt;
&gt;&gt;&gt; while if the common ancestor is:
&gt;&gt;&gt;
&gt;&gt;&gt;  {
&gt;&gt;&gt;    "name": "Jane Blow",
&gt;&gt;&gt;    "husband": "Joe Blow",
&gt;&gt;&gt;    "occupation": "n/a"
&gt;&gt;&gt;  }
&gt;&gt;&gt;
&gt;&gt;&gt; then a standard 3-way merge would say that she dumped the jerk and got
&gt;&gt;&gt; a job resulting in:
&gt;&gt;&gt;
&gt;&gt;&gt;  {
&gt;&gt;&gt;    "name": "Jane Doe",
&gt;&gt;&gt;    "occupation": "secretary"
&gt;&gt;&gt;  }
&gt;&gt;&gt;
&gt;&gt;&gt; Without the common ancestor you know what changed, but not which
&gt;&gt;&gt; direction the changes are going, and so have no sane way to resolve
&gt;&gt;&gt; the conflict.
&gt;&gt;&gt;
&gt;&gt;&gt; Given the non-atomic nature of reads and writes in Riak, it is likely
&gt;&gt;&gt; that neither of the two clients that wrote that data was in any way
&gt;&gt;&gt; aware of the existence of the other write.  This makes your suggestion
&gt;&gt;&gt; of escalating to the user impossible.  And there is no particular
&gt;&gt;&gt; reason to believe that the third user to come along will necessarily
&gt;&gt;&gt; know anything either.
&gt;&gt;&gt;
&gt;&gt;&gt; (Besides, I spent enough years maintaining batch systems to be wary of
&gt;&gt;&gt; escalating to users at the drop of a hat.  The "user" may well be a
&gt;&gt;&gt; complete moron on autopilot.)
&gt;&gt;&gt;
&gt;&gt;&gt; On Mon, Apr 18, 2011 at 7:01 PM, Sean Cribbs  wrote:
&gt;&gt;&gt;&gt; I think you're missing a key point here, and that is that the vector clock 
&gt;&gt;&gt;&gt; doesn't store copies of the \\*values\\*, only the individual "touches" of 
&gt;&gt;&gt;&gt; identified clients. I'm not sure what computing the common ancestor is 
&gt;&gt;&gt;&gt; going to give you if you don't have the value.  Vector clocks are 
&gt;&gt;&gt;&gt; essentially opaque to clients.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; That said, I think the use-case you gave is one that can clearly bubble up 
&gt;&gt;&gt;&gt; to the user, e.g. "Someone else changed this record while you were editing 
&gt;&gt;&gt;&gt; it. Can you resolve the differences?" (Give the other person's name 
&gt;&gt;&gt;&gt; perhaps, highlight the fields that are different.)
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Sean Cribbs 
&gt;&gt;&gt;&gt; Developer Advocate
&gt;&gt;&gt;&gt; Basho Technologies, Inc.
&gt;&gt;&gt;&gt; http://basho.com/
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; On Apr 18, 2011, at 9:12 PM, Ben Tilly wrote:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; Riak's small\\_vclock, big\\_vclock, young\\_vclock, and old\\_vclock
&gt;&gt;&gt;&gt;&gt; parameters already give control over pruning behavior.  If there isn't
&gt;&gt;&gt;&gt;&gt; enough history to compute a common ancestor, then return nothing for
&gt;&gt;&gt;&gt;&gt; the common ancestor.
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; The use case here really isn't an SCM.  The use case is when two
&gt;&gt;&gt;&gt;&gt; clients get simultaneous (within, say, 50 ms) requests to write to the
&gt;&gt;&gt;&gt;&gt; same object.  When a third one tries to read the data 5s later, it
&gt;&gt;&gt;&gt;&gt; would be nice to have a way to figure out what to do.  For this use
&gt;&gt;&gt;&gt;&gt; case you can limit the amount of history quite severely without loss.
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; Let's take a practical example of conflicting data structures:
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;  {
&gt;&gt;&gt;&gt;&gt;    "name": "Jane Doe",
&gt;&gt;&gt;&gt;&gt;    "occupation": "n/a"
&gt;&gt;&gt;&gt;&gt;  },
&gt;&gt;&gt;&gt;&gt;  {
&gt;&gt;&gt;&gt;&gt;    "name": "Jane Blow",
&gt;&gt;&gt;&gt;&gt;    "husband": "Joe Blow",
&gt;&gt;&gt;&gt;&gt;    "occupation": "secretary"
&gt;&gt;&gt;&gt;&gt;  }
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; What should it be resolved to?  Perhaps Jane just got divorced and
&gt;&gt;&gt;&gt;&gt; went to work as a secretary.  Or she could have gotten married and
&gt;&gt;&gt;&gt;&gt; left her job.  If you give me the common ancestor I can tell which
&gt;&gt;&gt;&gt;&gt; scenario to believe.  Without it I can only guess badly.  I don't want
&gt;&gt;&gt;&gt;&gt; to keep a history here.  I want to resolve the discrepancy the next
&gt;&gt;&gt;&gt;&gt; time I see it (and log it somewhere important if I can't resolve it).
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; On Mon, Apr 18, 2011 at 5:38 PM, Sean Cribbs  wrote:
&gt;&gt;&gt;&gt;&gt;&gt; Yes, but vector clocks are for resolution of race-conditions and network 
&gt;&gt;&gt;&gt;&gt;&gt; partitions, not to provide an SCM history.  Imagine how much space would 
&gt;&gt;&gt;&gt;&gt;&gt; be consumed by the history long enough to disambiguate an object that 
&gt;&gt;&gt;&gt;&gt;&gt; has been updated normally 1000 times, followed by one bad client that 
&gt;&gt;&gt;&gt;&gt;&gt; decides write to it without fetching the vector clock first.
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt; Coda Hale put it well in his talk at the recent Riak Meetup: your data 
&gt;&gt;&gt;&gt;&gt;&gt; needs to be logically monotonic so that writes (and reads) can be 
&gt;&gt;&gt;&gt;&gt;&gt; retried until resolution is reached.
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt; Also, we've found that assigning the client id to something that is 
&gt;&gt;&gt;&gt;&gt;&gt; relevant to your domain, e.g. real people, will help reduce surprises 
&gt;&gt;&gt;&gt;&gt;&gt; (and degenerate cases like sibling explosion) when it comes to 
&gt;&gt;&gt;&gt;&gt;&gt; vector-clock resolution.
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt; Sean Cribbs 
&gt;&gt;&gt;&gt;&gt;&gt; Developer Advocate
&gt;&gt;&gt;&gt;&gt;&gt; Basho Technologies, Inc.
&gt;&gt;&gt;&gt;&gt;&gt; http://basho.com/
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt; On Apr 18, 2011, at 8:15 PM, Aphyr wrote:
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I actually had a question about that page.  Why is it that when there
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is a conflict we can only get the conflicting versions of the data?
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If I'm going to try to resolve the conflict intelligently, I really
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; want the common ancestor as well so that I can try to do a 3-way
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; merge.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; Good call. If an ancestor were available it would make counting and 
&gt;&gt;&gt;&gt;&gt;&gt;&gt; merging orthogonal changes \\*much\\* simpler.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;

&gt;

