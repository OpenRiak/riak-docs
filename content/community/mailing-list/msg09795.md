---
title: "Re: riak java client causing OOMs on high latency [resolution]"
description: ""
project: community
lastmod: 2013-01-10T14:42:17-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg09795"
author_name: "Dietrich Featherston"
project_section: "mailinglistitem"
sent_date: 2013-01-10T14:42:17-08:00
---


We now believe this to be fixed in the following commit to rjc. Socket
timeouts were not resulting in permits being released -
https://github.com/basho/riak-java-client/commit/b8a4e7b872ae26e2c38e0ff4dd3e2d617a2c8344

The content of the byte[]s indicated that multiple threads were
reading from the same socket, and hence reading "length headers" out
of the middle of messages. We went digging for culprits, found the
missing finally block, then noticed this change downstream.

Will post more info if this doesn't do the trick.


On Thu, Jan 10, 2013 at 11:44 AM, Dietrich Featherston  wrote:
&gt; Have confirmed that this is likely a protobuf corruption issue and not
&gt; related to the actual data we are storing and fetching. We never see
&gt; object sizes as reported in /stats higher than about 600-700KB.
&gt; However, we forked the riak driver to instrument the byte[] allocation
&gt; sizes in this block of code. In some cases, it is attempting to create
&gt; ~2GB byte[] arrays and in other cases it is actually returning a
&gt; negative size header. See attached screenshot for the range of lengths
&gt; we are seeing returned.
&gt;
&gt;
&gt; On Tue, Jan 8, 2013 at 6:50 AM, Brian Roach  wrote:
&gt;&gt; The code you cite is reading a size (32 bit int, network byte order)
&gt;&gt; and a message code (8bit int) from the socket. It then creates a
&gt;&gt; byte[] of the size required for the amount of data that has been
&gt;&gt; requested and then sent back by Riak to the client in a response. (See
&gt;&gt; the docs here: 
&gt;&gt; http://docs.basho.com/riak/latest/references/apis/protocol-buffers/
&gt;&gt; that show this format )
&gt;&gt;
&gt;&gt; That byte[] is then passed into the Google protocol buffers generated
&gt;&gt; code where the appropriate protocol buffers object(s) are deserialized
&gt;&gt; from those bytes and the information contained therein is extracted
&gt;&gt; from them into our own objects which are returned to the caller as a
&gt;&gt; response.
&gt;&gt;
&gt;&gt; From the client's perspective, if that's how much data you're getting,
&gt;&gt; that's how much data you've requested, and how much Riak has sent you.
&gt;&gt;
&gt;&gt; Thanks,
&gt;&gt; Brian Roach
&gt;&gt;
&gt;&gt; On Mon, Jan 7, 2013 at 3:26 PM, Dietrich Featherston  wrote:
&gt;&gt;&gt; We're seeing instances of a JVM app which talks to riak run out of
&gt;&gt;&gt; memory when riak operations rise in latency or riak becomes otherwise
&gt;&gt;&gt; unresponsive. A heap dump of the JVM at the time of the OOM show that
&gt;&gt;&gt; 91% of the 1G (active) heap is consumed by large byte[] instances. In
&gt;&gt;&gt; our case 3 of those byte[]s are in the 200MB range with size dropping
&gt;&gt;&gt; off after that. The byte[] instances cannot be traced back to a
&gt;&gt;&gt; specific variable as their references appear to be stack-allocated
&gt;&gt;&gt; local method variables. But, based on the name of the thread, we can
&gt;&gt;&gt; tell that the thread is doing a store operation against
&gt;&gt;&gt; riak@localhost.
&gt;&gt;&gt;
&gt;&gt;&gt; Inspection of the data in one of these byte[]s shows what looks like
&gt;&gt;&gt; an r\\_object response with headers and footer boilerplate around our
&gt;&gt;&gt; object payload. This 200+MB byte[] is filled with 0s after the 338th
&gt;&gt;&gt; element which is really confusing and indicates that far too much
&gt;&gt;&gt; space is being allocated to read the protobuf payload. Here's a dump
&gt;&gt;&gt; of one of these instances:
&gt;&gt;&gt; https://gist.github.com/40ef9b2ff561e973a72c
&gt;&gt;&gt;
&gt;&gt;&gt; It's also worth mentioning that, according to /stats,
&gt;&gt;&gt; get\\_fsm\\_objsize\\_100 is consistently under 1MB so there is no reason to
&gt;&gt;&gt; think that our objects are actually this large.
&gt;&gt;&gt;
&gt;&gt;&gt; At this point I'm suspicious of the following code creating too large
&gt;&gt;&gt; a byte[] from possibly too large a return from dis.readInt()
&gt;&gt;&gt;
&gt;&gt;&gt; https://github.com/basho/riak-java-client/blob/master/src/main/java/com/basho/riak/pbc/RiakConnection.java#L110
&gt;&gt;&gt;
&gt;&gt;&gt; Unsure if that indicates a problem in the driver or the server-side
&gt;&gt;&gt; erlang protobuf server.
&gt;&gt;&gt;
&gt;&gt;&gt; Suspicious that requests pile up and many of these byte[]s are hanging
&gt;&gt;&gt; out--enough to cause an OOM. It's possible that they are always very
&gt;&gt;&gt; large, but are short-lived enough as to not cause a problem until
&gt;&gt;&gt; latencies rise increasing their numbers briefly.
&gt;&gt;&gt;
&gt;&gt;&gt; Thoughts?
&gt;&gt;&gt;
&gt;&gt;&gt; Thanks,
&gt;&gt;&gt; D
&gt;&gt;&gt;
&gt;&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt;&gt; riak-users mailing list
&gt;&gt;&gt; riak-users@lists.basho.com
&gt;&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

