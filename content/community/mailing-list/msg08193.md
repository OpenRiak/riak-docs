---
title: "Re: Deletion followed by re-addition leads to siblings when it	shouldn't"
description: ""
project: community
lastmod: 2012-08-07T12:20:46-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg08193"
mailinglist_parent_id: "msg08192"
author_name: "Sean Cribbs"
project_section: "mailinglistitem"
sent_date: 2012-08-07T12:20:46-07:00
---


The default setting for Riak is to reap tombstones after 3 seconds, leaving
the pristine state for that key. You can change that behavior in the
app.config file.

{riak\\_kv,[
 %% ...
 {delete\\_mode, DeleteMode},

]},


On Tue, Aug 7, 2012 at 2:26 PM, Kaspar Thommen wrote:

&gt; Sean,
&gt;
&gt; Thanks for the explanation. I'm still confused, however, because when I
&gt; insert a Thread.sleep(5000) before the second call to testBucket.store(...)
&gt; then I don't run into the UnresolvedConflictException - looks like the
&gt; deletion of the object somehow got 'propagated' through the cluster and is
&gt; really gone after those 5 seconds. Is this the case? Why?
&gt;
&gt; Also, how can I check if a sibling that I'm getting back is dead (marked
&gt; with a tombstone)?
&gt;
&gt; Thanks,
&gt; Kaspar
&gt;
&gt;
&gt;
&gt; 2012/8/3 Sean Cribbs 
&gt;
&gt;&gt; Kaspar,
&gt;&gt;
&gt;&gt; Your code creates siblings because:
&gt;&gt;
&gt;&gt; 1) When a key is deleted, Riak creates a tombstone (with a vector clock)
&gt;&gt; that is not reaped from storage immediately.
&gt;&gt; 2) When store a new value without correlating it to an old value, it is
&gt;&gt; treated as having the "empty" vector clock and creates a sibling.
&gt;&gt;
&gt;&gt; So in the siblings returned, one should be "deleted" and the other should
&gt;&gt; be your new value. You should be able to linearize this sequence by keeping
&gt;&gt; around the IRiakObject you fetched in the second step, and issuing the
&gt;&gt; delete and second store passing that object or its vector clock. I'm not
&gt;&gt; sure how that applies to the Java client, but that is the general strategy
&gt;&gt; in these cases.
&gt;&gt;
&gt;&gt; On Fri, Aug 3, 2012 at 2:48 AM, Kaspar Thommen 
&gt;&gt; wrote:
&gt;&gt;
&gt;&gt;&gt; Anyone please?
&gt;&gt;&gt; On Jul 28, 2012 6:59 PM, "Kaspar Thommen" 
&gt;&gt;&gt; wrote:
&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Hi,
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; I ran the following Java snippet that creates a bucket, stores a
&gt;&gt;&gt;&gt; key/value pair in it, deletes the key, and adds a new value for that same
&gt;&gt;&gt;&gt; key. The n-value is 3 and all r- and w-values are also set to 3 to ensure
&gt;&gt;&gt;&gt; full consistency (for testing only). Here's the code:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; public static void main(String[] args) throws Exception {
&gt;&gt;&gt;&gt; IRiakClient riak = RiakFactory.pbcClient();
&gt;&gt;&gt;&gt; try {
&gt;&gt;&gt;&gt; // store an object in a new bucket
&gt;&gt;&gt;&gt; Bucket testBucket =
&gt;&gt;&gt;&gt; riak.createBucket("testBucket").nVal(3).allowSiblings(true).execute();
&gt;&gt;&gt;&gt; testBucket.store("key", "value1").w(3).execute();
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; System.out.println(testBucket.fetch("key").r(3).execute().getValueAsString());
&gt;&gt;&gt;&gt; // prints 'value1'
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; // now delete it and store another object with the same key
&gt;&gt;&gt;&gt; testBucket.delete("key").r(3).w(3).execute();
&gt;&gt;&gt;&gt; testBucket.store("key", "value2").w(3).execute();
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; System.out.println(testBucket.fetch("key").r(3).execute().getValueAsString());
&gt;&gt;&gt;&gt; // throws 'UnresolvedConflictException: Siblings found'
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; } finally {
&gt;&gt;&gt;&gt; riak.shutdown();
&gt;&gt;&gt;&gt; }
&gt;&gt;&gt;&gt; }
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; As you can see by the comment I have added to the code fetching the key
&gt;&gt;&gt;&gt; a second time should, in my opinion, return the new value, but it fails
&gt;&gt;&gt;&gt; because there are siblings. Maybe I didn't fully understand how sibling
&gt;&gt;&gt;&gt; handling works, but I don't see how there can possibly be any siblings
&gt;&gt;&gt;&gt; given that r and w are 3. Any pointers? I tried the LevelDB and memory
&gt;&gt;&gt;&gt; backends, same result.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Thanks,
&gt;&gt;&gt;&gt; Kaspar
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;

&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt; --
&gt;&gt; Sean Cribbs 
&gt;&gt; Software Engineer
&gt;&gt; Basho Technologies, Inc.
&gt;&gt; http://basho.com/
&gt;&gt;
&gt;&gt;
&gt;


-- 
Sean Cribbs 
Software Engineer
Basho Technologies, Inc.
http://basho.com/
