---
title: "Re: Emulating composite index queries with secondary indexes and key	filters"
description: ""
project: community
lastmod: 2012-08-28T06:27:48-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg08380"
mailinglist_parent_id: "msg08379"
author_name: "Olav Frengstad"
project_section: "mailinglistitem"
sent_date: 2012-08-28T06:27:48-07:00
---


Looking at riak\\_kv\\_mapred\\_json it seems to be the case that you
can only do key filter on entire buckets.

On the other hand one can still use the riak\\_kv\\_mapred\\_filters, even
though it's ugly constructing all the filter manually instead of matching
binary patterns:

{ok, Pid} = riakc\\_pb\\_socket:start\\_link("127.0.0.1", 8087),
{ok, Filter} = riak\\_kv\\_mapred\\_filters:build\\_filter([[&lt;&lt;"ends\\_with"&gt;&gt;,"1"]]),
MapReduce = [
 { reduce
 , {qfun, fun(X, F) -&gt; lists:filter(fun({A, B}) -&gt; F(B) end, X) end},
 , riak\\_kv\\_mapred\\_filters:compose(Filter),
 , true}],
Index = {index, &lt;&lt;"test1"&gt;&gt;, &lt;&lt;"field\\_int"&gt;&gt;, &lt;&lt;"123"&gt;&gt;},
riakc\\_pb\\_socket:mapred(Pid, Index, MapReduce).

Question 2 & 3 still remains though:
&gt;&gt; 2) Would this be a efficient solution, considering the 2i query
&gt;&gt; will return 10k+ results? the reduce should cut that in half.
&gt;&gt; 3) What other options to i have for querying this? Obviously i can
&gt;&gt; use Riak search, but the term based indexing puts me off. Other
&gt;&gt; option is building this manually with empty object just linking.


2012/8/28 Jeremiah Peschka :
&gt; As best as I can recall, you can't key filter on 2i. You can, however,
&gt; perform range filtering. You could query where the 2i key is between
&gt; 20110101T00:00:00Z|a|a and 20110201T00:00:00Z|zzz|zzz
&gt;
&gt; Please forgive any typos. I'm using a phone.
&gt;
&gt;
&gt; On Tuesday, August 28, 2012, Olav Frengstad wrote:
&gt;&gt;
&gt;&gt; Hey,
&gt;&gt;
&gt;&gt; I'm looking to use riak to store time series. So naturaly i'm in the
&gt;&gt; processes of validating all possible methods this query. A object
&gt;&gt; has a id, origin, timestamp and type. The query in question is to
&gt;&gt; select all object within a time range that originated from "origin"
&gt;&gt; and has a certain "type".
&gt;&gt;
&gt;&gt; The current plan is to store the timestamp as a secondary index and
&gt;&gt; then have composite keys responsible for matching origin/type predicate.
&gt;&gt;
&gt;&gt; A key would look like this: "::".
&gt;&gt;
&gt;&gt; To query one would just pipe the 2i query to key filter map reduce:
&gt;&gt;
&gt;&gt; curl -X POST -H "Content-Type: application/json" -d '{"inputs":{
&gt;&gt; "bucket" : "seriesx", "index" : "timestamp\\_int", "start" : 123,
&gt;&gt; "end" : 456, "key\\_filters" : [["ends\\_with", ":"]]}}'
&gt;&gt;
&gt;&gt; In regards to this "imaginary" solution i have a few questions:
&gt;&gt; 1) is this possible, or does key filter only work on a bucket?
&gt;&gt; 2) Would this be a efficient solution, considering the 2i query
&gt;&gt; will return 10k+ results? the reduce should cut that in half.
&gt;&gt; 3) What other options to i have for querying this? Obviously i can
&gt;&gt; use Riak search, but the term based indexing puts me off. Other
&gt;&gt; option is building this manually with empty object just linking.
&gt;&gt;
&gt;&gt; --
&gt;&gt; Med Vennlig Hilsen
&gt;&gt; Olav Frengstad
&gt;&gt;
&gt;&gt; Systemutvikler // FWT
&gt;&gt; +47 920 42 090
&gt;
&gt;
&gt;
&gt; --
&gt; ---
&gt; Jeremiah Peschka
&gt; Managing Director, Brent Ozar PLF, LLC

-- 
Med Vennlig Hilsen
Olav Frengstad

Systemutvikler // FWT
+47 920 42 090

