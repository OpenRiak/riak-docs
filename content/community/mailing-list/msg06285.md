---
title: "Re: Delta updates using pre-commit hooks"
description: ""
project: community
lastmod: 2012-01-14T10:03:55-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg06285"
mailinglist_parent_id: "msg06127"
author_name: "Ryan Zezeski"
project_section: "mailinglistitem"
sent_date: 2012-01-14T10:03:55-08:00
---


Marek,

You're definitely butting up against the limits of Riak's data model here.
 It sounds like you are looking for something like Redis? E.g. add element
E to set S. You could probably use statebox [1] and pull some tricks in
the precommit hook to determine if the incoming client object is the
initial object or a delta but you would still need to perform a read in the
hook to get the box, apply the delta, and then return that object from the
hook. As you said this happens on the coordinator and there is no easy way
to guarantee this op applies local to the data off the top of my head. At
least a precommit hook would prevent streaming the object to/from the
client.

I think what you really want is native support for different data models on
top of Riak. Internally, we've played around with a CRDT [2] interface on
top of Riak where instead of sending objects you send operations. This is
analogous to how Redis works (although the underlying implementation is
very different given Riak's distributed nature). The trick with a new data
model is making sure it scales and making sure we understand its
consistency model.

Riak's pedigree is the key-value model. I'm sure you could hack something
together on top of Riak's KV model with precommit hooks but you will be
swimming upstream. That said, we're always looking at new models that
would compliment our existing key-value model.

-Ryan

[1]: https://github.com/mochi/statebox

[2]: http://hal.archives-ouvertes.fr/inria-00555588/

On Wed, Jan 4, 2012 at 10:11 AM, Marek Zawirski wrote:

&gt; Hi,
&gt;
&gt; we are trying use Riak as a storage layer for experimental
&gt; higher-level data types updated by clients, using a set of
&gt; well-defined operations. To this end, each data type instance is
&gt; stored under a single key. One problem with this approach is that
&gt; after client modifies even a small piece of the data structure, it
&gt; needs to write (and transfer) the whole data structure back to Riak.
&gt; We are looking for a way to reduce this overhead by sending just a
&gt; delta operation, preferably without partitioning the data structure to
&gt; several keys.
&gt;
&gt; One approach we thought about is to perform operations on Riak-side
&gt; using pre-commit hooks or similar technique. I.e. reconstruct the new
&gt; value on Riak using original old value + delta send by client. The
&gt; operations (deltas) we are talking about have necessary properties to
&gt; ensure convergence. Still, it seems there a couple technical issues
&gt; involved, we are looking how to solve them:
&gt; 1) pre-commit API seems to only offer access to the object value
&gt; passed by client during write and not the old value; I wonder - am I
&gt; able to read the value from the store in pre-commit hook? In
&gt; particular, the value previously read by the client writing,
&gt; identified by version vector?
&gt; 2) pre-commit hooks are executed on the coordinator node; is there an
&gt; easy way in Riak to apply operations at data nodes instead?
&gt;
&gt; Thanks for any info that can help addressing these issues.
&gt;
&gt; Regards,
&gt; Marek Zawirski
&gt;

