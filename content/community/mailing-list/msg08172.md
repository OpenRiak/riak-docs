---
title: "Re: Deletion followed by re-addition leads to siblings when it	shouldn't"
description: ""
project: community
lastmod: 2012-08-02T23:48:53-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg08172"
mailinglist_parent_id: "msg08109"
author_name: "Kaspar Thommen"
project_section: "mailinglistitem"
sent_date: 2012-08-02T23:48:53-07:00
---


Anyone please?
On Jul 28, 2012 6:59 PM, "Kaspar Thommen"  wrote:

&gt; Hi,
&gt;
&gt; I ran the following Java snippet that creates a bucket, stores a key/value
&gt; pair in it, deletes the key, and adds a new value for that same key. The
&gt; n-value is 3 and all r- and w-values are also set to 3 to ensure full
&gt; consistency (for testing only). Here's the code:
&gt;
&gt; public static void main(String[] args) throws Exception {
&gt; IRiakClient riak = RiakFactory.pbcClient();
&gt; try {
&gt; // store an object in a new bucket
&gt; Bucket testBucket =
&gt; riak.createBucket("testBucket").nVal(3).allowSiblings(true).execute();
&gt; testBucket.store("key", "value1").w(3).execute();
&gt;
&gt; System.out.println(testBucket.fetch("key").r(3).execute().getValueAsString());
&gt; // prints 'value1'
&gt;
&gt; // now delete it and store another object with the same key
&gt; testBucket.delete("key").r(3).w(3).execute();
&gt; testBucket.store("key", "value2").w(3).execute();
&gt;
&gt; System.out.println(testBucket.fetch("key").r(3).execute().getValueAsString());
&gt; // throws 'UnresolvedConflictException: Siblings found'
&gt;
&gt; } finally {
&gt; riak.shutdown();
&gt; }
&gt; }
&gt;
&gt; As you can see by the comment I have added to the code fetching the key a
&gt; second time should, in my opinion, return the new value, but it fails
&gt; because there are siblings. Maybe I didn't fully understand how sibling
&gt; handling works, but I don't see how there can possibly be any siblings
&gt; given that r and w are 3. Any pointers? I tried the LevelDB and memory
&gt; backends, same result.
&gt;
&gt; Thanks,
&gt; Kaspar
&gt;
&gt;
&gt;
