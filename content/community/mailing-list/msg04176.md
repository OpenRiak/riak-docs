---
title: "Re: Locking"
description: ""
project: community
lastmod: 2011-08-02T07:50:51-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg04176"
mailinglist_parent_id: "msg04175"
author_name: "Jon Meredith"
project_section: "mailinglistitem"
sent_date: 2011-08-02T07:50:51-07:00
---


Hi Jeffrey,

Do you know if Mongo provides locks that can be used on clusters of machines
and in the presence of network partitions/failures? Riak could probably get
close if you created a cluster with a single node and performed all accesses
with N=R=W=1 as updating a single vnode is atomic, it's only when the order
of vnode requests can be interleaved that you get problems. Of course you'd
have a single point of failure....

Soren: It may be worth looking at a separate lock service along the lines of
Zookeeper - you could take a look at the work Joe Blomstedt did on riak\\_zab
https://github.com/jtuple/riak\\_zab but as the FAQ suggests do not use it in
production.

BR,
Jon.

On Tue, Aug 2, 2011 at 8:40 AM, Jeffrey Kesselman  wrote:

&gt; jon gave a much better and more detailed description, but fundamentally no
&gt; true lock is possible without an atomic test and set operation.
&gt;
&gt; So far, of all the No Sql DBs I've looked at, only Mongo has that
&gt; capability.
&gt;
&gt;
&gt;
&gt; On Sun, Jul 31, 2011 at 4:55 PM, Soren Hansen  wrote:
&gt;
&gt;&gt; I've seen a couple of posts here and there on the subject of a locking
&gt;&gt; mechanism for Riak, most notably:
&gt;&gt;
&gt;&gt; http://riak-users.197444.n3.nabble.com/Riak-and-Locks-td1866960.html
&gt;&gt;
&gt;&gt; While it would only serve as an advisory locking mechanism, wouldn't a
&gt;&gt; bucket with a reasonably high n, w and dw set equal to n, a
&gt;&gt; deterministic naming scheme for the object being locked, and a locking
&gt;&gt; algorithm such as:
&gt;&gt;
&gt;&gt; 1. PUT /locks/object\\_id
&gt;&gt; If-None-Match: \\*
&gt;&gt; Body: 
&gt;&gt;
&gt;&gt; 1a. If this fails, wait for a while, then try again.
&gt;&gt; 1b. If it succeeds, proceed to 2.
&gt;&gt;
&gt;&gt; 2. The doc for If-None-Match says "this does not prevent concurrent
&gt;&gt; writes; it is possible for the condition to evaluate to true for
&gt;&gt; multiple requests if the requests occur at the same time." I'm not
&gt;&gt; completely sure if n=w=dw protects me from concurrent writes (I'm not
&gt;&gt; familiar with the locking semantics of a single riak instance).
&gt;&gt; Anyway, if I'm in fact not protected, the next step is to read the
&gt;&gt; value back to make sure we're actually the ones holding the key. If
&gt;&gt; not, go back to step 1. If yes, proceed as planned.
&gt;&gt;
&gt;&gt; 3. Once you're done with the lock, just DELETE it.
&gt;&gt;
&gt;&gt; If this were really that simple, someone would have suggested it. So,
&gt;&gt; what is this Riak rookie (i.e. I) missing?
&gt;&gt;
&gt;&gt;
&gt;&gt; --
&gt;&gt; Soren Hansen | http://linux2go.dk/
&gt;&gt; Ubuntu Developer | http://www.ubuntu.com/
&gt;&gt; OpenStack Developer | http://www.openstack.org/

&gt;
&gt;

