---
title: "Re: A script to check bitcask keydir sizes"
description: ""
project: community
lastmod: 2011-03-24T10:51:24-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg02740"
mailinglist_parent_id: "msg02738"
author_name: "Nico Meyer"
project_section: "mailinglistitem"
sent_date: 2011-03-24T10:51:24-07:00
---


You are right. But on the other hand the savings are really small.
Unless you have some good reason to give your bucket a very long name,
you can just choose a short bucket to begin with.

The bigger concern for me would be the way the bucket/key tuple is
serialized:

Eshell V5.8 (abort with ^G)
1&gt; iolist\\_size(term\\_to\\_binary({&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;})).
13

That's 13 bytes of overhead per key were only 2 bytes is needed with
reasonable bucket/key length limits of 256 bytes each. Or if that is not
enough, one could also use a variable length encoding, so bucket/keys
can be arbitrarily large and the most common cases (less then 128 bytes)
still only use 2 bytes of overhead.

That is still only about 1GB per 100Mio keys, so even that is not really
relevant in today's world of cheap 64GB machines.


Am Donnerstag, den 24.03.2011, 10:17 -0700 schrieb Greg Nelson:
&gt; Maybe slightly a different topic, but it's always seemed a little
&gt; strange to me that bucket names are prefixed to every key in the
&gt; keydir -- or rather, they are part of the key at that layer. Wouldn't
&gt; it be the common case that there are relatively few buckets? And so
&gt; wouldn't it save a lot of memory to keep a reference to an interned
&gt; bucket name string in each entry, instead of the whole bucket name?
&gt; 
&gt; 
&gt; This seems like it would only be more expensive (in terms of memory
&gt; usage) if either a) your bucket names are very short, like fewer than
&gt; 4 bytes, or b) your ratio of keys to buckets is near 1.
&gt; 
&gt; 
&gt; I'm sure I am missing something, though, and haven't poked into that
&gt; part of the code yet.
&gt; 
&gt; 
&gt; On Thursday, March 24, 2011 at 3:11 AM, Nico Meyer wrote:
&gt; 
&gt; &gt; Hi Anthony,
&gt; &gt; 
&gt; &gt; watching the memory that riak consumes is certainly the most
&gt; &gt; important
&gt; &gt; metric. If riak runs out of memory you are screwed. On a dedicated
&gt; &gt; node
&gt; &gt; just use the 'free' command to get that information:
&gt; &gt; 
&gt; &gt; total used free shared buffers cached
&gt; &gt; Mem: 66106100 49834164 16271936 0 232460 41492552
&gt; &gt; -/+ buffers/cache: 8109152 57996948
&gt; &gt; Swap: 1951856 36 1951820
&gt; &gt; 
&gt; &gt; 
&gt; &gt; the most important line is the second one. There should be "enough"
&gt; &gt; free
&gt; &gt; memory. Also swap used should always be near zero. Whats enough is
&gt; &gt; not
&gt; &gt; so clear cut. If latency is really important for you, it should be
&gt; &gt; enough free memory, so that your working set fits into that amount.
&gt; &gt; Then
&gt; &gt; the disk is mostly used for writing.
&gt; &gt; 
&gt; &gt; The way you can eyeball if you have enough memory left for caching
&gt; &gt; is
&gt; &gt; for example by using a tool like 'iostat' (in the systats package on
&gt; &gt; Debian). It shows you the disk utilization of your system. I usually
&gt; &gt; call it like that:
&gt; &gt; 
&gt; &gt; iostat -x 2
&gt; &gt; 
&gt; &gt; 
&gt; &gt; Of course you should also watch CPU and network utilization, but
&gt; &gt; usually
&gt; &gt; disk or memory becomes a problem first.
&gt; &gt; 
&gt; &gt; Cheers,
&gt; &gt; Nico
&gt; &gt; 
&gt; &gt; Am Mittwoch, den 23.03.2011, 23:45 -0700 schrieb Anthony Molinaro:
&gt; &gt; &gt; Hi Nico,
&gt; &gt; &gt; 
&gt; &gt; &gt; Its unclear riak-admin status eventually calls
&gt; &gt; &gt; riak\\_kv\\_stat:get\\_stats
&gt; &gt; &gt; which states
&gt; &gt; &gt; 
&gt; &gt; &gt; %% mem\\_total
&gt; &gt; &gt; %% The first element of the tuple returned by
&gt; &gt; &gt; %% {@link memsup:get\\_memory\\_data/0}.
&gt; &gt; &gt; %%
&gt; &gt; &gt; %% mem\\_allocated
&gt; &gt; &gt; %% The second element of the tuple returned by
&gt; &gt; &gt; %% {@link memsup:get\\_memory\\_data/0}.
&gt; &gt; &gt; %%
&gt; &gt; &gt; 
&gt; &gt; &gt; The man page for memsup states
&gt; &gt; &gt; 
&gt; &gt; &gt; Returns the result of the latest memory check, where Total is
&gt; &gt; &gt; the total memory size and Allocated the allocated memory size,
&gt; &gt; &gt; in bytes.
&gt; &gt; &gt; 
&gt; &gt; &gt; which doesn't tell me if that's filesystem cache or not. According
&gt; &gt; &gt; to
&gt; &gt; &gt; top the riak beam.smp is using 3G of virtual and 2.7G of resident
&gt; &gt; &gt; on node1 which don't match any of the values from before.
&gt; &gt; &gt; Attaching
&gt; &gt; &gt; to the riak node and running memory() I see
&gt; &gt; &gt; 
&gt; &gt; &gt; [{total,2392208240},
&gt; &gt; &gt; {processes,15012600},
&gt; &gt; &gt; {processes\\_used,12797856},
&gt; &gt; &gt; {system,2377195640},
&gt; &gt; &gt; {atom,824297},
&gt; &gt; &gt; {atom\\_used,812024},
&gt; &gt; &gt; {binary,898656},
&gt; &gt; &gt; {code,8336856},
&gt; &gt; &gt; {ets,556632}]
&gt; &gt; &gt; 
&gt; &gt; &gt; Which seems to reflect what top claims. I'm just curious what to
&gt; &gt; &gt; look at
&gt; &gt; &gt; to determine when I need to add new nodes. I'm currently capturing
&gt; &gt; &gt; the
&gt; &gt; &gt; statistics riak provides and putting them into rrds, and mean
&gt; &gt; &gt; response time
&gt; &gt; &gt; is great (95,99, and 100 have spikes quite regularly which I still
&gt; &gt; &gt; don't fully
&gt; &gt; &gt; understand the cause of, but mean/median is pretty good &lt;1ms). But
&gt; &gt; &gt; I'm
&gt; &gt; &gt; wondering when to detect if the whole thing will come crashing
&gt; &gt; &gt; down.
&gt; &gt; &gt; 
&gt; &gt; &gt; I've used Cassandra for the last 20 months in production and had
&gt; &gt; &gt; the same
&gt; &gt; &gt; issue, it works great then it falls over, and unfortunately with
&gt; &gt; &gt; such evenly
&gt; &gt; &gt; space data, everything tends to fall over at once. I just don't
&gt; &gt; &gt; want that
&gt; &gt; &gt; to happen with my riak cluster, so am wondering how to tell if you
&gt; &gt; &gt; are close
&gt; &gt; &gt; to needing to grow.
&gt; &gt; &gt; 
&gt; &gt; &gt; Anyone have any ideas?
&gt; &gt; &gt; 
&gt; &gt; &gt; -Anthony
&gt; &gt; &gt; 
&gt; &gt; &gt; 
&gt; &gt; &gt; On Thu, Mar 24, 2011 at 01:21:05AM +0100, Nico Meyer wrote:
&gt; &gt; &gt; &gt; Hi Anthony,
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; are you sure you are not including the filesystem cache in your
&gt; &gt; &gt; &gt; mem\\_allocated values? It will grow to use all of the free memory
&gt; &gt; &gt; &gt; or
&gt; &gt; &gt; &gt; the total size of your bitcask data files, whichever is smaller.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; We have about 100Mio keys per node, and riak uses about 7GB of
&gt; &gt; &gt; &gt; RAM.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; Cheers,
&gt; &gt; &gt; &gt; Nico
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; On 23.03.2011 23:24, Anthony Molinaro wrote:
&gt; &gt; &gt; &gt; &gt; So a question about when to add new nodes. I'm looking at the
&gt; &gt; &gt; &gt; &gt; output of
&gt; &gt; &gt; &gt; &gt; this script and the output of riak-admin status to attempt to
&gt; &gt; &gt; &gt; &gt; figure out
&gt; &gt; &gt; &gt; &gt; if it's time to grow a cluster.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; I have 4 nodes 1024 partitions replication factor 3, currently
&gt; &gt; &gt; &gt; &gt; with a
&gt; &gt; &gt; &gt; &gt; single bitcask single bucket where both the key and the value
&gt; &gt; &gt; &gt; &gt; are 36 bytes.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; According to the bitcask spreadsheet the overhead per key is
&gt; &gt; &gt; &gt; &gt; 40 bytes
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; The current key counts/memory are
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; key\\_counts mem\\_total mem\\_allocated (key\\_\\_count\\*76)
&gt; &gt; &gt; &gt; &gt; node1 22381785 25269010432 21015953408 1701015660
&gt; &gt; &gt; &gt; &gt; node2 22378092 25269010432 14076137472 1700734992
&gt; &gt; &gt; &gt; &gt; node3 22373770 25269010432 21565509632 1700406520
&gt; &gt; &gt; &gt; &gt; node4 22382394 25269010432 21493731328 1701061944
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; node2 failed at some point and was replaced with with a new
&gt; &gt; &gt; &gt; &gt; node.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; So there is some oddness here I don't understand. According to
&gt; &gt; &gt; &gt; &gt; the
&gt; &gt; &gt; &gt; &gt; calculated value I should see about 1.7GB per box used,
&gt; &gt; &gt; &gt; &gt; instead I see
&gt; &gt; &gt; &gt; &gt; 21GB on most machines except for the one which was restarted
&gt; &gt; &gt; &gt; &gt; which has
&gt; &gt; &gt; &gt; &gt; 14GB. From looking at memory it seems like I should be adding
&gt; &gt; &gt; &gt; &gt; some nodes
&gt; &gt; &gt; &gt; &gt; real soon or amount allocated will hit the total amount. Or
&gt; &gt; &gt; &gt; &gt; maybe there's
&gt; &gt; &gt; &gt; &gt; a memory leak which will reduce the amount of memory (as with
&gt; &gt; &gt; &gt; &gt; node2)?
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; I'm just trying to figure out why I seem to almost be out of
&gt; &gt; &gt; &gt; &gt; memory with
&gt; &gt; &gt; &gt; &gt; 23 million documents when the Bitcask capacity planning
&gt; &gt; &gt; &gt; &gt; spreadsheet seems
&gt; &gt; &gt; &gt; &gt; to suggest I should be able to have 282 million with 20 GiB of
&gt; &gt; &gt; &gt; &gt; free Ram.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; Confused,
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; -Anthony
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; On Wed, Mar 16, 2011 at 12:04:48PM -0700, Aphyr wrote:
&gt; &gt; &gt; &gt; &gt; &gt; I'm trying to track some basic metrics so we can plan for
&gt; &gt; &gt; &gt; &gt; &gt; cluster
&gt; &gt; &gt; &gt; &gt; &gt; capacity, monitor transfers, etc. Figured this might be of
&gt; &gt; &gt; &gt; &gt; &gt; interest
&gt; &gt; &gt; &gt; &gt; &gt; to other riak admins. Apologies if my erlang is
&gt; &gt; &gt; &gt; &gt; &gt; nonidiomatic, I'm
&gt; &gt; &gt; &gt; &gt; &gt; still learning. :)
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; #!/usr/bin/env escript
&gt; &gt; &gt; &gt; &gt; &gt; %%! -name riakstatuscheck -setcookie riak
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; main([]) -&gt; main(["riak@127.0.0.1"]);
&gt; &gt; &gt; &gt; &gt; &gt; main([Node]) -&gt;
&gt; &gt; &gt; &gt; &gt; &gt; io:format("~w\\n", [
&gt; &gt; &gt; &gt; &gt; &gt; lists:foldl(
&gt; &gt; &gt; &gt; &gt; &gt; fun({{\\_VNode, Count}, Sum) -&gt; Sum + Count end,
&gt; &gt; &gt; &gt; &gt; &gt; 0,
&gt; &gt; &gt; &gt; &gt; &gt; rpc:call(list\\_to\\_atom(Node), riak\\_kv\\_bitcask\\_backend,
&gt; &gt; &gt; &gt; &gt; &gt; key\\_counts, [])
&gt; &gt; &gt; &gt; &gt; &gt; )
&gt; &gt; &gt; &gt; &gt; &gt; ]).
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; $ ./riakstatus riak@127.0.0.1
&gt; &gt; &gt; &gt; &gt; &gt; 18729
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; &gt; &gt; &gt; &gt; &gt; riak-users mailing list
&gt; &gt; &gt; &gt; &gt; &gt; riak-users@lists.basho.com
&gt; &gt; &gt; &gt; &gt; &gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; 
&gt; &gt; 
&gt; &gt; 
&gt; &gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; &gt; riak-users mailing list
&gt; &gt; riak-users@lists.basho.com
&gt; &gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt; &gt; 
&gt; 
&gt; 



\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

