---
title: "Deletion followed by re-addition leads to siblings when it shouldn't"
description: ""
project: community
lastmod: 2012-07-28T09:59:42-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg08109"
author_name: "Kaspar Thommen"
project_section: "mailinglistitem"
sent_date: 2012-07-28T09:59:42-07:00
---


Hi,

I ran the following Java snippet that creates a bucket, stores a key/value
pair in it, deletes the key, and adds a new value for that same key. The
n-value is 3 and all r- and w-values are also set to 3 to ensure full
consistency (for testing only). Here's the code:

 public static void main(String[] args) throws Exception {
 IRiakClient riak = RiakFactory.pbcClient();
 try {
 // store an object in a new bucket
 Bucket testBucket =
riak.createBucket("testBucket").nVal(3).allowSiblings(true).execute();
 testBucket.store("key", "value1").w(3).execute();

System.out.println(testBucket.fetch("key").r(3).execute().getValueAsString());
 // prints 'value1'

 // now delete it and store another object with the same key
 testBucket.delete("key").r(3).w(3).execute();
 testBucket.store("key", "value2").w(3).execute();

System.out.println(testBucket.fetch("key").r(3).execute().getValueAsString());
 // throws 'UnresolvedConflictException: Siblings found'

 } finally {
 riak.shutdown();
 }
 }

As you can see by the comment I have added to the code fetching the key a
second time should, in my opinion, return the new value, but it fails
because there are siblings. Maybe I didn't fully understand how sibling
handling works, but I don't see how there can possibly be any siblings
given that r and w are 3. Any pointers? I tried the LevelDB and memory
backends, same result.

Thanks,
Kaspar
