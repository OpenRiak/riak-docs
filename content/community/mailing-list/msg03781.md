---
title: "Re: Riak async PB client based on Grizzly"
description: ""
project: community
lastmod: 2011-06-22T05:49:26-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg03781"
mailinglist_parent_id: "msg03780"
author_name: "Russell Brown"
project_section: "mailinglistitem"
sent_date: 2011-06-22T05:49:26-07:00
---

On 22 Jun 2011, at 13:46, Jon Brisbin wrote:

&gt; 
&gt; 
&gt; Well, you have 2 choices
&gt; 
&gt; 1) Abstract away the fact that your client is async, so you can implement 
&gt; RiakResponse etc as wrappers around a Future, first call to a method calls 
&gt; get on the Future
&gt; 2) You can require your users to think aysnc and code callbacks
&gt; 
&gt; If you do the latter (or both) you might be best extending the RawClient 
&gt; interface (or just defining a new one (your RawAsyncClient)) if you re-use 
&gt; stuff like RiakResponse/IRiakObject etc then it would be awesome and much 
&gt; easier to integrate into the Basho library. It would be great to offer 
&gt; library users the option to go async without changing their higher-level code.
&gt; 
&gt; I think what I'd like to do is both. :)
&gt; 
&gt; I'll start with a RawAsyncClient that replaces direct object returns with 
&gt; Futures and override that with one that takes a callback. I'll also base the 
&gt; PBC stuff on both IRiakObject and borrow from what's already in the pbc 
&gt; support in the driver, but integrate some Builder abstractions (something I'm 
&gt; doing in-line now).
&gt; 
&gt; Once that's done, I can implement a version of RawClient that calls get() on 
&gt; everything, so it's fully compatible. But by using as much from the driver as 
&gt; I can, application code should be quite compatible, even on the fully async 
&gt; side.

Sounds awesome. I'll pitch in what I can. Post that repo link when you get it 
on Github, Jon.

Cheers

Russell

&gt; 
&gt; Thanks!
&gt; 
&gt; Jon Brisbin
&gt; http//jbrisbin.com
&gt; 
&gt; 
&gt; Whichever, get it up on github and we can start playing around with it! :D
&gt; 
&gt; 
&gt; Thanks!
&gt; 
&gt; Jon Brisbin
&gt; http//jbrisbin.com
&gt; 
&gt; 
&gt; From: "Russell Brown" 
&gt; To: "Jon Brisbin" 
&gt; Cc: "riak-users Users" 
&gt; Sent: Wednesday, June 22, 2011 2:27:17 AM
&gt; Subject: Re: Riak async PB client based on Grizzly
&gt; 
&gt; Hey Jon, 
&gt; Any chance you want to implement the RawClient interface 
&gt; (https://github.com/basho/riak-java-client/blob/master/src/main/java/com/basho/riak/client/raw/RawClient.java)
&gt; from the basho riak-java-client library? That way your client can be swapped 
&gt; straight into the basho lib?
&gt; 
&gt; If not, let me know when you get a repo up on github and I'll write an 
&gt; adapter so that the basho riak-java-client can make use of your Grizzly 
&gt; client, which I guess means I'll pitch in a little (time permitting) to help 
&gt; shape the Grizzly client so it is RawClient shaped.
&gt; 
&gt; Cheers
&gt; 
&gt; Russell
&gt; 
&gt; On 21 Jun 2011, at 17:58, Jon Brisbin wrote:
&gt; 
&gt; I'm trying to get my feet wet with Grizzly on another project, so I've been 
&gt; spending some late(ish) nights also working on a Grizzly-based asynchronous 
&gt; PB client for Riak. I'm dropping all the way down to the protobuf level and 
&gt; using Grizzly's NIO abstractions to implement a completely non-blocking 
&gt; client. I'm writing the low-level stuff in Java and I'd really like to build 
&gt; a Scala layer on top of this, which uses the nice Scala idioms (operators, 
&gt; case classes, etc...). But I can't write code as fast in Scala as I can in 
&gt; Java and some of the Java APIs inside Grizzly aren't all that Scala-friendly 
&gt; and make the code pretty ugly. I figured it would be better to implement a 
&gt; fairly low-level PB client in Java and flesh out the user-facing API in Scala 
&gt; and/or Java.
&gt; 
&gt; My question is basically, if I seed this project on GitHub with what I've got 
&gt; so far, would anyone else be interested in helping complete it? I'm just 
&gt; working on this after my other Grizzly work, so I can't devote full time to 
&gt; it. It might take me a little while to implement things like links and 
&gt; mapreduce.
&gt; 
&gt; I think it shows some real promise because it is completely non-blocking. It 
&gt; uses Futures and CompletionHandlers to do the dirty work. A Grizzly filter is 
&gt; responsible for the actual encoding/decoding of protobuf data. Right now, it 
&gt; will marshall JSON using Jackson if your content-type is set to 
&gt; "application/json", otherwise it uses JDK serialization to encode the entry 
&gt; (or just passes a String straight through, of course).
&gt; 
&gt; Since it's a first pass, there is no real attempt to separate the protobuf 
&gt; stuff from the client. That's a v2 thing. Since I have limited time, I'm 
&gt; interested in speed to completion of features rather than good-looking and 
&gt; properly abstracted code. :)
&gt; 
&gt; Thanks!
&gt; 
&gt; Jon Brisbin
&gt; http//jbrisbin.com
&gt; 
&gt; 
 
&gt; 
 
&gt; 

