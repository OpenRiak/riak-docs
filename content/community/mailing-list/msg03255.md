---
title: "Re: C++ Riak client?"
description: ""
project: community
lastmod: 2011-05-05T16:15:01-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg03255"
mailinglist_parent_id: "msg03246"
author_name: "David Leimbach"
project_section: "mailinglistitem"
sent_date: 2011-05-05T16:15:01-07:00
---


Thanks!

On Thu, May 5, 2011 at 3:11 PM, Mike Oxford  wrote:

&gt; Protobuf does not do inter-message delimiters. You have to handle that
&gt; aspect yourself.
&gt;
&gt; In the streambuf, put in the length of your protobuf message (in network
&gt; format), then the stream the message into it.
&gt; On the other end they should extract the length, convert to host format and
&gt; then read the data in and ship to protobuf.
&gt;

Ah this seems like some part I hadn't read up to yet... It's difficult to
do this stuff without contiguous blocks of time :-).

Some of this makes me want to also investigate using BERT or BERT-RPC
straight to erlang's "native" client for C++ bindings and just skip protocol
buffers altogether :-).

Yes I know protocol buffers are trendy and all, but even Google's Go
programming language doesn't support them natively (without external
packages). They did their own encoding as well (gob).

https://github.com/blog/531-introducing-bert-and-bert-rpc

http://bert-rpc.org/

Dave


&gt;
&gt; That's the 10,000 foot view.
&gt;
&gt; http://code.google.com/apis/protocolbuffers/docs/techniques.html
&gt;
&gt; --snip
&gt; If you want to write multiple messages to a single file or stream, it is up
&gt; to you to keep track of where one message ends and the next begins. The
&gt; Protocol Buffer wire format is not self-delimiting, so protocol buffer
&gt; parsers cannot determine where a message ends on their own. The easiest way
&gt; to solve this problem is to write the size of each message before you write
&gt; the message itself. When you read the messages back in, you read the size,
&gt; then read the bytes into a separate buffer, then parse from that buffer. (If
&gt; you want to avoid copying bytes to a separate buffer, check out the
&gt; CodedInputStream class (in both C++ and Java) which can be told to limit
&gt; reads to a certain number of bytes.)
&gt;
&gt; --end snip
&gt;
&gt; You do have to parse a message in its entirety; there is no incremental
&gt; parsing. If you have a message which wraps 10,000 messages you'll have to
&gt; load the whole thing in before you can parse.
&gt;
&gt; HTH.
&gt;
&gt; -mox
&gt;
&gt;
&gt;
&gt;
&gt;
&gt; On Thu, May 5, 2011 at 3:02 PM, David Leimbach  wrote:
&gt;
&gt;&gt; I haven't completely abandoned mine yet either, but I've been finding that
&gt;&gt; some of the I wanted to use with streambufs aren't going to pan out due to
&gt;&gt; the nature of a socket backed stream and the way protocol buffers expects it
&gt;&gt; to work. Protocol Buffers expects the stream to be terminated when done
&gt;&gt; receiving a message \\*THEN\\* parse it rather than building the parsing in (I
&gt;&gt; think that's what happened anyway... I really need to check my notes I took
&gt;&gt; when I ran into this). This does appear to make a simple socket fd backed
&gt;&gt; streambuf way to plug into any protocol buffers stream a bit more difficult
&gt;&gt; than I was hoping.
&gt;&gt;
&gt;&gt; Then again, I may just not be overriding a particular member function that
&gt;&gt; I should be either.
&gt;&gt;
&gt;&gt; Might get some time on the weekend to poke at this some more.
&gt;&gt;
&gt;&gt; On the plus side I definitely had some Riak RPC binary protocol bits
&gt;&gt; working. I was encoding/decoding Ping/Pong just fine (and they don't need
&gt;&gt; any Protocol Buffer anything to work).
&gt;&gt;
&gt;&gt; Dave
&gt;&gt;
&gt;&gt; On Sat, Apr 9, 2011 at 8:47 AM, Sean Cribbs  wrote:
&gt;&gt;
&gt;&gt;&gt; I didn't permanently abandon it, but it was much more fiddly than doing
&gt;&gt;&gt; the same thing in pure Ruby. I have plans to deliver separate "native"
&gt;&gt;&gt; Protocol Buffers libraries for MRI and JRuby (at least) in 1.0 of the Ruby
&gt;&gt;&gt; client.
&gt;&gt;&gt;
&gt;&gt;&gt; Because it's being confused in this conversation, I think it merits
&gt;&gt;&gt; clarification -- the "protocol" that is used to talk to Riak and Google's
&gt;&gt;&gt; Protocol Buffers are NOT the same thing. Riak uses a simple length- and
&gt;&gt;&gt; message-code-prefixed binary protocol, in which the complex messages (ones
&gt;&gt;&gt; that have bodies and not just the message code) are serialized via Google's
&gt;&gt;&gt; Protocol Buffers. So, while we don't use the RPC facilities in Google's
&gt;&gt;&gt; library, the \\*serialization format\\* DOES use Protocol Buffers.
&gt;&gt;&gt;
&gt;&gt;&gt; Sorry for the confusion, we'll work to make that clearer in the wiki.
&gt;&gt;&gt;
&gt;&gt;&gt; Sean Cribbs 
&gt;&gt;&gt; Developer Advocate
&gt;&gt;&gt; Basho Technologies, Inc.
&gt;&gt;&gt; http://basho.com/
&gt;&gt;&gt;
&gt;&gt;&gt; On Apr 8, 2011, at 9:17 PM, Scott Gonyea wrote:
&gt;&gt;&gt;
&gt;&gt;&gt; They are the same and you can actually see me plugging into the C++ code
&gt;&gt;&gt; here:
&gt;&gt;&gt;
&gt;&gt;&gt; https://github.com/sgonyea/pabst/tree/master/ext
&gt;&gt;&gt;
&gt;&gt;&gt; But as part of an Objective-C library (called ObjFW). So, the code is
&gt;&gt;&gt; actually an Objective-C++ wrapper around the C++ PB code, that exchanges
&gt;&gt;&gt; messages with Objective-C code (that hooks into Ruby).
&gt;&gt;&gt;
&gt;&gt;&gt; I believe Sean Cribbs has some initial C++-wrapper code in his Ripple
&gt;&gt;&gt; repo... Though he eventually abandoned it after C++ left him permanently
&gt;&gt;&gt; cross-eyed (I think that's why).
&gt;&gt;&gt;
&gt;&gt;&gt; Scott
&gt;&gt;&gt;
&gt;&gt;&gt; On Apr 8, 2011, at 5:20 PM, Mike Oxford wrote:
&gt;&gt;&gt;
&gt;&gt;&gt; Be careful here..
&gt;&gt;&gt;
&gt;&gt;&gt; I do not thing Riak's "protocol buffers" are the same as Google's
&gt;&gt;&gt; protocol buffers.
&gt;&gt;&gt; Google's does bit-level packing and some other tricks that Riak does
&gt;&gt;&gt; not do, even though they both use the ".proto" file extension and very very
&gt;&gt;&gt; similar proto semantics.
&gt;&gt;&gt;
&gt;&gt;&gt; That said, if they ARE the same, then you can take the .proto files and
&gt;&gt;&gt; generate C++ classes, and use the secondary library "protobuf-c" to generate
&gt;&gt;&gt; C structs for the wire format.
&gt;&gt;&gt;
&gt;&gt;&gt; -mox
&gt;&gt;&gt;
&gt;&gt;&gt; On Fri, Apr 8, 2011 at 4:43 PM, David Leimbach wrote:
&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Spent a little time poking at this today... Kind of surprised that there
&gt;&gt;&gt;&gt; was no message defined for PingReq or for listing buckets.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; I realize these messages really have no usable payload, and just sort of
&gt;&gt;&gt;&gt; have a tag and length, but for completeness it kind of feels like they
&gt;&gt;&gt;&gt; should be there.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Of course I'm not a Protocol Buffers expert in any sense, so I can't say
&gt;&gt;&gt;&gt; whether this is a normal kind of choice or not.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Dave
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; On Fri, Apr 8, 2011 at 2:49 PM, Scott Gonyea  wrote:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; If we had this then a C-wrapper would be that much more attainable. So,
&gt;&gt;&gt;&gt;&gt; the author of such a lib would be a superstar in my book :).
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; Sent from my iPhone
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; On Apr 8, 2011, at 1:46 PM, David Leimbach  wrote:
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; &gt; I've been writing a bit of code in Haskell to push data to Riak, and
&gt;&gt;&gt;&gt;&gt; the bindings are pretty easy to use (Thanks Brian!), but getting 
&gt;&gt;&gt;&gt;&gt; penetration
&gt;&gt;&gt;&gt;&gt; at my company for Haskell is going to take a little time.
&gt;&gt;&gt;&gt;&gt; &gt;
&gt;&gt;&gt;&gt;&gt; &gt; As such I'm just wondering if anyone knows of anyone working on a
&gt;&gt;&gt;&gt;&gt; protocol buffers version of a Riak client in C++, or if this is going to 
&gt;&gt;&gt;&gt;&gt; be
&gt;&gt;&gt;&gt;&gt; something I'll have to take on.
&gt;&gt;&gt;&gt;&gt; &gt;
&gt;&gt;&gt;&gt;&gt; &gt; I've found a few generic looking C++ projects that use Boost's
&gt;&gt;&gt;&gt;&gt; asynchronous IO stuff with protocol buffers to make an RPC system, but I'm
&gt;&gt;&gt;&gt;&gt; not sure if any of those are implicitly compatible.
&gt;&gt;&gt;&gt;&gt; &gt;
&gt;&gt;&gt;&gt;&gt; &gt; Guess I'm just looking for a pointer...
&gt;&gt;&gt;&gt;&gt; &gt;
&gt;&gt;&gt;&gt;&gt; &gt; Dave
&gt;&gt;&gt;&gt;&gt; &gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt;&gt;&gt;&gt; &gt; riak-users mailing list
&gt;&gt;&gt;&gt;&gt; &gt; riak-users@lists.basho.com
&gt;&gt;&gt;&gt;&gt; &gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;

&gt;&gt;&gt;
&gt;&gt;&gt;

&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;

&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;
