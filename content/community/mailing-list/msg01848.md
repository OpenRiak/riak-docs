---
title: "Re: Storing Sets in a new backend"
description: ""
project: community
lastmod: 2010-12-27T11:25:40-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg01848"
mailinglist_parent_id: "msg01836"
author_name: "Joel Meyer"
project_section: "mailinglistitem"
sent_date: 2010-12-27T11:25:40-08:00
---


On Tue, Dec 21, 2010 at 7:25 PM, Jeremiah Peschka &lt;
jeremiah.pesc...@gmail.com&gt; wrote:

&gt; I'm interested to see how it turns out.
&gt;
&gt; One question: Shouldn't you be able to determine equality from the vclocks?
&gt; Timestamps could run into issues if the clocks of different machines get out
&gt; of sync. They also don't allow for much granularity - there's always a
&gt; chance of collisions.
&gt;
&gt; How would this be any different from doing the same thing with bitcask or
&gt; InnoDB? Is it just your use of mmap to save memory space as opposed to
&gt; bitcask reading keys into RAM?
&gt;

Yes. In the other project Anthony referenced I only stored the hash of the
key (64 bits) and used mmap to let the the filesystem handle the caching of
pages while highly optimizing the on-disk format. Also, for that project,
the data constraints were a little different as updates only affected a
portion of the stored value, which I edited in place by flipping a few bits
on the mmap'ed region and then msync'ed occasionally.

Our datasets tend to be large, accessed randomly, and have tight
restrictions on access time. Using riak\\_core to distribute the data among
multiple machines and do ring management works well, while writing the core
data access/storage in C lets us optimize on disk format and work close to
the hardware.

(If I get time I'd like to rewrite the first project [a time-series
database] as a backend for Riak by doing some similar API overloading.)

Joel


&gt; Jeremiah Peschka
&gt;
&gt;
&gt; On Tue, Dec 21, 2010 at 8:02 PM, Anthony Molinaro &lt;
&gt; antho...@alumni.caltech.edu&gt; wrote:
&gt;
&gt;&gt; Hi,
&gt;&gt;
&gt;&gt; Just wondering if anyone had an opinions on this idea?
&gt;&gt;
&gt;&gt; Thanks,
&gt;&gt;
&gt;&gt; -Anthony
&gt;&gt;
&gt;&gt; On Fri, Dec 17, 2010 at 03:20:58PM -0800, Anthony Molinaro wrote:
&gt;&gt; &gt; Hi,
&gt;&gt; &gt;
&gt;&gt; &gt; I have a situation where I need to store sets of integers as
&gt;&gt; efficiently
&gt;&gt; &gt; as possible. In order to do so I was going to implement a custom
&gt;&gt; backend
&gt;&gt; &gt; and alter the semantics of get/put/delete, such that
&gt;&gt; &gt;
&gt;&gt; &gt; put (K, [{i,V}]) - insert one or more V into list at K
&gt;&gt; &gt; put (K, [{d,V}]) - delete one or more V from list at K
&gt;&gt; &gt; get (K) - returns list at K
&gt;&gt; &gt; delete (K) - delete entire list
&gt;&gt; &gt;
&gt;&gt; &gt; I'll probably keep the lists in sorted order via insertion sort so that
&gt;&gt; &gt; a quorum read can easily determine equality.
&gt;&gt; &gt;
&gt;&gt; &gt; My backend would probably be a linked in driver which mmaps a file so
&gt;&gt; &gt; I can keep this stuff as tightly packed in memory as possible.
&gt;&gt; &gt;
&gt;&gt; &gt; We did something similar using just riak\\_core for a different system,
&gt;&gt; &gt; but for that system we had a custom thrift frontend and didn't adhere
&gt;&gt; &gt; to the riak\\_kv api.
&gt;&gt; &gt;
&gt;&gt; &gt; So I was wondering, what sort of issues might I see with this sort of
&gt;&gt; &gt; use of riak? Is there another way I'm missing which would allow me
&gt;&gt; &gt; to efficiently do this?
&gt;&gt; &gt;
&gt;&gt; &gt; I expect in the end to have approximately 500 million lists of integers
&gt;&gt; &gt; with most in the ~10 integer range with a few up to the ~200 integer
&gt;&gt; &gt; range. Also, I'll probably have a timestamp associated with each
&gt;&gt; &gt; integer and want to use map-reduce to expire entries which are too old.
&gt;&gt; &gt;
&gt;&gt; &gt; Anway, I realize this might be an odd usage, and I can always fallback
&gt;&gt; &gt; to what we did before which was a thrift server on top up riak\\_core with
&gt;&gt; &gt; a custom datastore, but I figured if I could use the same API as riak\\_kv
&gt;&gt; &gt; with a custom backend it might save me a little time.
&gt;&gt; &gt;
&gt;&gt; &gt; -Anthony
&gt;&gt; &gt;
&gt;&gt; &gt; --
&gt;&gt; &gt; ------------------------------------------------------------------------
&gt;&gt; &gt; Anthony Molinaro &gt; &gt;
&gt;&gt;
&gt;&gt; --
&gt;&gt; ------------------------------------------------------------------------
&gt;&gt; Anthony Molinaro 

&gt;
&gt;

