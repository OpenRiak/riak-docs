---
title: "Re: Question: Object Not Saved After Save/Delete/Save"
description: ""
project: community
lastmod: 2011-06-04T08:24:55-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg03554"
mailinglist_parent_id: "msg03548"
author_name: "Sean Cribbs"
project_section: "mailinglistitem"
sent_date: 2011-06-04T08:24:55-07:00
---


I already have an issue open on the tracker to deal with some of the client 
semantics changes (https://github.com/seancribbs/ripple/issues/166); it might 
be broken out into separate issues so it can be completed.

Sean Cribbs 
Developer Advocate
Basho Technologies, Inc.
http://basho.com/

On Jun 3, 2011, at 6:19 PM, Andrew Thompson wrote:

&gt; On Fri, Jun 03, 2011 at 06:08:06PM -0400, Keith Bennett wrote:
&gt;&gt; Aphyr & Andrew -
&gt;&gt; 
&gt;&gt; Thanks for your responses. I'm trying to wrap my head around the issues you 
&gt;&gt; raised, and I must confess it's difficult. Anyway, some questions for you...
&gt;&gt; 
&gt;&gt; On Jun 3, 2011, at 5:12 PM, Andrew Thompson wrote:
&gt;&gt; 
&gt;&gt;&gt; On Fri, Jun 03, 2011 at 02:00:23PM -0700, Aphyr wrote:
&gt;&gt;&gt;&gt; Riak can't use the vclock for conflict resolution on a fresh object,
&gt;&gt;&gt;&gt; i.e. one without a vclock. Deletes are writes. You should use get or
&gt;&gt;&gt;&gt; reload before writing to help Riak sequence your writes correctly.
&gt;&gt; 
&gt;&gt; If the caller doesn't have a handle to the RObject in the Ruby framework, or 
&gt;&gt; the metadata of an HTTP response, but is only accessing the data by bucket 
&gt;&gt; and key values, is there any way to use reload? And if the object has been 
&gt;&gt; deleted is there any way to use get?
&gt;&gt; 
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; On top of this, Riak has some weirdness around very quick sequences
&gt;&gt;&gt;&gt; of deletes/writes due, IIRC, to deletes not being tagged with a
&gt;&gt;&gt;&gt; vector clock. I... think... this will be addressed in an upcoming
&gt;&gt;&gt;&gt; release.
&gt;&gt; 
&gt;&gt; I tried inserting a 20 second pause between each read/write, but there was 
&gt;&gt; no change in the behavior. Should it be longer than that?
&gt; 
&gt; This is scary, it should not be possible to trigger this behaviour with
&gt; such a large gap. Even 10ms was enough to prevent it in my testing.
&gt;&gt; 
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt; Ah, my favorite bug. This is indeed mostly solved on master by exposing
&gt;&gt;&gt; the vclocks for tombstones so they can be cleanly overwritten by the new
&gt;&gt;&gt; object rather than merged into a frankenobject that has the metadata of
&gt;&gt;&gt; the tombstone but the value of the new object (which is then subject to
&gt;&gt;&gt; real deletion).
&gt;&gt;&gt; 
&gt;&gt;&gt; So the fix for the issue was to add a new type of return value for a get
&gt;&gt;&gt; that finds a tombstone, {error, {deleted, Vclock}} instead of always
&gt;&gt;&gt; returning {error, notfound} on a true notfound or when a tombstone is
&gt;&gt;&gt; encountered.
&gt;&gt;&gt; 
&gt;&gt; 
&gt;&gt; That sounds like exactly what I need. Can I simulate that fix in my Ruby 
&gt;&gt; code? Any pointers about that? Any chance we could get that into the Ruby 
&gt;&gt; client? I'd be willing to put a little effort into that, but I don't really 
&gt;&gt; understand the issues well enough yet.
&gt; 
&gt; I suspect we will want to update the clients to support this, but I
&gt; don't know of a specific plan to do so yet. I don't know the details of
&gt; the ruby client enough (or at all) to advise on making changes to it.
&gt; 
&gt;&gt; 
&gt;&gt;&gt; An example of how to safely delete for all 3 APIs can be found at
&gt;&gt;&gt; 
&gt;&gt;&gt; https://gist.github.com/965376
&gt;&gt;&gt; 
&gt;&gt;&gt; Note the new deletedvclock option. The REST API will always use this
&gt;&gt;&gt; option on gets and will return a X-Riak-Vclock header along with any 404
&gt;&gt;&gt; that is actually a tombstone.
&gt;&gt;&gt; 
&gt;&gt;&gt; Some further reading can be found here:
&gt;&gt;&gt; 
&gt;&gt;&gt; https://issues.basho.com/show\\_bug.cgi?id=260
&gt;&gt;&gt; https://issues.basho.com/show\\_bug.cgi?id=555
&gt;&gt;&gt; 
&gt;&gt;&gt; So, long story short; either upgrade to master and use the deletedvclock
&gt;&gt;&gt; option or avoid doing rapid put/delete/put cycles.
&gt;&gt; 
&gt;&gt; You're suggesting I use mercurial to pull down the HEAD and use that, right?
&gt;&gt; 
&gt; 
&gt; git, not mercurial. I don't think we maintain the bitbucket repos
&gt; anymore, everything has moved to github.
&gt; 
&gt; Andrew
&gt; 
