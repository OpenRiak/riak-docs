---
title: "Re: Riak 1.0, Clojure and the Java Client"
description: ""
project: community
lastmod: 2011-10-10T16:39:44-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg05119"
mailinglist_parent_id: "msg05103"
author_name: "Aphyr"
project_section: "mailinglistitem"
sent_date: 2011-10-10T16:39:44-07:00
---

On 10/07/2011 04:23 PM, Tim Robinson wrote:


I just read the Satebox page you linked as an example and have a hard
time thinking I would want to use this. While automation is always nice,
the overhead is an unnecessary burden. Since Clojure provides
coordinated/transactional data structures, it's already easy \\*enough\\* to
resolve conflicts within your natural code flow without having to resort
to the rationalizing of queued values. Also, I can only speak for
myself, but I believe most people would only want this to apply in
selective cases such that a performance hit is not taken for the other
90% of data where last write winning is just fine.

Does that make sense to you? I could be completely off considering I
only read the 5 minute 'read-me' blurb.


Do you ever plan to have more than one clojure runtime modify the same 
object? For that matter, do you ever plan to restore a node from a 
backup or failure? That's where statebox comes into play.


--Kyle

