---
title: "Re: Correct way to use pbc/mapreduce to do multiget where keys and	bucket names are binary values?"
description: ""
project: community
lastmod: 2011-06-16T10:14:47-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg03722"
mailinglist_parent_id: "msg03556"
author_name: "Jacques"
project_section: "mailinglistitem"
sent_date: 2011-06-16T10:14:47-07:00
---


Well that figures. In micro benchmarks (always unreliable), the two are
not even close . The 20 separate gets blow the map reduce multiget out of
the water. With info likely in os disk cache, we see:

20 gets including forking/joining: ~25ms total
single map reduce multiget using erlang: ~250ms

I guess there must be a lot of overhead using the map reduce framework.

This is for my local single node testing cluster. I'll have to retest in a
multinode cluster...

Is this in alignment with what others are seeing?

Thanks,
Jacques

On Thu, Jun 16, 2011 at 9:52 AM, Jacques  wrote:

&gt; Thanks for the info. As a note, I found that the javascript function was
&gt; having trouble return binary values.
&gt;
&gt; I followed your suggestion and am now using the following function. (Here
&gt; for others.)
&gt;
&gt; -module(multiget).
&gt; -export([key\\_value/3]).
&gt;
&gt; key\\_value({error, notfound}, \\_KD, \\_) -&gt;
&gt; none;
&gt; key\\_value(RiakObject, \\_KD, \\_) -&gt;
&gt; [riak\\_object:bucket(RiakObject),riak\\_object:key(RiakObject),
&gt; riak\\_object:get\\_value(RiakObject)].
&gt;
&gt;
&gt; Thanks again for your help. I haven't done performance tests yet but am
&gt; hoping that this is more performant than 20 individual gets.
&gt;
&gt; I must say that I'm still quite surprised that a key value store of Riak's
&gt; caliber doesn't have a native binary multiget within the core pbc api.
&gt;
&gt; Jacques
&gt;
&gt; On Thu, Jun 16, 2011 at 5:03 AM, Russell Brown wrote:
&gt;
&gt;&gt; Hi Jaques,
&gt;&gt; Sorry for the slow reply. I think this one just slipped by me.
&gt;&gt;
&gt;&gt; Ok. answers inline below:
&gt;&gt;
&gt;&gt; On 14 Jun 2011, at 18:26, Jacques wrote:
&gt;&gt;
&gt;&gt; Does anybody have any insight on my questions below?
&gt;&gt;
&gt;&gt; Thanks,
&gt;&gt; Jacques
&gt;&gt;
&gt;&gt;
&gt;&gt; On Tue, Jun 7, 2011 at 6:12 PM, Jacques  wrote:
&gt;&gt;
&gt;&gt;&gt; I've been working on this. I have it working with an anonymous
&gt;&gt;&gt; javascript function. I was hoping to move it to using the
&gt;&gt;&gt; "map\\_object\\_value" built-in erlang function. However, when I attempt to use
&gt;&gt;&gt; this function, I get failures if any of my keys don't exist. Is there a way
&gt;&gt;&gt; to construct my map phase so that it gracefully handles not founds and just
&gt;&gt;&gt; returns what it finds?
&gt;&gt;
&gt;&gt;
&gt;&gt; Yes. riak\\_kv\\_mapreduce:map\\_object\\_value accepts an arg value of
&gt;&gt; either "filter\\_notfound", "include\\_notfound" or "include\\_keydata", so your
&gt;&gt; not found values can be omitted by passing "filter\\_notfound" as the arg
&gt;&gt; value for the map phase (instead of ATOM\\_NONE in your construction.)
&gt;&gt;
&gt;&gt;
&gt;&gt;&gt; Also, using this function, is there a way to return the bucket and key
&gt;&gt;&gt; names?
&gt;&gt;&gt;
&gt;&gt;
&gt;&gt; No not using riak\\_kv\\_mapreduce:map\\_object\\_value, you could use
&gt;&gt; riak\\_kv\\_mapreduce:map\\_identity to get the whole riak object (meta data, key
&gt;&gt; and value) or just write your own map reduce function that returns the data
&gt;&gt; you want (and can filter out the not founds just like map\\_object\\_value)
&gt;&gt;
&gt;&gt; Or can one assume the response order is identical to the order of inputs?
&gt;&gt;&gt;
&gt;&gt;
&gt;&gt; No.
&gt;&gt;
&gt;&gt; deletia
&gt;&gt;
&gt;&gt;
&gt;&gt; Cheers
&gt;&gt;
&gt;&gt; Russell
&gt;&gt;
&gt;&gt;
&gt;
