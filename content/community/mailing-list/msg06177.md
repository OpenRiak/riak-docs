---
title: "Re: riak-erlang-client write, riak-java-client read problem"
description: ""
project: community
lastmod: 2012-01-09T05:28:50-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg06177"
mailinglist_parent_id: "msg06176"
author_name: "Sean Cribbs"
project_section: "mailinglistitem"
sent_date: 2012-01-09T05:28:50-08:00
---


Marcel,

Sorry for the confusion, I missed one significant detail.
mochijson2:encode/1 will return an iolist (a list of lists and binaries).
Wrap the call to mochijson2:encode/1 in erlang:iolist\\_to\\_binary/1, like so:

Value = erlang:iolist\\_to\\_binary(mochijson2:encode({struct, [{id, 22}]})).

Hope that helps.

On Mon, Jan 9, 2012 at 7:56 AM, Marcel MÃ¼ller wrote:

&gt; Hi Sean,
&gt;
&gt; thanks for your help but we found another problem:
&gt;
&gt; after we insert the valid json:
&gt; {ok,Pid} = riakc\\_pb\\_socket:start\\_link("10.10.10.74", 8087),
&gt; Value = mochijson2:encode({struct, [{id, 22}]}),
&gt; In = riakc\\_obj:new(&lt;&lt;"mm"&gt;&gt;,&lt;&lt;"1"&gt;&gt;,Value,"application/json"),
&gt; riakc\\_pb\\_socket:put(Pid,In)
&gt;
&gt; we read it from erlang:
&gt;
&gt; {ok, Obj} = riakc\\_pb\\_socket:get(Pid,"mm","1"),
&gt; io:format("Obj: ~p~n",[Obj]),
&gt; ContentType = riakc\\_obj:get\\_content\\_type(Obj),
&gt; io:format("ContentType: ~p~n",[ContentType]),
&gt;
&gt; Obj: {riakc\\_obj,"mm","1",
&gt;
&gt; &lt;&lt;107,206,97,96,96,96,204,96,202,5,82,28,202,156,255,126,250,
&gt;
&gt; 115,109,75,206,96,74,228,206,99,101,152,17,87,127,130,47,11,0&gt;&gt;,
&gt; [{{dict,3,16,16,8,80,48,
&gt; {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]},
&gt; {{[],[],[],[],[],[],[],[],[],[],
&gt;
&gt; [[&lt;&lt;"X-Riak-VTag"&gt;&gt;,51,122,101,57,117,75,111,98,113,
&gt; 118,97,77,100,117,114,76,97,56,122,68,115,70],
&gt;
&gt; [&lt;&lt;"content-type"&gt;&gt;,97,112,112,108,105,99,97,116,
&gt;
&gt; 105,111,110,47,120,45,101,114,108,97,110,103,45,
&gt; 98,105,110,97,114,121]],
&gt; [],[],
&gt;
&gt; [[&lt;&lt;"X-Riak-Last-Modified"&gt;&gt;|{1326,113432,240315}]],
&gt; [],[]}}},
&gt; &lt;&lt;131,107,0,4,84,69,83,84&gt;&gt;}],
&gt; undefined,undefined}
&gt; ContentType: "application/x-erlang-binary"
&gt;
&gt; We received every time x-erlang-binary
&gt;
&gt; When we wrote the same over the http api for example:
&gt;
&gt; curl -X PUT -H "Content-Type: application/json" -i
&gt; http://127.0.0.1:8098/riak/mm/2 -d '{"email:","email to email.com
&gt; ","pass":"123123"}'
&gt;
&gt; Obj: {riakc\\_obj,"mm","2",
&gt;
&gt; &lt;&lt;107,206,97,96,96,96,204,96,202,5,82,28,202,156,255,126,250,
&gt;
&gt; 115,157,14,206,96,74,100,204,99,101,232,115,175,63,193,151,5,
&gt; 0&gt;&gt;,
&gt; [{{dict,3,16,16,8,80,48,
&gt; {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]},
&gt; {{[],[],[],[],[],[],[],[],[],[],
&gt;
&gt; [[&lt;&lt;"X-Riak-VTag"&gt;&gt;,122,97,52,89,80,115,106,112,121,
&gt; 57,118,98,68,81,114,66,56,72,109,78,52],
&gt;
&gt; [&lt;&lt;"content-type"&gt;&gt;,97,112,112,108,105,99,97,116,
&gt; 105,111,110,47,106,115,111,110]],
&gt; [],[],
&gt;
&gt; [[&lt;&lt;"X-Riak-Last-Modified"&gt;&gt;|{1326,107534,668061}]],
&gt; [],[]}}},
&gt; &lt;&lt;"{\\"email:\\",\\"email to email.com
&gt; \\",\\"pass\\":\\"123123\\"}"&gt;&gt;}],
&gt; undefined,undefined}
&gt; ContentType: "application/json"
&gt;
&gt;
&gt; It looks like the risk\\_obj:new don't write the right content-type.
&gt;
&gt; Can you imagine why ?
&gt;
&gt; Thanks
&gt; Marcel
&gt;
&gt;
&gt; Am 07.01.2012 um 18:29 schrieb Sean Cribbs:
&gt;
&gt; Marcel,
&gt;
&gt; {ok,Pid} = riakc\\_pb\\_socket:start\\_link("127.0.0.1", 8087),
&gt;&gt; Tuple = "{\\"id\\",22}",
&gt;&gt;
&gt;
&gt; That is not valid JSON, first of all.
&gt;
&gt;
&gt;&gt; Obj = riakc\\_obj:new("mm","1",Tuple),
&gt;&gt;
&gt;
&gt; Make sure that you set the content type here, otherwise it won't be
&gt; detected on the Java side. (example below)
&gt;
&gt;
&gt;&gt; riakc\\_pb\\_socket:put(Pid,Obj),
&gt;&gt;
&gt;&gt; After then we try to read from risk-java-client:
&gt;&gt;
&gt;&gt; RiakClient httpClient = new RiakClient("http://10.10.10.61:8098/riak");
&gt;&gt; IRiakClient client = RiakFactory.httpClient(httpClient);
&gt;&gt; Bucket b = client.fetchBucket("mm").execute();
&gt;&gt; IRiakObject fetched = b.fetch("1").execute();
&gt;&gt; String decodedString = new String(fetched.getValue());
&gt;&gt; System.out.println(decodedString);
&gt;&gt;
&gt;&gt; I convert the Object to an HexString: 83 6B 00 05 7B 22 6E 22 7D
&gt;&gt;
&gt;&gt;
&gt; Decoding that byte array in Erlang gives:
&gt;
&gt; 1&gt; &lt;&lt;16#83,16#6B,0,5,16#7B,16#22,16#6E,16#22,16#7D&gt;&gt;.
&gt; &lt;&lt;131,107,0,5,123,34,110,34,125&gt;&gt;
&gt; 2&gt; binary\\_to\\_term(v(1)).
&gt; "{\\"n\\"}"
&gt; 3&gt;
&gt;
&gt; The default behavior of the Erlang client is to serialize terms to binary
&gt; unless the content type is explicit and the value of the object is a
&gt; binary. Try this instead:
&gt;
&gt; Value = mochijson2:encode({struct, [{id, 22}]}),
&gt; Obj = riakc\\_obj:new(&lt;&lt;"mm"&gt;&gt;,&lt;&lt;"1"&gt;&gt;,Value,"application/json"),
&gt; riakc\\_pb\\_socket:put(Pid, Obj)
&gt;
&gt; Then re-read it from the Java side and you should get what you expect.
&gt;
&gt; My question is:
&gt;&gt;
&gt;&gt; 1. What are the first 4 bytes ?
&gt;&gt;
&gt;
&gt; A binary that starts with byte 131 is typically in Erlang
&gt; term\\_to\\_binary/binary\\_to\\_term format.
&gt;
&gt;
&gt;&gt; 2. how can i receive a string with out the 4 bytes ?
&gt;&gt;
&gt;
&gt; See above.
&gt;
&gt;
&gt;&gt; 3. How can i convert the string into a JSON Object ?
&gt;&gt;
&gt;&gt;
&gt; See above, and then use Jackson to decode the value (I believe the Java
&gt; client may do this automatically for you).
&gt;
&gt; --
&gt; Sean Cribbs 
&gt; Software Engineer
&gt; Basho Technologies, Inc.
&gt; http://basho.com/
&gt;
&gt;
&gt;


-- 
Sean Cribbs 
Software Engineer
Basho Technologies, Inc.
http://basho.com/
