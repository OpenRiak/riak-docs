---
title: "Re: deleting keys"
description: ""
project: community
lastmod: 2011-06-01T07:43:19-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg03518"
mailinglist_parent_id: "msg03517"
author_name: "Sean Cribbs"
project_section: "mailinglistitem"
sent_date: 2011-06-01T07:43:19-07:00
---


Good point, Eric. This is the primary reason that Ripple switched to ISO 8601 
format as the default; also that other languages will often use ISO 8601, 
whereas RFC 822 is less common.

Sean Cribbs 
Developer Advocate
Basho Technologies, Inc.
http://basho.com/

On Jun 1, 2011, at 10:33 AM, Eric Moritz wrote:

&gt; Depending on what you need the date for, you may be able to skip the
&gt; parsing step. If you're using it for sorting or comparison, ISO8601
&gt; can be compared lexicographically and usually no parsing is needed,
&gt; "earlier\\_isodate &lt; later\\_isodate" will be true in Javascript even
&gt; though they're strings. I just wanted to point that out in case you
&gt; over looked this property of ISO8061 formatted strings.
&gt; 
&gt; Eric.
&gt; 
&gt; 
&gt; On Wed, Jun 1, 2011 at 9:45 AM, Sean Cribbs  wrote:
&gt;&gt; Rob,
&gt;&gt; 
&gt;&gt; Yes, you can use the provided iso8601.js file (only generated for you in a 
&gt;&gt; Rails 3 project, unfortunately, but you can grab it from inside the gem or 
&gt;&gt; on github) to parse ISO8601 Dates. You'll need to set the js\\_source\\_dir in 
&gt;&gt; app.config to point to the directory where this lives.
&gt;&gt; 
&gt;&gt; If we upgrade erlang\\_js to a later version of Spidermonkey in the future, 
&gt;&gt; the iso8601.js file will no longer be needed (1.8.5 supports ISO8601). You 
&gt;&gt; can also choose to use RFC822-style dates by setting Ripple.date\\_format = 
&gt;&gt; :rfc822.
&gt;&gt; 
&gt;&gt; Sean Cribbs 
&gt;&gt; Developer Advocate
&gt;&gt; Basho Technologies, Inc.
&gt;&gt; http://basho.com/
&gt;&gt; 
&gt;&gt; On Jun 1, 2011, at 9:37 AM, Dingwell, Robert A. wrote:
&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt; Thanks,
&gt;&gt;&gt; 
&gt;&gt;&gt; I was trying to use the number of keys as an indication of how many objects 
&gt;&gt;&gt; there were in a bucket but I see that is not the smartest approach. I 
&gt;&gt;&gt; didn't see anything that was an indication of the number of items in a 
&gt;&gt;&gt; bucket , is there anything if riak like this or do I need to create a map 
&gt;&gt;&gt; reduce job for this?
&gt;&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt; This is totally off the original topic but another question I have is 
&gt;&gt;&gt; related to javascript Date objects. In ripple if I have a field that is a 
&gt;&gt;&gt; Time field it serializes to riak as a iso8601 string representation of the 
&gt;&gt;&gt; object. When performing a map reduce job on the bucket related to the 
&gt;&gt;&gt; ripple class I have if I attempt to create a javascript Date object from 
&gt;&gt;&gt; the string in the stored object I get an Invalid Date error. Is this just 
&gt;&gt;&gt; due to a limitation in the version of spider monkey being used?
&gt;&gt;&gt; 
&gt;&gt;&gt; Thanks
&gt;&gt;&gt; 
&gt;&gt;&gt; Rob
&gt;&gt;&gt; 
&gt;&gt;&gt; On May 31, 2011, at 8:44 PM, Sean Cribbs wrote:
&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; Robert,
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; What Keith said is misleading -- that key cache was solely in the Ruby 
&gt;&gt;&gt;&gt; client driver and not part of Riak itself.
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; In Riak, deletes have two phases; in the first, so-called "tombstones" are 
&gt;&gt;&gt;&gt; written to the partitions that own replicas of the key. The tombstone has 
&gt;&gt;&gt;&gt; special metadata marking it as such and an empty value, but has a 
&gt;&gt;&gt;&gt; descendant vector clock from the last known value. In the second phase, 
&gt;&gt;&gt;&gt; the tombstones are read back from the replicas, and iff they all are 
&gt;&gt;&gt;&gt; tombstones (that is, all replicas respond, and all are tombstones), a 
&gt;&gt;&gt;&gt; reaping command is sent such that they will be cleared from the backend.
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; In your case, what may have occurred is that the replica chosen for 
&gt;&gt;&gt;&gt; key-listing did not receive the tombstone write (only 1/n\\_val of all 
&gt;&gt;&gt;&gt; partitions are consulted for key-lists), or had not yet received the 
&gt;&gt;&gt;&gt; reaping command. When you read the key again, you obviously get a "not 
&gt;&gt;&gt;&gt; found" because the other replicas will resolve to a tombstone. Eventually 
&gt;&gt;&gt;&gt; your read requests will invoke read-repair, updating the stale partition 
&gt;&gt;&gt;&gt; and causing the value to be reaped.
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; The moral of the story here is, again, don't rely on key-listings for 
&gt;&gt;&gt;&gt; strong indications of cluster state.
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; Sean Cribbs 
&gt;&gt;&gt;&gt; Developer Advocate
&gt;&gt;&gt;&gt; Basho Technologies, Inc.
&gt;&gt;&gt;&gt; http://basho.com/
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; On May 31, 2011, at 8:12 PM, Keith Bennett wrote:
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt;&gt; Robert -
&gt;&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt;&gt; Until a source code change a few days ago, riak would by default cache 
&gt;&gt;&gt;&gt;&gt; the keys reported to be in a bucket, so after fetching them once they 
&gt;&gt;&gt;&gt;&gt; would not be updated after deletions, additions, etc. The key is indeed 
&gt;&gt;&gt;&gt;&gt; gone, but the keys API did not report the change.
&gt;&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt;&gt; If you go to the message archive at 
&gt;&gt;&gt;&gt;&gt; http://lists.basho.com/pipermail/riak-users\\_lists.basho.com/2011-May/thread.html,
&gt;&gt;&gt;&gt;&gt; and search for "Riak cleint resources", you'll see the ruckus that I 
&gt;&gt;&gt;&gt;&gt; started a week and a half ago about this very subject. ;)
&gt;&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt;&gt; There is an option to force the reloading of keys but I forget what it 
&gt;&gt;&gt;&gt;&gt; is, and anyway it is now gone from the current code base since the 
&gt;&gt;&gt;&gt;&gt; strategy was changed. Be warned that using the keys method is, anyway, 
&gt;&gt;&gt;&gt;&gt; as Sean Cribbs pointed out to me, in general an awful idea, and almost 
&gt;&gt;&gt;&gt;&gt; always should be avoided. This is because it's a very expensive 
&gt;&gt;&gt;&gt;&gt; operation -- in order to accomplish it, all keys in the data store need 
&gt;&gt;&gt;&gt;&gt; to be accessed.
&gt;&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt;&gt; My guess is that testing for the exception you encountered is probably 
&gt;&gt;&gt;&gt;&gt; the best way to test for existence/absence of a key, but hopefully those 
&gt;&gt;&gt;&gt;&gt; more knowledgeable than I will enlighten us on that.
&gt;&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt;&gt; - Keith
&gt;&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt;&gt; On May 31, 2011, at 7:23 PM, Dingwell, Robert A. wrote:
&gt;&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt;&gt;&gt; Hi,
&gt;&gt;&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt;&gt;&gt; When deleting a key from a bucket I'm noticing that the object 
&gt;&gt;&gt;&gt;&gt;&gt; associated with the key is gone but the key itself is still sticking 
&gt;&gt;&gt;&gt;&gt;&gt; around. I loop though all of the keys in a bucket and then call delete 
&gt;&gt;&gt;&gt;&gt;&gt; on each one, the object for the key is then gone so if I try to get the 
&gt;&gt;&gt;&gt;&gt;&gt; object for that key I get a 404 as expected. But if I look at the 
&gt;&gt;&gt;&gt;&gt;&gt; bucket in the browser with the keys=true parameter, all of the keys are 
&gt;&gt;&gt;&gt;&gt;&gt; still there. Is this normal and if so how do I get rid of the keys?
&gt;&gt;&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt;&gt;&gt; Thanks\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt;&gt;&gt;&gt;&gt; riak-users mailing list
&gt;&gt;&gt;&gt;&gt;&gt; riak-users@lists.basho.com
&gt;&gt;&gt;&gt;&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt; 
&gt;&gt; 
&gt;&gt; 
&gt; 
