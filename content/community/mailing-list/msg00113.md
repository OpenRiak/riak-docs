---
title: "Re: one-to-very-many link associations"
description: ""
project: community
lastmod: 2010-04-22T06:02:06-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg00113"
mailinglist_parent_id: "msg00111"
author_name: "Sean Cribbs"
project_section: "mailinglistitem"
sent_date: 2010-04-22T06:02:06-07:00
---


Orlin,

One thing that you imply is that you would always be using the Link header to 
represent links. Another way to cope with large numbers of links is to 
encapsulate them in the object itself, rather than in the headers. This 
removes the header-length/count limitation, but would require you to have a map 
function that understands the internals of the object. Also, you would need to 
deal with the larger size of the object, which could potentially slow down your 
request.

In Ripple, I intend to support secondary link-storing objects through 
associations. You would associate the secondary object by key (i.e. it would 
have the same key as the owner), and then that secondary object would have a 
link association to the targets. Then the origin/owner object would have the 
transitive association via a simple method delegation. As I told the Raleigh 
Ruby group on Tuesday, "I want to provide just enough tools to shoot yourself 
in the foot." Having a convention is helpful, but won't substitute for 
thoughtful evaluation of your data model.

One of the "other options" that I didn't mention was a graph database. If your 
model seems to beg lots and lots of links, you might be better off looking at 
something that fits the traversal model better, like Neo4J, AllegroGraph, etc. 
You could still use Riak for storing the primary objects, but keep your tightly 
interrelated stuff in the graph DB. Remember, nosql is about choice and using 
the best tool for the job!

Sean Cribbs 
Developer Advocate
Basho Technologies, Inc.
http://basho.com/

On Apr 22, 2010, at 4:23 AM, Orlin Bozhinov wrote:

&gt; Riak Users, 
&gt; 
&gt; Thinking about a data modeling pattern that will allow one to not worry about 
&gt; how many links can be had with one-to-many (or many-to-many) scenarios. This 
&gt; question has come up before in various places. One answer I like is Sean's 
&gt; from this thread http://riak.markmail.org/thread/6e7ypt5ndjzjk7mr saying: 
&gt; "... at the point where you have that many links it becomes necessary to 
&gt; consider other options, including intermediary objects or alternative ways of 
&gt; representing the relationship". I wonder if an \\_intermediary way\\_ could be 
&gt; baked into Ripple (or your client library of choice). This is for the cases 
&gt; when one-to-many can become one-to-very-many. 
&gt; 
&gt; To make it more interesting, let's say we want to add metadata to the 
&gt; relationship as described in the pre-last paragraph of 
&gt; http://blog.basho.com/2010/03/25/schema-design-in-riak---relationships/. 
&gt; Here is what I have in mind: {from}-&gt;{from\\_association}-&gt;{association}-&gt;{to} 
&gt; -- the {curlied} are bucket / objects and -&gt; are links. For example if 
&gt; {from} = "user"; and {association} = "interest"; and {to} = {whatever} there 
&gt; is interest in - e.g. "event", "place", "story", another "user" or even 
&gt; self-interest :) But I'm getting ahead of myself. Let's use a recent 
&gt; example from Basho's blog where a "user" links {to} = "task". So we get: 
&gt; user -has--&gt; user\\_interest -meta--&gt; interest -in--&gt; task. 
&gt; 
&gt; The "interest" association could imply "ownership" but maybe the application 
&gt; allows its "users" to express interest another's "task". Maybe it's a 
&gt; collaborative effort... Reverse-linking from the many interests / tasks to 
&gt; their respective owners is easy because it's just a single link for task 
&gt; -of--&gt; user or interest -of--&gt; user. In the interests bucket I want to put 
&gt; all kinds of useful metadata. There I would embed (via Composition as Ripple 
&gt; calls it) not only all the "tags", but also "notes", "star", etc. Think 
&gt; delicious bookmarks or google reader items and so on. It seems like a common 
&gt; pattern. Something that may fit the use case of @botanicus too. One could 
&gt; represent all possible links (various associations) between two objects as 
&gt; metadata contained in a given "interest". Ownership can be a type of 
&gt; interest for the sake of link-walking. 
&gt; 
&gt; There are three things happening here: 
&gt; 1. the "very many" (links through intermediary objects)
&gt; 2. optional metadata (yet another intermediary object) - multiple 
&gt; associations between any two objects can be expressed through extra metadata 
&gt; rather than extra links
&gt; 3. reusing the "very-many" and / or metadata intermediaries -linking--&gt; to 
&gt; objects in different buckets
&gt; 
&gt; The real issue (that #1 solves) is not having an easy ability to do "very 
&gt; many" links originating from the same object. The #2 metadata object vs a 
&gt; few extra links for tags / notes (which are insignificant compared to the 
&gt; many interests a user can have) - makes it easier (in my eyes) to put in 
&gt; Redis for filtering... Of-course interests (#2) could be specialized 
&gt; (different metadata models) with regards to what they are about (#3). On 
&gt; delicious that's just bookmarks. I've got close to 6,000 of them. Does that 
&gt; approach "very many" in terms of Riak? If "very many" were easier to do 
&gt; (with client-library models or otherwise Riak itself) #2 & #3 would be 
&gt; indifferent about which intermediary leads to them (an extra link-walk step) 
&gt; as they are already possible anyway. How could we step (automagically) 
&gt; through an intermediary object (the user\\_interest "very many" enabler bucket) 
&gt; - having a specific target object in mind? 
&gt; 
&gt; I think it may already be possible with current link-walking. Then it's all 
&gt; a matter of managing the intermediary bucket / objects. Not exactly sure how 
&gt; the max links are calculated. According to one formula from the mailing list 
&gt; I may get 1000 headers (limit in mochiweb) \\* 200 links ("around 40 chars per 
&gt; link") = 200,000 links max? That seems like "very many", but there was also 
&gt; something about performance burden... If we took those 200 with just a 
&gt; single header, pointing to 200 intermediary objects, each pointing to another 
&gt; 200 target objects we would get 40,000 links. That's quite a few. Of-course 
&gt; that number could easily get much much bigger (square the default limit). 
&gt; What decides how many links per intermediary object is ideal? Is it a 
&gt; setting that Basho could recommend a default for? Could Ripple automate 
&gt; that? Some link creation logic is needed and if Riak doesn't support it, the 
&gt; client libraries that do "associations" are a good candidate for the task. 
&gt; Also with link deletion - we'll need to either keep track of link count per 
&gt; intermediary or run map-reduce jobs to clean-up once in a while... 
&gt; 
&gt; In either case, link creation should be as simple as knowing which 
&gt; intermediary object is the last one and whether we should add the next new 
&gt; link through it or through a new intermediary (when a certain link count 
&gt; \\_setting\\_ is reached). If this could be automated then it wouldn't matter 
&gt; how many the links are. Otherwise Riak would have to be monitored and if 
&gt; certain links begin to get "very many" then a model migration is run to make 
&gt; the transition from few straight links to very many. If client libraries 
&gt; could work with both kinds of links then this transition would mean tweaking 
&gt; the model association (and link walking remaining the same). But when using 
&gt; Riak's raw interface there would be a difference, which means a switch from 
&gt; one-to-many to one-to-very-many will usually take some thinking / effort. 
&gt; Any time I'm in doubt, it seems safer to side with the very-many (just in 
&gt; case). What is the cost of an extra step of link-walking as compared to 
&gt; changing application code? 
&gt; 
&gt; As another example, if one were to build GitHub with Riak, how would you 
&gt; model the watching & following associations? Many users would use few, but 
&gt; some would use many, which in a few cases get to be very many, which means 
&gt; everybody will watch and follow in very-many style. If the app ui allows it, 
&gt; one has to assume it will happen... Here is the following / watching example 
&gt; for very many - different words for having interest in something:
&gt; 
&gt; \\* separate very-many:
&gt; user -does--&gt; user\\_following -what--&gt; user
&gt; user -does--&gt; user\\_watching -what--&gt; repo (-of--&gt; user)
&gt; \\* combined very-many:
&gt; user -has--&gt; user\\_interest -for--&gt; {whatever}
&gt; \\* combined very-many + metadata:
&gt; user -has--&gt; user\\_interest -meta--&gt; interest -for--&gt; {whatever}
&gt; \\* and if metadata was different, perhaps:
&gt; user -has--&gt; user\\_interest -meta--&gt; interest\\_user -what--&gt; user
&gt; user -has--&gt; user\\_interest -meta--&gt; interest\\_repo -what--&gt; repo
&gt; 
&gt; Whatever the pattern, it would be nice to have the best practices defined and 
&gt; implemented for reuse (via association-proficient client libs - a la Ripple). 
&gt; After all, Riak users like big data, which is another way of saying very 
&gt; many items of stuff -- and why not very many hands / links too :)
&gt; 
&gt; Orlin
&gt; 

