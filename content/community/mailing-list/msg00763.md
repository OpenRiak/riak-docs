---
title: "Re: Expected vs Actual Bucket Behavior"
description: ""
project: community
lastmod: 2010-07-20T23:22:20-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg00763"
mailinglist_parent_id: "msg00756"
author_name: "Daniel Einspanjer"
project_section: "mailinglistitem"
sent_date: 2010-07-20T23:22:20-07:00
---

 On 7/20/10 6:00 PM, Eric Filson wrote:
On Tue, Jul 20, 2010 at 3:02 PM, Justin Sheehy &gt; wrote:


 Hi, Eric! Thanks for your thoughts.

 On Tue, Jul 20, 2010 at 12:39 PM, Eric Filson &gt; wrote:

 &gt; I would think that this requirement,
 &gt; retrieving all objects in a bucket, to be a \\_very\\_ common
 &gt; place occurrence for modern web development and perhaps
 (depending on
 &gt; requirements) \\_the\\_ most common function aside from retrieving a
 single k/v
 &gt; pair.

 I tend to see people that mostly try to write applications that don't
 select everything from a whole bucket/table/whatever as a very
 frequent occurrence, but different people have different requirements.
 Certainly, it is sometimes unavoidable.


Indeed, in my case it is :(
I've had two use cases that bumped into this limitation. In one, we are 
just working around / accepting the limitation. In the other, we found 
it much easier/safer to consider a different solution entirely.


 &gt; I might recommend a hybrid
 &gt; solution (based in my limited knowledge of Riak)... What about
 allowing a
 &gt; bucket property named something like "key\\_index" that points to
 a key
 &gt; containing a value of "keys in bucket". Then, when calling GET
 &gt; /riak/bucket, Riak would use the key\\_index to immediately reduce
 its result
 &gt; set before applying m/r funcs. While I understand this is
 essentially what
 &gt; a developer would do, it would certainly alleviate some code
 requirements
 &gt; (application side) as well as make the behavior of retrieving a
 bucket's
 &gt; contents more "expected" and efficient.

 A much earlier incarnation of Riak actually stored bucket keylists
 explicitly in a fashion somewhat like what you describe. We removed
 this as one of our biggest goals is predictable and understandable
 behavior in a distributed systems sense, and a model like this one
 turns each write operation into at least two operations. This isn't
 just a performance issue, but also adds complexity. For instance, it
 is not immediately obvious what should be returned to the client if a
 data item write succeeds, but the read/write of the index fails?


Haha, these are the exact reasons I would cite as a developer for 
using a similar method on Riak's side... without the option of auto 
bucket indexing it effectively places this double write into the 
application side where it requires more cycles and more data across 
the wire. Instead of doing a single write, from the application side, 
and allowing Riak to handle this, you have to GET index\\_key, UPDATE 
index\\_key, ADD new\\_key... So rather than having a single transaction 
with Riak, you have to have three transactions with Riak + Application 
functionality. Inherently, this adds another level of complexity into 
the application code base for something that could be done more 
efficiently by the DB engine itself.


I would think a separate error number and message would suffice as a 
return error, obviously though, this would require developers being 
made aware so they can code for the exception.


Also, this would be optional, if the index\\_key wasn't set for the 
bucket then this setup wouldn't be used. This would at least make the 
system more flexible to the application requirements and developer 
preferences.


I understand that there may be people using Riak who either never intend 
to have a huge number of keys in the cluster, or who never intend to try 
to map reduce over a bucket if they do.
I also understand that there are performance and complexity wins to be 
had by eliminating the feature.


That said, I feel it needs to be an optional feature that the engine 
itself provides. Pushing it out to the client layer severely 
complicates the transaction because it is now two separate REST calls 
rather than something that can be done in a tightly coupled fashion on 
the node servicing the request.


-Daniel
