---
title: "Re: strange behavior upgrading from riak-java-client 1.0.5 -> 1.0.6"
description: ""
project: community
lastmod: 2012-12-28T11:34:46-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg09701"
mailinglist_parent_id: "msg09700"
author_name: "Dietrich Featherston"
project_section: "mailinglistitem"
sent_date: 2012-12-28T11:34:46-08:00
---


On Dec 28, 2012, at 11:57 AM, Brian Roach  wrote:

&gt; On Fri, Dec 28, 2012 at 11:37 AM, Dietrich Featherston
&gt;  wrote:
&gt;&gt; 
&gt;&gt; All socket operations. It looks as though those that open a new socket are 
&gt;&gt; especially
&gt;&gt; impacted. We are running 1.2.1 with the leveldb backend. Same 9 node SSD 
&gt;&gt; cluster info I
&gt;&gt; have posted to the list before but don't have access to all of the details 
&gt;&gt; at the moment.
&gt; 
&gt; Sorry, I mean what type of Riak operations? Store, fetch, MapReduce,
&gt; etc? What is actually timing out?

Primarily stores but I did see one case of socket timeouts simply building a 
new connection pool using the rjc.

&gt; 
&gt;&gt; I suspect that there are additional timeouts to be configured and the 
&gt;&gt; previous default
&gt;&gt; values have been lowered. I tried bumping the requestTimeout to no avail. 
&gt;&gt; This wouldn't
&gt;&gt; explain the strange latency spikes (via /stats) seen as we began rolling out 
&gt;&gt; the new driver.
&gt; 
&gt; It really shouldn't change any of this. Even the withoutFetch()
&gt; feature as it just ... doesn't do a fetch.
&gt; 
&gt; Since you're using that new feature, how are you using it? Is this
&gt; storing new objects, or are you providing a vclock from a previous
&gt; fetch?

We are simply doing a put. It is not uncommon for keys to be overwritten but we 
are not providing a vector clock. There is a dedicated master performing the 
write for a given key upstream from riak and overwriting is always safe 
(assuming last one wins) but we don't hold onto the vector clock. 

It seems possible/likely that we are inadvertently invoking some riak 
consistency machinery by turning off the get prior to put using withoutFetch(). 
Would it help to attempt to coordinate writes in another way?

Somewhat related: I've been curious about writing a smart riak client that 
writes to a node based on the preflist for a key to avoid unnecessary internal 
handing off of reads and writes when possible. Two things strike me though 1) 
would need to compute this preflist outside of riak and 2) unsure how impactful 
this change would be without better understanding where internal riak 
bottlenecks present themselves. Perhaps best left for another thread.

&gt; 
&gt; Thanks,
&gt; - Roach

