---
title: "Re: efficient fetching of values falling in a key range"
description: ""
project: community
lastmod: 2012-01-30T10:51:31-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg06462"
mailinglist_parent_id: "msg06461"
author_name: "Dietrich Featherston"
project_section: "mailinglistitem"
sent_date: 2012-01-30T10:51:31-08:00
---


That's perfect thanks. I think I was presuming that the name of the
underlying index was $key\\_bin so this didn't cross my mind. Definitely
agree with having a separated typed KeyIndex rather than changing how
BinIndex or IntIndex work.

Thanks,
D


On Mon, Jan 30, 2012 at 10:41 AM, Russell Brown wrote:

&gt;
&gt; On 30 Jan 2012, at 18:12, Dietrich Featherston wrote:
&gt;
&gt; I'm using a leveldb-backed riak 1.0.2 and looking for some suggestions to
&gt; fetch a block of data by key range. I have control over the keys and all
&gt; reads out of this setup will involve at minimum a key range. It seems that
&gt; if leveldb is an ideal candidate for this kind of access pattern so long as
&gt; I'm able to take advantage of that in the APIs exposed by riak.
&gt;
&gt; First thought is to use the built-in $key index to do a query for the keys
&gt; falling in a range, then fetch the underlying objects (either directly or
&gt; via a map job). Doesn't look like this is yielding any results for a range
&gt; known to contain data, however.
&gt;
&gt; Doing something like the following in the Java API yields no data
&gt;
&gt; val keys =
&gt;&gt; bucket.fetchIndex(BinIndex.named("$key")).from(startKey).to(endKey).execute();
&gt;
&gt;
&gt; Whereas the same question phrased as a keyfilter map job does yield data
&gt;
&gt; riak.mapReduce(query)
&gt;&gt; .addKeyFilter(new BetweenFilter(startKey, endKey))
&gt;&gt; .addMapPhase(new NamedErlangFunction("riak\\_kv\\_mapreduce",
&gt;&gt; "map\\_object\\_value"), true)
&gt;&gt; .execute()
&gt;
&gt;
&gt; Perhaps there is something I need to do to make sure the $key index is
&gt; built other than using the leveldb backend, but I couldn't find any
&gt; evidence of that in the docs.
&gt;
&gt; Does this seem like a reasonable approach? If so, any thoughts on how I
&gt; might be reading the key index incorrectly?
&gt;
&gt;
&gt; It is a bug/oversight in the RJC, when you do BinIndex.named("$key"),
&gt; you'll get an index called "$key\\_bin", which isn't the name of the index
&gt; you want. I'll raise a bug for it and get a patch out. I think the best bet
&gt; is to have a tagged type (KeyIndex ?) rather than change the way that
&gt; BinIndex/IntIndex work. Sound ok?
&gt;
&gt; Cheers
&gt;
&gt; Russell
&gt;
&gt;
&gt; Thanks,
&gt; D
&gt;

