---
title: "Re: Riak async PB client based on Grizzly"
description: ""
project: community
lastmod: 2011-06-22T00:29:48-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg03771"
mailinglist_parent_id: "msg03763"
author_name: "Russell Brown"
project_section: "mailinglistitem"
sent_date: 2011-06-22T00:29:48-07:00
---


Hey Jon, 
Any chance you want to implement the RawClient interface 
(https://github.com/basho/riak-java-client/blob/master/src/main/java/com/basho/riak/client/raw/RawClient.java)
 from the basho riak-java-client library? That way your client can be swapped 
straight into the basho lib?

If not, let me know when you get a repo up on github and I'll write an adapter 
so that the basho riak-java-client can make use of your Grizzly client, which I 
guess means I'll pitch in a little (time permitting) to help shape the Grizzly 
client so it is RawClient shaped.

Cheers

Russell

On 21 Jun 2011, at 17:58, Jon Brisbin wrote:

&gt; I'm trying to get my feet wet with Grizzly on another project, so I've been 
&gt; spending some late(ish) nights also working on a Grizzly-based asynchronous 
&gt; PB client for Riak. I'm dropping all the way down to the protobuf level and 
&gt; using Grizzly's NIO abstractions to implement a completely non-blocking 
&gt; client. I'm writing the low-level stuff in Java and I'd really like to build 
&gt; a Scala layer on top of this, which uses the nice Scala idioms (operators, 
&gt; case classes, etc...). But I can't write code as fast in Scala as I can in 
&gt; Java and some of the Java APIs inside Grizzly aren't all that Scala-friendly 
&gt; and make the code pretty ugly. I figured it would be better to implement a 
&gt; fairly low-level PB client in Java and flesh out the user-facing API in Scala 
&gt; and/or Java.
&gt; 
&gt; My question is basically, if I seed this project on GitHub with what I've got 
&gt; so far, would anyone else be interested in helping complete it? I'm just 
&gt; working on this after my other Grizzly work, so I can't devote full time to 
&gt; it. It might take me a little while to implement things like links and 
&gt; mapreduce.
&gt; 
&gt; I think it shows some real promise because it is completely non-blocking. It 
&gt; uses Futures and CompletionHandlers to do the dirty work. A Grizzly filter is 
&gt; responsible for the actual encoding/decoding of protobuf data. Right now, it 
&gt; will marshall JSON using Jackson if your content-type is set to 
&gt; "application/json", otherwise it uses JDK serialization to encode the entry 
&gt; (or just passes a String straight through, of course).
&gt; 
&gt; Since it's a first pass, there is no real attempt to separate the protobuf 
&gt; stuff from the client. That's a v2 thing. Since I have limited time, I'm 
&gt; interested in speed to completion of features rather than good-looking and 
&gt; properly abstracted code. :)
&gt; 
&gt; Thanks!
&gt; 
&gt; Jon Brisbin
&gt; http//jbrisbin.com
&gt; 
&gt; 

