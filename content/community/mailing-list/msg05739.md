---
title: "Re: Clarifying \"Read-before-Write\""
description: ""
project: community
lastmod: 2011-11-26T05:19:52-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg05739"
mailinglist_parent_id: "msg05738"
author_name: "Andres Jaan Tack"
project_section: "mailinglistitem"
sent_date: 2011-11-26T05:19:52-08:00
---


Thanks! That explanation is perfect. I guess should have taken a look at
some of the other clients as an example in the first place.

Now I have something to fix for Riak-Cpp. :)

--
Andres

2011/11/26 Russell Brown 

&gt;
&gt; On 26 Nov 2011, at 01:14, Andres Jaan Tack wrote:
&gt;
&gt; So I was just reading and thinking about this, and I don't understand the
&gt; advice offered under "Read-before-Write" at
&gt; http://wiki.basho.com/Client-Implementation-Guide.html.
&gt;
&gt; "Riak will return an encoded vector 
&gt; clock
&gt;&gt; with every "fetch" or "read" request that does not result in a "not
&gt;&gt; found" response. In addition to the Client ID, this vector clock tells Riak
&gt;&gt; how to resolve concurrent writes, essentially representing the "last seen"
&gt;&gt; version of the object to which the client made modifications. In order to
&gt;&gt; prevent sibling 
&gt;&gt; explosion,
&gt;&gt; clients should always have a vector clock before sending a write, and send
&gt;&gt; the vector clock as part of the write request. Therefore, it is essential
&gt;&gt; that keys are fetched before being written (except in the case where Riak
&gt;&gt; selects the key or there is \\*a priori\\* knowledge that the key is new).
&gt;&gt; Client libraries that make this automatic will reduce operational issues by
&gt;&gt; limiting sibling explosion. Clients may also choose to perform automatic 
&gt;&gt; Sibling
&gt;&gt; Resolution
&gt;&gt; on read."
&gt;
&gt;
&gt; I'm having trouble understanding the advice. I get that if I'm aware of
&gt; all the siblings, I can resolve them (optionally) with that vector clock.
&gt; What I don't understand here: If an application PUTs to an object out of
&gt; the blue, not having read it first, should the client library
&gt; read-before-write?
&gt;
&gt;
&gt; Yes it should.
&gt;
&gt; This seems like a great way to blow away siblings by accident.
&gt;
&gt;
&gt; But it should never do that, if siblings are encountered, it should \\*do\\*
&gt; something.
&gt;
&gt; Or is the point rather to avoid sibling explosion for applications that
&gt; don't care about losing information?
&gt;
&gt;
&gt; A well behaved client library will not blindly PUT a value "over the top"
&gt; of siblings, but will push the problem to the library user (hopefully in
&gt; some helpful way, like automatically applying some domain specific
&gt; resolution logic.)
&gt;
&gt; So, in the case of the Java client, when you store (or fetch for that
&gt; matter) you must provide an implementation of the ConflictResolver
&gt; interface to the client, this will then be executed to resolve any siblings
&gt; on the pre-store fetch. If you don't provide a conflict resolver the Java
&gt; client uses one that throws a runtime exception when it encounters siblings
&gt; on fetch, exactly so that you don't do as you describe, and blow away
&gt; potentially meaningful sibling values.
&gt;
&gt; Maybe the wording on the wiki should make this clearer, maybe it should
&gt; read:
&gt;
&gt; "Clients [that automatically fetch before store] \\_must\\_ chose to either
&gt; perform automatic Sibling Resolution \\*or\\* abort the write and notify the
&gt; presence of siblings to the caller"
&gt;
&gt; It is a thorny issue, please let me know if I've answered your question
&gt; adequately.
&gt;
&gt; Cheers
&gt;
&gt; Russell
&gt;
&gt;
&gt; --
&gt; Andres

