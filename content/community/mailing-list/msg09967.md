---
title: "Re: Fun with Unicode"
description: ""
project: community
lastmod: 2013-02-02T00:30:07-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg09967"
mailinglist_parent_id: "msg09964"
author_name: "Anton"
project_section: "mailinglistitem"
sent_date: 2013-02-02T00:30:07-08:00
---


Yes, so far, I believe that this exact string should replace every
invocation of .dumps() in python, and our case specifically. The way I
understand it, PHP and Python do what they do by default, in order to
protect ancient systems which do not like to read non-ascii values,
but I have to say that the reasons behind all this are quite hard to
dig out.

Unless someone else is already on this, I can give it a go in a branch
and see if there is anything more to it.

However, in the case libraries in multiple languages will have access
to the same cluster, one has to check what the default encoding in all
of them will do. Be cause the \\uXXXX escaping will work, transparently
to you, eating up storage space and bandwidth.

On 1 February 2013 17:21, Adam Lindsay  wrote:
&gt; Ugh, yes, to both.
&gt;
&gt; Anton put his finger on it exactly--I made a typical Python Unicode goof in
&gt; not being explicit about the encoding. My bad for assuming the json module
&gt; would do so.
&gt;
&gt; So, Anton, would your use case be served by the following?
&gt;
&gt; antonjson = lambda x: json.dumps(x, ensure\\_ascii=False).encode("utf8")
&gt; R.set\\_encoder('application/json', antonjson)
&gt;
&gt; --
&gt; Adam Lindsay
&gt;
&gt; On Friday, 1 February 2013 at 16:11, Sean Cribbs wrote:
&gt;
&gt; For what it's worth, the underlying transports don't (read: shouldn't)
&gt; care about the encoding of the payload. They just want a chunk of
&gt; bytes. Is there an equivalent to "hey, I know this is probably a
&gt; unicode or string object, but just give me the equivalent bytearray
&gt; without transcoding anything"? If there is, we should be using that.
&gt;
&gt; On Fri, Feb 1, 2013 at 9:57 AM, Anton  wrote:
&gt;
&gt; Adam, you should be able to write to any transport if you first
&gt; .encode('utf-8') the result there, right? ensure\\_ascii=False will feed
&gt; you unicode objects (if and only if there's something non-ASCII in the
&gt; input to .dumps). They of course will cause anything that attempts to
&gt; coerce them to a string to go wrong, as it'll attempt to do that by
&gt; encoding to ASCII.
&gt;
&gt; On 1 February 2013 16:45, Adam Lindsay  wrote:
&gt;
&gt; Anton, Sean,
&gt;
&gt; Anton brings up a pretty interesting problem.
&gt;
&gt; At first, I thought it might be easy to remedy with:
&gt;
&gt; import json
&gt; import functools
&gt; antonjson = functools.partial(json.dumps, ensure\\_ascii=False)
&gt;
&gt; from riak import RiakClient
&gt; R = RiakClient()
&gt; R.set\\_encoder('application/json', antonjson)
&gt;
&gt; â€¦however, upon testing this out, it's seems likely that the underlying
&gt; transport channels use the default encoding, 'ascii,' and choke on the 8-bit
&gt; data we now pass it, in socket.py (for the HTTP client) or
&gt; protobuf.internal.type\\_checkers (for PBC).
&gt;
&gt; Maybe that's a suitable hint for Anton's further investigation, but I'll try
&gt; to spend some time with it to see what I can find, as well.
&gt;
&gt; As to the OP's question: Yes, you've summarized the state of affairs quite
&gt; nicely. IMHO it was a reasonable default (you can't be sure other Riak
&gt; clients are as good as Python at 8-bit/Unicode!), but the underlying
&gt; implementation definitely shows a bug that (again, IMHO) should and can be
&gt; fixed.
&gt; --
&gt; Adam Lindsay
&gt;
&gt; On Friday, 1 February 2013 at 14:27, Sean Cribbs wrote:
&gt;
&gt; Anton,
&gt;
&gt; I don't see any reason why this can't be fixed. However, since I'm not
&gt; familiar with the specifics of the JSON implementation, I'll need
&gt; assistance. Please open an issue or pull-request on the Python client:
&gt; https://github.com/basho/riak-python-client/issues. We are open to
&gt; major, breaking changes for the next release.
&gt;
&gt; On Fri, Feb 1, 2013 at 8:06 AM, Anton  wrote:
&gt;
&gt; Let's talk python and Unicode (yey!)
&gt;
&gt; The objects that I want to store will have non-ASCII strings in them.
&gt; Potentially a lot. How much is a lot? "Very many millions" should be a
&gt; good estimate.
&gt;
&gt; Now, the default behaviour for storing a python object (ok, a dict of
&gt; stuff), using the PBC transport is to pass them to json and encode
&gt; them. I'm ok with that, I like JSON and the fact that I can read out
&gt; an object in JSON, using a browser, helps a lot. It's really great for
&gt; developing project-specific tools, say debugging tools.
&gt;
&gt; But here is where the fun part starts. The JSON encoder in python is
&gt; not a simple thing, and takes a lot of parameters. And by default it
&gt; works. So well that people rarely look at what's going on. When you
&gt; look at what's going on, however, things get more entertaining.
&gt;
&gt; The JSON encoder works on unicode objects, not strings. When you pass
&gt; it unicode objects, it's happy. When you pass it strings, it decodes
&gt; them, using a specified encoding. By default this is set to 'utf-8'
&gt; which makes everything quite ok. So far so good. However, there's
&gt; another option - 'ensure\\_ascii'. This is set to True by default and it
&gt; means that the JSON encoder will spew out an ASCII-encoded string.
&gt; That is, in the result, every unicode code-point is encoded as \\u0123,
&gt; or a total of 6 bytes.
&gt;
&gt; Now, this is not good. For one, the JSON RFCs expect Unicode, encoded
&gt; using UTF-\\*. Also, even if much of the data will require 3bytes in
&gt; UTF-8, that's still only half the bytes that the python default would
&gt; take.
&gt;
&gt; Now, consider this elementary example. It already gives a significant
&gt; (in bytes) difference for a short string:
&gt; http://pastie.org/6011147
&gt;
&gt;
&gt; Please tell me I'm not going crazy and all this is the state of
&gt; affairs and it is, in fact, wrong and can/should be fixed.
&gt;
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;
&gt;
&gt;
&gt;
&gt; --
&gt; Sean Cribbs 
&gt; Software Engineer
&gt; Basho Technologies, Inc.
&gt; http://basho.com/
&gt;
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;
&gt;
&gt;
&gt;
&gt; --
&gt; Sean Cribbs 
&gt; Software Engineer
&gt; Basho Technologies, Inc.
&gt; http://basho.com/
&gt;
&gt;

\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

