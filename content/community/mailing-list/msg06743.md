---
title: "Re: Possibility of a CAS API"
description: ""
project: community
lastmod: 2012-02-24T23:47:17-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg06743"
mailinglist_parent_id: "msg06739"
author_name: "Martin Bruse"
project_section: "mailinglistitem"
sent_date: 2012-02-24T23:47:17-08:00
---


Here is the working link:
https://github.com/ProjectDaisy/blodsband/blob/master/lib/blodsband/riak/bucket.rb#L484

The universe will always punish you if you send long emails via smartphone
:/

On Sat, Feb 25, 2012 at 4:21 AM, Armon Dadgar wrote:

&gt; It sounds like the "If-Unmodified-Since" and "If-None-Match" flags could
&gt; do what I
&gt; need, but the docs specify "it is possible for the condition to evaluate
&gt; to true for
&gt; multiple requests if the requests occur at the same time."
&gt;
&gt; From my understanding, the KV vnode's process their requests in a serial
&gt; fashion.
&gt; I'm not sure I fully understand how It could be that the request evaluates
&gt; to true
&gt; for multiple requests, if the PUTs are handled serially.
&gt;
&gt; If it is a matter of the vnodes being interleaved, would it be solvable by
&gt; setting w = r = n?
&gt;
&gt; I'm not convinced that a CAS operation is inevitably subject to data races.
&gt; There are proven techniques for avoiding races at the cost of latency,
&gt; which is acceptable in certain situations.
&gt;
&gt; I will take a look at Zab, thanks for the reference!
&gt;
&gt; Best Regards,
&gt;
&gt; Armon Dadgar
&gt;
&gt; On Feb 24, 2012, at 6:09 PM, Dietrich Featherston wrote:
&gt;
&gt; If you need CAS semantics, then coordinate that outside of riak. Any
&gt; check-then-act type of operation where atomicity is important is going to
&gt; leave some room for a data race in a system with the distribution semantics
&gt; of riak. Would suggest thinking about the problem in such a way that
&gt; handling of siblings is tolerant of duplicate writes and eventually the
&gt; correct value bubbles up to the readers. That or do the coordination of
&gt; unique indexes in something not dynamo shaped.
&gt;
&gt; I can't say I'm intimately familiar with the work yet, but others have
&gt; prototyped/postulated consistency layers on top of riak (a la zab) that
&gt; might more closely match what you're trying to do. None of this is in a
&gt; released / supported version of riak to my knowledge though.
&gt;
&gt; Thanks,
&gt; D
&gt;
&gt;
&gt; On Fri, Feb 24, 2012 at 4:41 PM, Armon Dadgar wrote:
&gt;
&gt;&gt; As part of a new feature we are working on, we've run into
&gt;&gt; a situation where it would be incredibly convenient to have a
&gt;&gt; check-and-set (CAS) API for Riak KV. In short, we are trying to build
&gt;&gt; a unique index of a bucket, using a second bucket which acts as a
&gt;&gt; reverse index.
&gt;&gt;
&gt;&gt; The CAS API would operate in the same manner as a PUT, except it
&gt;&gt; should take a "last vclock". The new value + last vclock are submitted
&gt;&gt; to the responsible vnodes. The vnodes respond if the last vclock
&gt;&gt; for the key matches the specified last value. If we get "r" nodes
&gt;&gt; responding
&gt;&gt; that the last value matches, then we should commit the write. This method
&gt;&gt; is basically a two-phase commit.
&gt;&gt;
&gt;&gt; It would also be great if no-value sentinel could be specified to indicate
&gt;&gt; the CAS should only succeed if there is not already a key. We need this
&gt;&gt; to make sure uniqueness constraints are not violated.
&gt;&gt;
&gt;&gt; I wanted to gauge the interest from the community in something like this,
&gt;&gt; and see if I could get thoughts from the Basho team on if this could be
&gt;&gt; implemented.
&gt;&gt;
&gt;&gt; Best Regards,
&gt;&gt;
&gt;&gt; Armon Dadgar
&gt;&gt;
&gt;
&gt;

