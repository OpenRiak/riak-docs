---
title: "Re: Race condition reading objects"
description: ""
project: community
lastmod: 2011-10-31T13:02:00-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg05392"
mailinglist_parent_id: "msg05382"
author_name: "Rusty Klophaus"
project_section: "mailinglistitem"
sent_date: 2011-10-31T13:02:00-07:00
---


Hi Elias,

Thanks for your excellent description of the problem. We haven't seen this
before to my knowledge, and this isn't expected behavior.

Can you answer a few questions to help us troubleshoot?

 - Can you send me the exact error message you saw when the client failed
 to deserialize the object?
 - What OS are you running? Virtualized or bare-metal?
 - What version of the Ruby library does your app use?
 - Anything special about the disks? (Super slow and old? Shiny new
 SSD's? RAID?)
 - Can you reproduce the results without using multi\\_backend?
 - Does the data load successfully when you use Bitcask instead of
 LevelDB?

Also, if you can share your code, or if you have a small script that can
reproduce the failure, that would be extremely helpful.

Best,
Rusty

On Sun, Oct 30, 2011 at 7:58 PM, Elias Levy wrote:

&gt; I am finding that there appears to be some sort of race condition when
&gt; reading recently written objects (as in concurrently). I am using Riak
&gt; 1.0.0 with the leveldb backend through the multi backend in a 3 node
&gt; cluster. Writes are done with W=2 and reads with R=2. The client is using
&gt; the riak client Ruby gem.
&gt;
&gt; The issue cropped up while working on a data loading script. The script
&gt; load data from a file and insert it into the cluster. It attempts to do so
&gt; in parallel, with configurable concurrency. This data is largely
&gt; non-repetitive. Usually an object is written once and has worked without
&gt; major issue. I recently changed the script to collect statistics on some
&gt; of the data being inserted, and insert the stats into a different bucket.
&gt; The stats are written in JSON and keyed by a value in the data being
&gt; loaded. The script will attempt to fetch the stats object for the key
&gt; currently under consideration, if it finds one merge the new stats, and
&gt; store the new or updated object.
&gt;
&gt; Once some of the stats objects started to grow into the KB range, the
&gt; reading of some existing stat objects started to fail. Upon examination it
&gt; seems the data in the object was being truncated and thus riak client
&gt; failed to deserialize the object as it was no longer valid. But if I
&gt; fetched the object manually I was returned complete. I added a loop to the
&gt; script to retry such truncated fetches, and I found that they would succeed
&gt; after a few tries.
&gt;
&gt; It would thus appear that Riak is making the new object available to be
&gt; fetched before its data is fully stored, leading to the apparently
&gt; truncated return. The issue only becomes visible once the object is large
&gt; enough to introduce enough delay in processing for store and fetch
&gt; operations to overlap. Using W=2 and R=2 probably has no effect as only
&gt; the vclocks are compared, not the actual data stored. Not sure if this is
&gt; an issue with the new leveldb backend or the KV code.
&gt;
&gt; Anyone seen this? Is it expected behavior? Shouldn't the new object only
&gt; be exposed after it has been completed received and stored?
&gt;
&gt; Elias
&gt;
&gt;
&gt;

-- 
Rusty Klophaus (@rustyio)
\\*Basho Technologies, Inc.\\*
www.basho.com
