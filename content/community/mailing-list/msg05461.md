---
title: "Re: Riak and Distributed Image Processing"
description: ""
project: community
lastmod: 2011-11-07T17:24:08-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg05461"
mailinglist_parent_id: "msg05459"
author_name: "andrew cooke"
project_section: "mailinglistitem"
sent_date: 2011-11-07T17:24:08-08:00
---



Hi,

Thanks for the reply.

There were a lot of useful details there, but the thing I need to reply to, I
think, is the whole question of whether the map step is combining multiple
images, or processing a single image.

The number of calibrations (in the sense I used that term) is always small.
I'll explain why below (I'm not putting the text here because it's long and
more about astronomy than computing). So I am considering them as "constants"
that are somehow present on every node. Somewhere in the Riak docs I thought
I found some mention of a map step that cached a linked value locally. I
can't find that now, but I thought this might be how the calibration was
pulled across initially.

Does the above address your concern? So rather than

 fetch one image &gt; fetch another image &gt; mutate &gt; write output

I see something more like:

 move to where the image is &gt;
 fetch calibration if this this is the first image on this node &gt;
 mutate the image &gt; write output

Does that improve things?

Andrew


Here's the argument why the number of calibration images does not scale
with the number of observation images:

Astronomy is observing time limited. The number of telescopes is small
compared to the number of astronomers. Furthermore, new discoveries are made
by pushing limits - either by observing new objects (which means looking at
faint objects, since bright ones are already well-studied, and so requires a
lot of observing time) or by doing large statistical samples (which requires a
lot of observing time) or by looking at something in more detail (which means
restricting spatial or frequency ranges, and so implies less photons and
requires a lot of observing time). In every case, instruments and observing
processes must spend as much time as possible obtaining observation images.
This forces calibration images to be made at the start/end of the night. So a
small number of calibrations are applied to many observations.

The above is simplified, but hopefully it gives the general idea. What is new
in my email (if anything) is not the general approach, but the idea that
"commodity" software can be used rather than developing dedicated pipeline
software for a particular instrument (along with the idea that you can create
provenance graphs and reuse data in a similar way to pure data structures).



On Mon, Nov 07, 2011 at 04:56:41PM -0500, Alexander Sicular wrote:
&gt; Great project, Andrew. It's not a dumb idea, sounds pretty awesome actually. 
&gt; I just don't think Riak will get you there.
&gt; 
&gt; As I see it, the basic outline looks something like:
&gt; 
&gt; fetch one image &gt; fetch another image &gt; mutate &gt; write output
&gt; 
&gt; I just don't see how Riak's implementation of map reduce allows you to 
&gt; iterate over a collection of images accessed by key and then mutate over some 
&gt; other image. That said, Riak would work well as the distributed, replicated 
&gt; image repository. The main advantage would be computation would be done where 
&gt; the data resides. You could write some erlang-fu mod that shelled the image 
&gt; out to some matlab/scipy/opencl process and then wrote output directly back 
&gt; to riak or put output in some watched dir that made it back to riak some 
&gt; other way. Many nodes with many cores would help. But in reality disk i/o is 
&gt; often the slowest link in any moderately complex chain. Shipping 20MB images 
&gt; over the wire in a GigE network is not really a big deal.
&gt; 
&gt; Further, image to image manipulation becomes some order of O(n2) complexity 
&gt; which almost guarantees that you will never complete your compute task if 
&gt; either your calibration or observation set grow at any meaningful rate. I 
&gt; don't have experience in the image manipulation space but I do have some 
&gt; experience in the data similarity/comparison space which in this instance is 
&gt; more or less the same. You have two pieces of data that you need to run some 
&gt; sort of algorithm against to determine (dis)similarity. It is usually the 
&gt; case that direct comparison is not used in such cases if only for regards to 
&gt; computation time. Then again, if your set size is static disregard everything 
&gt; I just said, do direct comparisons and compute your execution time on the 
&gt; back of a napkin.
&gt; 
&gt; Meh, that's my feeble stab at it.
&gt; 
&gt; Let us know what you eventually decide on!
&gt; 
&gt; Cheers,
&gt; 
&gt; -Alexander Sicular
&gt; 
&gt; @siculars
&gt; http://siculars.posterous.com
&gt; 
&gt; On Nov 7, 2011, at 4:23 PM, andrew cooke wrote:
&gt; 
&gt; &gt; 
&gt; &gt; Hi,
&gt; &gt; 
&gt; &gt; Apologies if this is a dumb idea, or I am asking in the wrong place. I'm
&gt; &gt; muddling around trying to understand various bits of technology while 
&gt; &gt; piecing
&gt; &gt; together a possible project. So feel free to tell me I'm wrong :o)
&gt; &gt; 
&gt; &gt; I am considering how best to design a system that processes data from
&gt; &gt; telescopes. A typical "step" in the processing might involve combining a
&gt; &gt; small number of calibration images with a (possibly large) set of 
&gt; &gt; observation
&gt; &gt; images in some way and then adding the result. To do this in a distributed
&gt; &gt; manner you would have the observations on various machines, broadcast the
&gt; &gt; calibrations, then do a map (the per-observation processing) followed by a
&gt; &gt; reduce (the summing).
&gt; &gt; 
&gt; &gt; So, in very vague terms, this fits roughly into map-reduce territory. What 
&gt; &gt; I
&gt; &gt; am doing now is seeing how the details work out with various "nosql" 
&gt; &gt; systems.
&gt; &gt; 
&gt; &gt; So my basic question is: how would the above fit with Riak? Alternatively,
&gt; &gt; what else should I consider?
&gt; &gt; 
&gt; &gt; Some more details and speculation:
&gt; &gt; 
&gt; &gt; - A typical image might contain 10 million 16 bit values, so is of around
&gt; &gt; 20MB in size (and will get bigger as technology improves).
&gt; &gt; 
&gt; &gt; - A typical process could involve anything from 1 to hundreds of images.
&gt; &gt; 
&gt; &gt; - I have no problem with using Erlang for high level code, but would expect
&gt; &gt; to delegate image processing to C, Fortran, or OpenCL (if GPUs were
&gt; &gt; available on nodes; I know an OpenCL package exists for Erlang).
&gt; &gt; 
&gt; &gt; - Integration with numerical Python or IDL or Matlab or similar would be an
&gt; &gt; unexpected plus.
&gt; &gt; 
&gt; &gt; - I imagine (but have done no tests so have no real idea how much time would
&gt; &gt; be spent in number-crunching, compared to data movement) that for
&gt; &gt; efficiency it might (sometimes) be best to have mutable, memory mapped
&gt; &gt; access to the images in a map-reduce "task".
&gt; &gt; 
&gt; &gt; - But exactly when processes would mutate image data, and when they would
&gt; &gt; create new images, is not yet clear.
&gt; &gt; 
&gt; &gt; - If images awere immutable then you could consider the data processing as a
&gt; &gt; directed graph of images. Re-processing with modified parameters (a 
&gt; &gt; common
&gt; &gt; occurence as the astronomer "tweaks" the reduction) might re-use some
&gt; &gt; points in the graph to avoid duplicating previous work. Some kind of
&gt; &gt; "garbage collection" could then be required to delete older images.
&gt; &gt; 
&gt; &gt; - Some processing will require combining images on different nodes.
&gt; &gt; 
&gt; &gt; - Something must preserve a history of the processing required to generate
&gt; &gt; each image. I assume this would be managed by the high-level code, but
&gt; &gt; it's possible "data provenance" is already available in Riak, or supported
&gt; &gt; by some library?
&gt; &gt; 
&gt; &gt; - Most tasks would be expressed in terms of kernel operations (eg add two
&gt; &gt; images) taken from some library, but astronomers may want to add 
&gt; &gt; completely
&gt; &gt; new code.
&gt; &gt; 
&gt; &gt; If you've read this far I'd love to hear of any thoughts that pop into your
&gt; &gt; head in response to the above. Possible problems? Technical details of 
&gt; &gt; Riak
&gt; &gt; that might help? Similar projects?
&gt; &gt; 
&gt; &gt; Thanks,
&gt; &gt; Andrew
&gt; &gt; 
&gt; &gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; &gt; riak-users mailing list
&gt; &gt; riak-users@lists.basho.com
&gt; &gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt; 

\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

