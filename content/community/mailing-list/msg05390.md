---
title: "Re: Riak 1.0, Clojure and the Java Client"
description: ""
project: community
lastmod: 2011-10-31T11:17:22-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg05390"
mailinglist_parent_id: "msg05103"
author_name: "Ryan Zezeski"
project_section: "mailinglistitem"
sent_date: 2011-10-31T11:17:22-07:00
---


On Fri, Oct 7, 2011 at 7:23 PM, Tim Robinson  wrote:

&gt;
&gt;
&gt; I just read the Satebox page you linked as an example and have a hard time
&gt; thinking I would want to use this. While automation is always nice, the
&gt; overhead is an unnecessary burden. Since Clojure provides
&gt; coordinated/transactional data structures, it's already easy \\*enough\\* to
&gt; resolve conflicts within your natural code flow without having to resort to
&gt; the rationalizing of queued values. Also, I can only speak for myself, but
&gt; I believe most people would only want this to apply in selective cases such
&gt; that a performance hit is not taken for the other 90% of data where last
&gt; write winning is just fine.
&gt;
&gt; Does that make sense to you? I could be completely off considering I only
&gt; read the 5 minute 'read-me' blurb.
&gt;
&gt; Thanks again.
&gt; Tim
&gt;
&gt;
Statebox gives your conflict context when you have a split-brain scenario.
 If resolution of your data relies on it's history/context, rather than
just the latest siblings (e.g. removing an item from a set), then you need
to store that context somewhere. Statebox stores the context inline with
the object and provides some automatic resolution for certain types of
data, such as sets.

However, Statebox is Erlang only. You are forced to use Erlang to use it
or extend it. I think it would be worthwhile to copy it in a Clojure
client as \\_one\\_ of the ways to handle conflict resolution. I imagine as a
protocol [1] so that you can easily say "this thing participates in
sliding-window history-based conflict resolution."

-Ryan

[1]: My Clojure knowledge is very rusty but IIRC a protocol is much like a
type class in Haskell.
