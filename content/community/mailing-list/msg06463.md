---
title: "Re: efficient fetching of values falling in a key range"
description: ""
project: community
lastmod: 2012-01-30T12:08:18-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg06463"
mailinglist_parent_id: "msg06462"
author_name: "Dietrich Featherston"
project_section: "mailinglistitem"
sent_date: 2012-01-30T12:08:18-08:00
---


Yeah I had something that I thought would work then ran into some
assumptions about handling of the existing bin / int query types. Started
to introduce a higher level Index type that a generic RangeQuery could
operate on rather than playing the combinatorics game with the existing
AbstractRangeQuery subclasses. Got hairy enough that it's probably a good
idea to let someone who has ownership over the codebase do this.

In the end I'm not sure if I'll even be able to use the key range queries.
Problem is that this only fetches the keys but what I really need is to
fetch the values behind these keys. Doesn't look like there is a riak
operation that maps onto a leveldb seek + scan in each of the partitions to
pull a range of values.


On Mon, Jan 30, 2012 at 11:54 AM, Russell Brown wrote:

&gt; Hi Dietrich,
&gt; I'm actually doing it now. If you had a look at it you'll see it is a bit
&gt; of mess, what with the Query types and Index types and all that. I'm happy
&gt; to keep going and finish.
&gt;
&gt; Cheers
&gt;
&gt; Russell
&gt;
&gt; On 30 Jan 2012, at 18:58, Dietrich Featherston wrote:
&gt;
&gt; Hey Russel. Any thoughts on when you'd get around to pushing to master?
&gt; Since I'm actively working on this I'm happy to add KeyIndex to the RJC and
&gt; send a pull request if that would be quicker.
&gt;
&gt;
&gt; On Mon, Jan 30, 2012 at 10:51 AM, Dietrich Featherston  wrote:
&gt;
&gt;&gt; That's perfect thanks. I think I was presuming that the name of the
&gt;&gt; underlying index was $key\\_bin so this didn't cross my mind. Definitely
&gt;&gt; agree with having a separated typed KeyIndex rather than changing how
&gt;&gt; BinIndex or IntIndex work.
&gt;&gt;
&gt;&gt; Thanks,
&gt;&gt; D
&gt;&gt;
&gt;&gt;
&gt;&gt; On Mon, Jan 30, 2012 at 10:41 AM, Russell Brown wrote:
&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; On 30 Jan 2012, at 18:12, Dietrich Featherston wrote:
&gt;&gt;&gt;
&gt;&gt;&gt; I'm using a leveldb-backed riak 1.0.2 and looking for some suggestions
&gt;&gt;&gt; to fetch a block of data by key range. I have control over the keys and all
&gt;&gt;&gt; reads out of this setup will involve at minimum a key range. It seems that
&gt;&gt;&gt; if leveldb is an ideal candidate for this kind of access pattern so long as
&gt;&gt;&gt; I'm able to take advantage of that in the APIs exposed by riak.
&gt;&gt;&gt;
&gt;&gt;&gt; First thought is to use the built-in $key index to do a query for the
&gt;&gt;&gt; keys falling in a range, then fetch the underlying objects (either directly
&gt;&gt;&gt; or via a map job). Doesn't look like this is yielding any results for a
&gt;&gt;&gt; range known to contain data, however.
&gt;&gt;&gt;
&gt;&gt;&gt; Doing something like the following in the Java API yields no data
&gt;&gt;&gt;
&gt;&gt;&gt; val keys =
&gt;&gt;&gt;&gt; bucket.fetchIndex(BinIndex.named("$key")).from(startKey).to(endKey).execute();
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; Whereas the same question phrased as a keyfilter map job does yield data
&gt;&gt;&gt;
&gt;&gt;&gt; riak.mapReduce(query)
&gt;&gt;&gt;&gt; .addKeyFilter(new BetweenFilter(startKey, endKey))
&gt;&gt;&gt;&gt; .addMapPhase(new NamedErlangFunction("riak\\_kv\\_mapreduce",
&gt;&gt;&gt;&gt; "map\\_object\\_value"), true)
&gt;&gt;&gt;&gt; .execute()
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; Perhaps there is something I need to do to make sure the $key index is
&gt;&gt;&gt; built other than using the leveldb backend, but I couldn't find any
&gt;&gt;&gt; evidence of that in the docs.
&gt;&gt;&gt;
&gt;&gt;&gt; Does this seem like a reasonable approach? If so, any thoughts on how I
&gt;&gt;&gt; might be reading the key index incorrectly?
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; It is a bug/oversight in the RJC, when you do BinIndex.named("$key"),
&gt;&gt;&gt; you'll get an index called "$key\\_bin", which isn't the name of the index
&gt;&gt;&gt; you want. I'll raise a bug for it and get a patch out. I think the best bet
&gt;&gt;&gt; is to have a tagged type (KeyIndex ?) rather than change the way that
&gt;&gt;&gt; BinIndex/IntIndex work. Sound ok?
&gt;&gt;&gt;
&gt;&gt;&gt; Cheers
&gt;&gt;&gt;
&gt;&gt;&gt; Russell
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; Thanks,
&gt;&gt;&gt; D
&gt;&gt;&gt;

&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;
&gt;
&gt;
