---
title: "Re: Geospatial advice?"
description: ""
project: community
lastmod: 2012-05-01T11:09:47-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg07362"
mailinglist_parent_id: "msg07360"
author_name: "Mark Rose"
project_section: "mailinglistitem"
sent_date: 2012-05-01T11:09:47-07:00
---


Well, I'd be indexing items over the entire globe. I'd be be looking at
resolutions from an entire world view down to city block. I'm thinking of
using geohashes as an index to restrict the result set, then further
filtering and sorting by mapreducing the remaining items. So I only need
enough granularity to reduce the number of items to a reasonable amount. At
the world view level, I'd filter out most results using mapreduce, but the
local-level queries would be far more common so an index would be highly
advantageous. The geometry I'd want to query would be a window that
arbitrarily overlaps one or more geohash regions. Basically, think plotting
items in say, Google Maps.

Can you use a secondary index inside mapreduce? I haven't seen any examples
of it. I have only seen a secondary index being used to feed a mapreduce. I
am new to Riak.

I imagine my number of points would be at most 100 items per square km, but
typically less than 1 per square km. A 1 km resolution would be sufficient.
A 32 bit geohash would cover that fine. Vast regions of the Earth would
contain no points at all.

-Mark

On Tue, May 1, 2012 at 1:16 PM, Sean Cribbs  wrote:

&gt; In contrast to Alexander's assessment, I'd say "it depends". I have built
&gt; some geospatial indexes on top of Riak using a geohashing scheme based on
&gt; the Hilbert space-filling curve. However, I had to choose specific levels
&gt; of "zoom" and precompute them. Now that we have secondary indexes, you
&gt; could perhaps bypass the precomputation step. In general, if you know the
&gt; geometry of the space you want to query, you can fairly trivially compute
&gt; the names of the geohashes you need to look up and then either fetch
&gt; individual keys for those (if you precompute them), or use MapReduce to
&gt; fetch a range of them. It's not automatic, for sure, but the greatest
&gt; complexity will be in deciding which granularities of index to support.
&gt;
&gt; On Tue, May 1, 2012 at 12:44 PM, Alexander Sicular wrote:
&gt;
&gt;&gt; My advice is to not use Riak. Check mongo or Postgres.
&gt;&gt;
&gt;&gt;
&gt;&gt; @siculars on twitter
&gt;&gt; http://siculars.posterous.com
&gt;&gt;
&gt;&gt; Sent from my iRotaryPhone
&gt;&gt;
&gt;&gt; On May 1, 2012, at 9:18, Mark Rose  wrote:
&gt;&gt;
&gt;&gt; &gt; Hello everyone!
&gt;&gt; &gt;
&gt;&gt; &gt; I'm going to be implementing Riak as a storage engine for geographic
&gt;&gt; data. Research has lead me to using geohashing as a useful way to filter
&gt;&gt; out results outside of a region of interest. However, I've run into some
&gt;&gt; stumbling blocks and I'm looking for advice on the best way to proceed.
&gt;&gt; &gt;
&gt;&gt; &gt; Querying efficiently by geohash involves querying several regions
&gt;&gt; around a point. From what I can tell, Riak offers no way to query a
&gt;&gt; secondary index with multiple ranges. Having to query a several ranges,
&gt;&gt; merge them in the application layer, then pass them off to mapreduce seems
&gt;&gt; rather silly (and could mean passing GBs of data). Alternatively, I could
&gt;&gt; start straight with mapreduce, but key filtering seems to work only with
&gt;&gt; the primary key, which would force me into using the geohashed location as
&gt;&gt; the primary key (which would lead to collisions if two things existed at
&gt;&gt; the same point). I'd also like to avoid using the primary key as the
&gt;&gt; geohash as if the item moves I'd have to change all the references to it.
&gt;&gt; Lastly, I could do a less efficient mapreduce over a less precise geohash,
&gt;&gt; but this doesn't solve the issue of the equator (anything near the equator
&gt;&gt; would require mapreducing the entire dataset).
&gt;&gt; &gt;
&gt;&gt; &gt; Is there any way to query multiple ranges with a secondary index and
&gt;&gt; pass that off to mapreduce? Or should I just stick with the less efficient
&gt;&gt; mapreduce, and when near the equator, run two queries and later merge them?
&gt;&gt; Or am I going about this the wrong way?
&gt;&gt; &gt;
&gt;&gt; &gt; In any case, the final stage of my queries will involve mapreduce as
&gt;&gt; I'll need to further filter the items found in a region.
&gt;&gt; &gt;
&gt;&gt; &gt; Thank you,
&gt;&gt; &gt; Mark
&gt;&gt; &gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt; &gt; riak-users mailing list
&gt;&gt; &gt; riak-users@lists.basho.com
&gt;&gt; &gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

&gt;
&gt;
&gt;
&gt; --
&gt; Sean Cribbs 
&gt; Software Engineer
&gt; Basho Technologies, Inc.
&gt; http://basho.com/
&gt;
&gt;
