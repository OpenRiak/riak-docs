---
title: "Re: Getting all the Keys"
description: ""
project: community
lastmod: 2011-01-23T10:14:38-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg02078"
mailinglist_parent_id: "msg02065"
author_name: "Jeremiah Peschka"
project_section: "mailinglistitem"
sent_date: 2011-01-23T10:14:38-08:00
---


As a point of nit picky correctness, the one thing to keep in mind is that
the "relational" in "relational database" refers to a
relationor relation
variable. Which is a table and not the relationship between the
tables. The relationship between tables is a foreign key to humans and a
"referential constraint" to academics.

Jeremiah Peschka
Microsoft SQL Server MVP
MCITP: Database Developer, DBA


On Sat, Jan 22, 2011 at 8:46 PM, Eric Moritz wrote:

&gt; This is the best way for me to understand how to model data in Riak. Think
&gt; about the web. You always have a starting point. The starting point is an
&gt; URL. An URL is analogous to a key in Riak. A URL gets you a document on the
&gt; web, a key gets you a document in Riak.
&gt;
&gt; Now on the web page addressed by your URL has other URLs that serve as
&gt; pointers to other pages.
&gt;
&gt; In Riak, your starting doc(s) need to have references to other documents to
&gt; related them.
&gt;
&gt; In fact both systems, when defined this way are extremely relational. They
&gt; diverge from relational databases in the fact that there's tons of redundant
&gt; data and no built-in integrity checking.
&gt;
&gt; On the web this results in 404s and inconsistent titles in a tags. The
&gt; same problems happen in Riak; deleted keys could still be referenced by
&gt; other documents. It's all reminiscent of dangling pointers in my CS
&gt; classes. Just in that old C code I had to write, there was a lot of house
&gt; keeping to make sure integrity was preserved.
&gt;
&gt; Unlike the web, with Riak, we have complete control over what links to
&gt; what. Unfortunately it adds complexity to applications that otherwise would
&gt; be simple in an ACID DB. The benefit to this added complexity is AP.
&gt;
&gt; The folks who wrote the Dynamo paper state that, at least for them, this
&gt; added complexity when negligible because they were already designing their
&gt; services to compensate for integrity issues. Unfortunately for most of us,
&gt; our SQL databases let us ignore those issues.
&gt;
&gt; tl;dr think of Riak like the web. The web interrelates pages using URLs, we
&gt; have design our app's Riak docs similarly using key references.
&gt; On Jan 22, 2011 8:22 PM, "Sean Cribbs"  wrote:
&gt; &gt; On Jan 22, 2011, at 4:15 PM, Thomas Burdick wrote:
&gt; &gt;
&gt; &gt;&gt; \\* Why is key listing so slow?
&gt; &gt;
&gt; &gt; It is slow because, even if the keys are in RAM, you have to scan roughly
&gt; all of the keys in the cluster to get a listing for a single bucket. As a
&gt; certain person is fond of saying, "full table scan is full table scan".
&gt; There are ways to improve this, but without single-arbiters of state (and
&gt; points of failure) it is very costly.
&gt; &gt;
&gt; &gt;&gt; \\* What do people do in the context of purely using riak to do what I
&gt; want, have a big set of keys to iterate over?
&gt; &gt;
&gt; &gt; As others have said so eloquently, they don't, they use something else.
&gt; Or they try to minimize how frequently they do it. Part of the current
&gt; revolution in data storage is about realizing that no one tool is going to
&gt; completely fit your needs, and that that's good and right. Anyone who tells
&gt; you otherwise is selling you a bill of goods.
&gt; &gt;
&gt; &gt; To understand why listing keys is difficult, you have to understand
&gt; Riak's (and Dynamo's) original design motivations:
&gt; &gt;
&gt; &gt; \\* To be basically available at all times for reads and writes, which in
&gt; turn means to be tolerant of machine and network failures.
&gt; &gt; \\* To provide low-latency random access to large data sets. (Note I didn't
&gt; say an entire data set.)
&gt; &gt; \\* To scale linearly with minimal operational complexity.
&gt; &gt;
&gt; &gt; Everything has tradeoffs - these are the ones we chose with Riak. Now, we
&gt; (Basho) are actively trying to create ways to make discovering your data
&gt; easier (key-filters are one of them, as Justin mentioned we're discussing
&gt; counters and indices), but the majority of people who use Riak have ways of
&gt; discovering or knowing keys ahead of time. If that's not your case, you
&gt; should look into other solutions; some good ones have been mentioned in this
&gt; thread. That said, we hear your pain and are working hard to improve
&gt; usability while maintaining the properties discussed above.
&gt; &gt;
&gt; &gt; Cheers,
&gt; &gt;
&gt; &gt; Sean Cribbs 
&gt; &gt; Developer Advocate
&gt; &gt; Basho Technologies, Inc.
&gt; &gt; http://basho.com/
&gt; &gt;
&gt; &gt;
&gt; &gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; &gt; riak-users mailing list
&gt; &gt; riak-users@lists.basho.com
&gt; &gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;
&gt;
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

