---
title: "Re: Expected vs Actual Bucket Behavior"
description: ""
project: community
lastmod: 2010-07-20T15:00:22-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg00756"
mailinglist_parent_id: "msg00754"
author_name: "Eric Filson"
project_section: "mailinglistitem"
sent_date: 2010-07-20T15:00:22-07:00
---


On Tue, Jul 20, 2010 at 3:02 PM, Justin Sheehy  wrote:

&gt; Hi, Eric! Thanks for your thoughts.
&gt;
&gt; On Tue, Jul 20, 2010 at 12:39 PM, Eric Filson  wrote:
&gt;
&gt; &gt; I would think that this requirement,
&gt; &gt; retrieving all objects in a bucket, to be a \\_very\\_ common
&gt; &gt; place occurrence for modern web development and perhaps (depending on
&gt; &gt; requirements) \\_the\\_ most common function aside from retrieving a single
&gt; k/v
&gt; &gt; pair.
&gt;
&gt; I tend to see people that mostly try to write applications that don't
&gt; select everything from a whole bucket/table/whatever as a very
&gt; frequent occurrence, but different people have different requirements.
&gt; Certainly, it is sometimes unavoidable.
&gt;

Indeed, in my case it is :(


&gt;
&gt; &gt; In my mind, this seems to leave the only advantage to buckets in this
&gt; &gt; application to be namespacing... While certainly important, I'm fuzzy on
&gt; &gt; what the downside would be to allowing buckets to exist as a separate
&gt; &gt; partition/pseudo-table/etc... so that retrieving all objects in a bucket
&gt; &gt; would not need to read all objects in the entire system
&gt;
&gt; The namespacing aspect is a huge advantage for many people. Besides
&gt; the obvious way in which that allows people to avoid collisions, it is
&gt; a powerful tool for data modeling. For example, sets of 1-to-1
&gt; relationships can be very nicely represented as something like
&gt; "bucket1/keyA, bucket2/keyA, bucket3/keyA", which allows related items
&gt; to be fetched without any intermediate queries at all.
&gt;

I agree however, the same thing can be accomplished by prefixing your keys
with a "namespace"...

bucket\\_1\\_keyA, bucket\\_2\\_keyA, bucket\\_3\\_keyA

Obviously, buckets in Riak have additional functionality and allow for some
more complex but easier to use m/r functions across multiple buckets,
etc...


&gt;
&gt; One of the things that many users have become happily used to is that
&gt; buckets in Riak are generally "free"; they come into existence on
&gt; demand, and you can use as many of them as you want in the above or
&gt; any other fashion. This is in essence what conflicts with your
&gt; desire. Making buckets more fundamentally isolated from each other
&gt; would be difficult without incurring some incremental cost per bucket.
&gt;

For me, I am more than willing to add a small amount of overhead to the
storage engine for increased functionality and reduced overhead on the
application layer. Again this is obviously application specific and I'm not
saying it should all be converted over for all buckets exiting in their own
space for every implementation but certainly a different storage engine or
configuration option to allow this level/type of access would be nice :)


&gt; &gt; I might recommend a hybrid
&gt; &gt; solution (based in my limited knowledge of Riak)... What about allowing a
&gt; &gt; bucket property named something like "key\\_index" that points to a key
&gt; &gt; containing a value of "keys in bucket". Then, when calling GET
&gt; &gt; /riak/bucket, Riak would use the key\\_index to immediately reduce its
&gt; result
&gt; &gt; set before applying m/r funcs. While I understand this is essentially
&gt; what
&gt; &gt; a developer would do, it would certainly alleviate some code requirements
&gt; &gt; (application side) as well as make the behavior of retrieving a bucket's
&gt; &gt; contents more "expected" and efficient.
&gt;
&gt; A much earlier incarnation of Riak actually stored bucket keylists
&gt; explicitly in a fashion somewhat like what you describe. We removed
&gt; this as one of our biggest goals is predictable and understandable
&gt; behavior in a distributed systems sense, and a model like this one
&gt; turns each write operation into at least two operations. This isn't
&gt; just a performance issue, but also adds complexity. For instance, it
&gt; is not immediately obvious what should be returned to the client if a
&gt; data item write succeeds, but the read/write of the index fails?
&gt;

Haha, these are the exact reasons I would cite as a developer for using a
similar method on Riak's side... without the option of auto bucket indexing
it effectively places this double write into the application side where it
requires more cycles and more data across the wire. Instead of doing a
single write, from the application side, and allowing Riak to handle this,
you have to GET index\\_key, UPDATE index\\_key, ADD new\\_key... So rather than
having a single transaction with Riak, you have to have three transactions
with Riak + Application functionality. Inherently, this adds another level
of complexity into the application code base for something that could be
done more efficiently by the DB engine itself.

I would think a separate error number and message would suffice as a return
error, obviously though, this would require developers being made aware so
they can code for the exception.

Also, this would be optional, if the index\\_key wasn't set for the bucket
then this setup wouldn't be used. This would at least make the system more
flexible to the application requirements and developer preferences.


&gt; Most people using distributed data systems (including but not limited
&gt; to Riak) do explicit data modeling, using things like key identity as
&gt; above, or objects that contain links to each other (Riak has great
&gt; support for this) or other data modeling means to plan out their
&gt; expected queries in advance.
&gt;
&gt; &gt; Anyway, information is pretty limited on riak right now, seeing as how
&gt; it's
&gt; &gt; so new, but talk in my development circles is very positive and lively.
&gt;
&gt; Please do let us know any aspects of information on Riak that you
&gt; think are missing. We think that between the wiki, the web site, and
&gt; various other materials, the information is pretty good. Riak's been
&gt; open source for about a year, and in use longer than that; while there
&gt; are many things much older than Riak, we don't see relative youth as a
&gt; reason not to do things right.
&gt;
&gt; Thanks again for your thoughts, and I hope that this helps with your
&gt; understanding.


Some very valuable information, for me, would be seeing a breakdown of how
Riak scales out...

Something like showing how many keys in how many buckets takes how long with
how many nodes... (extended by, now with 2 more machines, now with more
complex m/r funcs, now with twice as many keys, etc...) I know this largely
depends on whatever map/reduce functions are being run however even a simple
example would be nice to see. As it is I have no idea how many queries per
second of what type I can run with how many active nodes? Again, I realize
this is something that needs to be benchmarked for any sort of accuracy but
I'm speaking more of targeting developers, like myself, who are looking into
this as a newer technology that may work for them. It is a very large
commitment of time and resources to design and implement something then
benchmark it in order to obtain the "if it will work for this application
efficiently" answer. Having some baseline stats from which to start may
prompt more developers to explore Riak as a storage solution.

And one more thanks for hearing me out and your feedback. I'd also like to
reiterate that I'm coming from a limited nosql background... however I feel
that's the case with the majority of developers out there today. My
recommendations for options are based on the real world application design
challenges I've personally been presented with over my career and that I
feel may be common to many other developers as well. Obviously, even adding
a single option such that I've mentioned is a massive undertaking on Basho's
part but they are definitely pieces of functionality that would make me say,
"done, Riak it is". Rather than... is there something else which would
better suit my needs... and when vying for adoption rate that's a major
factor :)
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

