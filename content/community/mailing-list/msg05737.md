---
title: "Clarifying \"Read-before-Write\""
description: ""
project: community
lastmod: 2011-11-25T17:14:46-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg05737"
author_name: "Andres Jaan Tack"
project_section: "mailinglistitem"
sent_date: 2011-11-25T17:14:46-08:00
---


So I was just reading and thinking about this, and I don't understand the
advice offered under "Read-before-Write" at
http://wiki.basho.com/Client-Implementation-Guide.html.

"Riak will return an encoded vector
clock
&gt; with every "fetch" or "read" request that does not result in a "not
&gt; found" response. In addition to the Client ID, this vector clock tells Riak
&gt; how to resolve concurrent writes, essentially representing the "last seen"
&gt; version of the object to which the client made modifications. In order to
&gt; prevent sibling 
&gt; explosion,
&gt; clients should always have a vector clock before sending a write, and send
&gt; the vector clock as part of the write request. Therefore, it is essential
&gt; that keys are fetched before being written (except in the case where Riak
&gt; selects the key or there is \\*a priori\\* knowledge that the key is new).
&gt; Client libraries that make this automatic will reduce operational issues by
&gt; limiting sibling explosion. Clients may also choose to perform automatic 
&gt; Sibling
&gt; Resolution
&gt; on read."


I'm having trouble understanding the advice. I get that if I'm aware of all
the siblings, I can resolve them (optionally) with that vector clock. What
I don't understand here: If an application PUTs to an object out of the
blue, not having read it first, should the client library
read-before-write? This seems like a great way to blow away siblings by
accident.

I'm having trouble understanding the advice. I get that if I'm aware of all
the siblings, I can resolve them (optionally) with that vector clock. What
I don't understand here: If an application PUTs to an object out of the
blue, not having read it first, should the client library
read-before-write? This seems like a great way to blow away siblings by
accident.

Or is the point rather to avoid sibling explosion for applications that
don't care about losing information?

--
Andres
