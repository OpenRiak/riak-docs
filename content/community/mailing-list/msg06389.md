---
title: "Re: Connection Pooling with the python-riak-client"
description: ""
project: community
lastmod: 2012-01-24T09:34:43-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg06389"
mailinglist_parent_id: "msg06383"
author_name: "Michael Clemmons"
project_section: "mailinglistitem"
sent_date: 2012-01-24T09:34:43-08:00
---


Greg,
Your amazing thanks. In my application its failing on the start of the
application, I do not believe while trying to do a request but its possible
let me grok and get back to you with some trace backs.
As far as Im aware to define more than one hostport with the client you
still have to hack the client. Adding an optional hostports or servers
parameter would be simple.
Being able to define the connection manager as a kwarg might be a good
option. If the intent is to define the conextmanager by subclassing the
transport, things make more sense. I think for multiple nodes round robin
might be the most sane default for longterm or short term connections.
Thanks again for replying, I'll see what happens when I try this with
multiple live nodes, and get back with more thoughts.

On Mon, Jan 23, 2012 at 7:08 PM, Greg Stein  wrote:

&gt; On Fri, Jan 20, 2012 at 15:53, Michael Clemmons 
&gt; wrote:
&gt; &gt;...
&gt; &gt; I've decided to go back and cleanup that approach and reapply it to the
&gt; &gt; current master branch. To my surprise I found that the ConnectionManager
&gt; &gt; supports multiple connections and has the tools to add and remove them.
&gt; &gt; Looking at the simple case of the RiakHttpTransport layer and the
&gt; &gt; http\\_request method it looks like it should grab a new connection(or an
&gt; old
&gt; &gt; one) and try it and if it fails move on to the next putting the host port
&gt; &gt; pair at the bottom of the list.
&gt;
&gt; Right. That is the intent.
&gt;
&gt; I will note that a failure does not automatically remove a host/port
&gt; pair, but fails the particular request (after N retries). I'm not sure
&gt; that is entirely "the best strategy" (see below, ref: many
&gt; strategies), but the plumbing should be there for applications to
&gt; decide the proper behavior. It may be possible to decide a
&gt; best/default strategy so that (most) applications do not have to get
&gt; involved.
&gt;
&gt; &gt; So it looked like all I needed to do was update the client code to
&gt; accept a
&gt; &gt; list of hostport pairs and it would just work, which sounded too easy to
&gt; be
&gt; &gt; true. I tested it anyways and if I use one hostport that is a working
&gt; riak
&gt; &gt; node it connects and everything works. If I include 2 nodes one working
&gt; and
&gt; &gt; one a random port it fails no matter the order. So its not just trying
&gt; to
&gt; &gt; connect to the first and failing its connecting to them all and failing
&gt; if
&gt; &gt; any fail.
&gt;
&gt; Well, yeah. You started the thing up, saying all the host/port pairs
&gt; were proper. It is telling you they are not :-)
&gt;
&gt; One question: when does the failure happen? At instantiation time, or
&gt; later at request time? On the first request, or some later request?
&gt;
&gt; (as I recall, it should lazy-open all host/port pairs, so the failure
&gt; should not happen until later... and only when the pair is attempted
&gt; to be used)
&gt;
&gt; &gt; Anyone have any idea of why its built this way and what other solutions
&gt;
&gt; The overall intent is to connect to (at least) one known working node.
&gt; That node can then be queried for "all" other known working nodes,
&gt; which are then added into the ConnectionManager (CM). The (long-lived)
&gt; process can then continue to monitor the status of the ring and make
&gt; corresponding updates to the CM.
&gt;
&gt; The code does not (yet) have a well-defined process for \\*removal\\* of
&gt; non-working nodes. That is a complex application-level decision.
&gt; Should it remove the host/port permanently? If it is just a network
&gt; glitch, or the particular host is have transient issues, then maybe
&gt; the pair should be kept around (but unused) and re-installed in a
&gt; minute or two when the host starts replying again. Maybe you just
&gt; remove the pair and wait for a general background monitoring thread to
&gt; note their existence and reinstall the pair.
&gt;
&gt; For a single-threaded, short-lived application, the multiple host/port
&gt; pair capability is not very useful. That functionality is really
&gt; necessary for multiple threads and/or long-lived processes. In this
&gt; scenario, as existing connections get used up, the CM will spin up new
&gt; connections for threads to use to perform their operations. (the
&gt; underlying connections are persistent and reused until the server
&gt; decides to close them, where the client will attempt to reopen and
&gt; reuse the connection again)
&gt;
&gt; What happens when you give the CM a list of \\*working\\* host/port pairs?
&gt; Does that still fail for you? It is true that when one goes down, then
&gt; some level of the stack should remove the pair, but "which level" just
&gt; hasn't been decided.
&gt;
&gt; There is also a "monitor" concept that has been sketched out in the
&gt; code, but not implemented. See riak/transports/monitor.py. That should
&gt; be used in a long-running application to periodically hit the riak
&gt; servers, querying what nodes are in the ring, and adding new ones and
&gt; removing broken ones. I sketched it out but neither myself nor anybody
&gt; else has further worked on such logic.
&gt;
&gt; &gt; people have worked out on their own? My intent is to do this so it
&gt; merges
&gt; &gt; cleanly with the current master, and doesn't introduce unnecessary
&gt; change,
&gt; &gt; to increase the likelyhood of a successful pull request.
&gt;
&gt; For production code, some of this host/port pair management needs to
&gt; be done. It would be nice to have the monitor (thread) completed, but
&gt; that may not be appropriate for your application.
&gt;
&gt; I think that Brett's work on timeouts is necessary for production
&gt; code. The key decision point here is Python compatibility support. If
&gt; the library requires 2.7, then it should be quite easy to merge his
&gt; changes. I think (but don't recall offhand) that the timeout parameter
&gt; for HTTPConnection might be available in 2.6, but I definitely know it
&gt; is not available for Python 2.5. When I began my work on the client, I
&gt; was targeting 2.5 and made many compatibility changes with that in
&gt; mind. This was primarily to support my 2.5-based dev environment, even
&gt; though I was going to deploy to 2.7. I eventually upgraded my dev
&gt; environment, so compatibility isn't a huge concern for me any more. I
&gt; would leave that decision to the Basho folks, who are controlling the
&gt; decisions and guidance for the client.
&gt;
&gt; Hopefully, that gives you a good background on the current decision
&gt; and thoughts around it. I'd be more than happy to elaborate further on
&gt; the choices made... please just ask!
&gt;
&gt; Cheers,
&gt; -g
&gt;

-- 
-Michael
