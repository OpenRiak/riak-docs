---
title: "Re: Fun with Unicode"
description: ""
project: community
lastmod: 2013-02-01T06:28:18-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg09958"
author_name: "Sean Cribbs"
project_section: "mailinglistitem"
sent_date: 2013-02-01T06:28:18-08:00
---


Anton,

I don't see any reason why this can't be fixed. However, since I'm not
familiar with the specifics of the JSON implementation, I'll need
assistance. Please open an issue or pull-request on the Python client:
https://github.com/basho/riak-python-client/issues. We are open to
major, breaking changes for the next release.

On Fri, Feb 1, 2013 at 8:06 AM, Anton  wrote:
&gt; Let's talk python and Unicode (yey!)
&gt;
&gt; The objects that I want to store will have non-ASCII strings in them.
&gt; Potentially a lot. How much is a lot? "Very many millions" should be a
&gt; good estimate.
&gt;
&gt; Now, the default behaviour for storing a python object (ok, a dict of
&gt; stuff), using the PBC transport is to pass them to json and encode
&gt; them. I'm ok with that, I like JSON and the fact that I can read out
&gt; an object in JSON, using a browser, helps a lot. It's really great for
&gt; developing project-specific tools, say debugging tools.
&gt;
&gt; But here is where the fun part starts. The JSON encoder in python is
&gt; not a simple thing, and takes a lot of parameters. And by default it
&gt; works. So well that people rarely look at what's going on. When you
&gt; look at what's going on, however, things get more entertaining.
&gt;
&gt; The JSON encoder works on unicode objects, not strings. When you pass
&gt; it unicode objects, it's happy. When you pass it strings, it decodes
&gt; them, using a specified encoding. By default this is set to 'utf-8'
&gt; which makes everything quite ok. So far so good. However, there's
&gt; another option - 'ensure\\_ascii'. This is set to True by default and it
&gt; means that the JSON encoder will spew out an ASCII-encoded string.
&gt; That is, in the result, every unicode code-point is encoded as \\u0123,
&gt; or a total of 6 bytes.
&gt;
&gt; Now, this is not good. For one, the JSON RFCs expect Unicode, encoded
&gt; using UTF-\\*. Also, even if much of the data will require 3bytes in
&gt; UTF-8, that's still only half the bytes that the python default would
&gt; take.
&gt;
&gt; Now, consider this elementary example. It already gives a significant
&gt; (in bytes) difference for a short string:
&gt; http://pastie.org/6011147
&gt;
&gt;
&gt; Please tell me I'm not going crazy and all this is the state of
&gt; affairs and it is, in fact, wrong and can/should be fixed.
&gt;

-- 
Sean Cribbs 
Software Engineer
Basho Technologies, Inc.
http://basho.com/

