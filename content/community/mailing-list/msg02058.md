---
title: "Re: Getting all the Keys"
description: ""
project: community
lastmod: 2011-01-22T09:23:33-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg02058"
mailinglist_parent_id: "msg02055"
author_name: "Thomas Burdick"
project_section: "mailinglistitem"
sent_date: 2011-01-22T09:23:33-08:00
---


I guess I'm left even more baffled now, if the keys are all in memory and I
only have 1 real node in my cluster, why would it take half a second to
obtain all the keys from a completely empty database? If it takes half a
second to just list the keys out like that how could a map/reduce ever take
less time? Doesn't map/reduce need to go through all the keys? Does
streaming the keys really improve the ability to go through all of them or
does it just let you incrementally work with them?

There's no real seemingly obvious way to map meaningful names in this case,
the keys are just random unique identifiers, in postgresql I'd be using the
serial type which clearly would never work in the case of riak.

So in case of riak I've been using uuid's thus far. So far in order to get
any sort of meaningful speed I just serialize my own erlang list of binary
uuid's to a table. That really isn't that fast either though, it just
happens to be faster than list\\_keys at the moment.

So really whats the solution to just having a list of like 50k keys that can
quickly be appended to without taking seconds to then retrieve later on. Or
is this just not a valid use case for riak at all? That would suck cause
again, I really like the notion of an AP oriented database!

Tom Burdick


On Sat, Jan 22, 2011 at 10:31 AM, Alexander Sicular wrote:

&gt; Hi Thomas,
&gt;
&gt; This is a topic that has come up many times. Lemme just hit a couple of
&gt; high notes in no particular order:
&gt;
&gt; - If you must do a list keys op on a bucket, you must must must use
&gt; "?keys=stream". True will block on the coordinating node until all nodes
&gt; return their keys. Stream will start sending keys as soon as the first node
&gt; returns.
&gt;
&gt; - "list keys" is one of the most expensive native operations you can
&gt; perform in Riak. Not only does it do a full key scan of all the keys in your
&gt; bucket, but all the keys in your cluster. It is obnoxiously expensive and
&gt; only more so as the number of keys in your cluster grows. There has been
&gt; discussions about changing this but everything comes with a cost (more open
&gt; file descriptors) and I do not believe a decision has been made yet.
&gt;
&gt; -Riak is in no way a relational system. It is, in fact, about as opposite
&gt; as you can get. Incidentally, "select \\*" is generally not recommended in the
&gt; Kingdom of Relations and regarded as wasteful. You need a bit of a mind
&gt; shift from relational world to have success with nosql in general and Riak
&gt; in particular.
&gt;
&gt; -There are no native indices in Riak. By default Riak uses the bitcask
&gt; backend. Bitcask has many advantages but one disadvantage is that all keys
&gt; (key length + a bit of overhead) must fit in ram.
&gt;
&gt; -Do not use "?keys=true". Your computer will melt. And then your face.
&gt;
&gt; -As of Riak 0.14 your m/r can filter on key name. I would highly recommend
&gt; that your data architecture take this into account by using keys that have
&gt; meaningful names. This will allow you to not scan every key in your cluster.
&gt;
&gt; -Buckets are analogous to relational tables but only just. In Riak, you can
&gt; think of a bucket as a namespace holder (it is used as part of the default
&gt; circular hash function) but primarily as a mechanism to differentiate system
&gt; settings from one group of keys to the next.
&gt;
&gt; -There is no penalty for unlimited buckets except for when their settings
&gt; deviate from the system defaults. By settings I mean things like hooks,
&gt; replication values and backends among others.
&gt;
&gt; -One should list keys by truth if one enjoys sitting in parking lots on the
&gt; freeway on a scorching summers day or perhaps waiting in a TSA line at your
&gt; nearest international point of embarkation surrounded by octomom families
&gt; all the while juggling between the grope or the pr0n slideshow. If that is
&gt; for you, use "?keys=true".
&gt;
&gt; -Virtually everything in Riak is transient. Meaning, for the most part (not
&gt; including the 60 seconds or so of m/r cache), there is no caching going on
&gt; in Riak outside of the operating system. Ie. your subsequent queries will do
&gt; more or less the same work as their predecessors. You need to cache your own
&gt; results if you want to reuse them... quickly.
&gt;
&gt;
&gt;
&gt; Oh, there's more but I'm pretty jelloed from last night. Welcome to the
&gt; fold, Thomas. Can I call you Tom?
&gt;
&gt; Cheers,
&gt; -Alexander Sicular
&gt;
&gt; @siculars
&gt;
&gt; On Jan 22, 2011, at 10:19 AM, Thomas Burdick wrote:
&gt;
&gt; &gt; I've been playing around with riak lately as really my first usage of a
&gt; distributed key/value store. I quite like many of the concepts and
&gt; possibilities of Riak and what it may deliver, however I'm really stuck on
&gt; an issue.
&gt; &gt;
&gt; &gt; Doing the equivalent of a select \\* from sometable in riak is seemingly
&gt; slow. As a quick test I tried...
&gt; &gt;
&gt; &gt; http://localhost:8098/riak/mytable?keys=true
&gt; &gt;
&gt; &gt; Before even iterating over the keys this was unbearably slow already.
&gt; This took almost half a second on my machine where mytable is completely
&gt; empty!
&gt; &gt;
&gt; &gt; I'm a little baffled, I would assume that getting all the keys of a table
&gt; is an incredibly common task? How do I get all the keys of a table quickly?
&gt; By quickly I mean a few milliseconds or less as I would expect of even a
&gt; "slow" rdbms with an empty table, even some tables with 1000's of items can
&gt; get all the primary keys of a sql table in a few milliseconds.
&gt; &gt;
&gt; &gt; Tom Burdick
&gt; &gt;
