---
title: "Re: LevelDB"
description: ""
project: community
lastmod: 2012-08-21T19:29:58-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg08347"
mailinglist_parent_id: "msg08345"
author_name: "David Yu"
project_section: "mailinglistitem"
sent_date: 2012-08-21T19:29:58-07:00
---


On Wed, Aug 22, 2012 at 5:33 AM, Alexander Sicular wrote:

&gt; I was in the Riak 1.2 webinar earlier today and asked a leveldb question
&gt; about insertion order and durability vs. bitcask's WOL architecture. Joe
&gt; was not able to get to my question then but took the time to write me a
&gt; detailed answer. Great engineers at Basho taking time to answer questions
&gt; is a great thing. Thanks Joe!
&gt;
&gt; -Alexander Sicular
&gt;
&gt; @siculars
&gt;
&gt; Begin forwarded message:
&gt;
&gt; \\*From: \\*Joseph Blomstedt 
&gt; \\*Subject: \\*\\*LevelDB\\*
&gt; \\*Date: \\*August 21, 2012 3:45:45 PM EDT
&gt; \\*To: \\*sicul...@gmail.com
&gt;
&gt; Alexander,
&gt;
&gt; I noticed your LevelDB question in the webinar as Reem was closing
&gt; things out, so I figured I'd follow up via email.
&gt;
&gt; As you know, Bitcask maintains a strict set of write-logs and an
&gt; in-memory hash table that maps keys to (file, offset). Pretty
&gt; straightforward. Compaction is a separate thing that happens based on
&gt; independent triggers.
&gt;
&gt; LevelDB is rather different. LevelDB does maintain a WAL, but it's
&gt; short-lived and only for crash recovery. LevelDB writes to the WAL,
&gt; but also keeps the object in an in-memory write buffer (configurable
&gt; size, increased in Riak 1.2 by 10x from Riak 1.1). After the buffer
&gt; becomes full, LevelDB writes the data to disk as a Level-0 SST (data
&gt; in sorted order + sorted index at the end of the file).
&gt;
&gt; There can be multiple Level-0 SSTs. To read a key, LevelDB looks at
&gt; the index in each SST starting from newest file to oldest. For
&gt; performance, there's an LRU cache of indexes so you're not always
&gt; hitting disk. LevelDB now also includes bloom filters (used in Riak
&gt; 1.2) to make it easier to skip non-interesting SSTs.
&gt;
&gt; To make things more efficient, LevelDB does compaction/merging in a
&gt; background thread. A set of Level-0 files will be selected and merged
&gt; together into a larger Level-1 file. The format is the same, but the
&gt; file is now larger and includes the data from multiple Level-0 files.
&gt; The original Level-0 files are then removed. Likewise, Level-1 files
&gt; are merged into Level-2 files, and Level-2 into Level-3, etc. Each
&gt; Level having larger files with a greater chunk of adjacent, sorted
&gt; data.
&gt;
&gt; To read, you check newest to oldest on Level 0, then Level 1, then Level
&gt; 2, etc.
&gt;
&gt; While compaction is a background thing, LevelDB limits the number of
&gt; Level-0 files you can have. If you hit the limit, LevelDB will block
&gt; writes until files have been merged into Level-1. With a single
&gt; compaction thread, it was easy to max out LevelDB in Riak 1.1, and
&gt; these stalls were fairly frequent and hurt 95% and up latencies, as
&gt; well as greatly hurt throughput. Our change to use multiple compaction
&gt; threads has greatly improved the how quickly compaction occurs, and
&gt; writes rarely (if ever) end up stalling. To further improve things,
&gt; there's the adaptive write throttling that I mentioned that will slow
&gt; down writes (increased latency) in order to ensure compaction isn't
&gt; heavily affected and remains ahead of write traffic -- thus, further
&gt; preventing stalls. Net effect is somewhat higher latency and lower
&gt; throughput that is more consistent (ie. 95%+ are tighter around
&gt; average latency).
&gt;
&gt; I hope this answers your question.
&gt;
&gt; -Joe
&gt;
&gt;
&gt; Thanks for sharing!

&gt;

-- 
When the cat is away, the mouse is alone.
- David Yu
