---
title: "Re: The power of the siblings...."
description: ""
project: community
lastmod: 2011-10-04T13:15:53-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg05034"
mailinglist_parent_id: "msg05027"
author_name: "Andy Skelton"
project_section: "mailinglistitem"
sent_date: 2011-10-04T13:15:53-07:00
---


Ryan Zezeski wrote:
&gt; Mike Oxford wrote:
&gt;&gt; The big "problem" is that you have to have "knowledge of the buckets"
&gt;&gt; to later correlate them. Listing buckets is expensive.
&gt;
&gt; I'm not sure if you realize this but "bucket" is really just a namespace in
&gt; the key.  Said another way =/.  The  is
&gt; what's hashed and determines the ring position.  There are no special
&gt; provisions for a bucket for the most part (one exception I can think of is
&gt; custom properties which get stored in the gossiped ring).

Right. There is no list of buckets. Computing the list is ludicrously
expensive because it involves folding over all of the keys in the
backend, extracting the bucket name from each, and accumulating these
in a set.

Listing all the keys in a bucket is similarly expensive. It folds over
all the keys, extracts the bucket name, matches against the desired
bucket (if any), and then accumulates the keys. However, if you
specify the bucket when listing keys there is an optimization
available to key listing that is impossible for bucket listing.

I've given it some thought because I intend to regularly MR over
entire buckets which involves listing keys. The best solution I've
found so far is to partition the keyspace by using the multi backend.
When you ask for all of the keys in a given bucket, only the backend
that stores that bucket is consulted. Ideally, any bucket that will
need to produce its key list gets its own keyspace (backend).

Andy

