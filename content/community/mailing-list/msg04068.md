---
title: "Re: Connection Pool with Erlang PB Client Necessary?"
description: ""
project: community
lastmod: 2011-07-26T11:35:32-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg04068"
mailinglist_parent_id: "msg04067"
author_name: "Andrew Berman"
project_section: "mailinglistitem"
sent_date: 2011-07-26T11:35:32-07:00
---


Thanks for the reply Bryan. This all makes sense. I am fairly new to
Erlang and wasn't sure if using a gen\\_server solved some of the issues
with connections. From what I've seen a lot of people simply make
calls to Riak directly from a resource and so I thought having a
gen\\_server in front of Riak would help to manage things better.
Apparently it doesn't.

So, then, two more questions. I have used connection pools in Java
like C3P0 and they can ramp up connections and then cull connections
when there is a period of inactivity. The only pooler I've found that
does this is: https://github.com/seth/pooler . Do you have any other
recommendations on connection poolers?

Second, I'm still a little confused on client ID. I thought client Id
represented an actual client, not a connection. So, in my case, the
gen\\_server is one client which makes multiple connections. After
seeing what you wrote and reading a bit more on it, it seems like
client Id should just be some random string (base64 encoded) that
should be generated on creating a connection. Is that right?

Thanks for your help!

Andrew

On Tue, Jul 26, 2011 at 9:39 AM, Bryan O'Sullivan  wrote:
&gt; On Mon, Jul 25, 2011 at 4:03 PM, Andrew Berman  wrote:
&gt;&gt;
&gt;&gt; I know that this subject has been brought up before, but I'm still
&gt;&gt; wondering what the value of a connection pool is with Riak.
&gt;
&gt; It's a big deal:
&gt;
&gt; It amortises TCP and PBC connection setup overhead over a number of
&gt; requests, thereby reducing average query latency.
&gt; It greatly reduces the likelihood that very busy clients and servers will
&gt; run out of limited resources that are effectively invisible, e.g. closed TCP
&gt; connections stuck in TIME\\_WAIT.
&gt;
&gt; Each of the above is a pretty big deal. Of course, connection pooling isn't
&gt; free.
&gt;
&gt; If you have many clients talking to a server sporadically, you may end up
&gt; with large numbers of open-and-idle connections on a server, which will both
&gt; consume resources and increase latency for all other clients. This is
&gt; usually only a problem with a very large number (many thousands) of clients
&gt; per server, and it usually only arises with poorly written and tuned
&gt; connection pooling libraries. But ...
&gt; ... Most connection pooling libraries are poorly written and tuned, so
&gt; they'll behave pathologically just when you need them not to.
&gt; Since you don't set up a connection per request, the requests where you \\*do\\*
&gt; need to set up a connection are going to be more expensive than those where
&gt; you don't, so you'll see jitter in your latency profile. About 99.9% of
&gt; users will never, ever care about this.
&gt;&gt;
&gt;&gt; Since Erlang processes are so small and fast to
&gt;&gt; create, is there really any overhead in having the gen\\_server create a
&gt;&gt; new connection (with the same client id) each time it needs to access
&gt;&gt; Riak?
&gt;
&gt; Of course. The overhead of Erlang processes has nothing to do with the cost
&gt; of setting up a connection.
&gt; Also, you really don't want to be using the same client ID repeatedly across
&gt; different connections. That's an awesome way to cause bugs with vclock
&gt; resolution that end up being very very hard to diagnose.

