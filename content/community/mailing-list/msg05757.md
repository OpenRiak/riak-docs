---
title: "Re: [lager] RFC on refactorings for a Graylog2 backend"
description: ""
project: community
lastmod: 2011-11-28T10:35:06-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg05757"
mailinglist_parent_id: "msg05756"
author_name: "Andrew Thompson"
project_section: "mailinglistitem"
sent_date: 2011-11-28T10:35:06-08:00
---


On Mon, Nov 28, 2011 at 12:47:17PM -0500, Jason Wagner wrote:
&gt; This is a very developer oriented question about Lager that I'm posting
&gt; here because I didn't find a dedicated list.

Yes, it doesn't have a list. I'm not sure if it is worth rectifying that
yet. Here should be fine for now.

&gt; I'm working on a Graylog2 backend for Lager. I'm sitting on a very basic
&gt; plugin that does little more than post log messages to a graylog2 system
&gt; that I'll push to github after I do some integration testing tonight.
&gt; 
&gt; However, there's a next step with the Graylog2 integration that would
&gt; really leverage the power of both tools-- pushing Lager's trace attributes
&gt; into Graylog2 user fields to really leverage the analytics that the newest
&gt; versions of Graylog2 provide. This would allow both pre-log trace
&gt; filtering and after the fact trace analysis through Graylog2.
&gt; 
&gt; This would be a major change to the Lager internals and I wanted to solicit
&gt; opinions on the changes.
&gt; 
&gt; \\*Proposed changes
&gt; \\*\\*Pass through all trace attributes\\*
&gt; The backends need to receive all trace attributes, including default
&gt; attributes such as line, file, function, pid, etc. This would allow proper
&gt; population of the graylog2 fields.
&gt; 
&gt; I would change this by removing the lager\\_transform:transform\\_statement's
&gt; call of lager\\_util:check\\_traces so that all Traces got passed through. I
&gt; don't believe this would impact any backends except via sending them more
&gt; payload in the event, but please correct me if I'm wrong.

I've actually been considering doing this as well, for similar reasons.
I don't see a problem with doing it.

&gt; \\*Refactor message formatting\\*
&gt; The formatting needs to be extracted and externalized from lager:log and
&gt; lager:log\\_dest. This is probably desirable, anyway, since it would be a
&gt; very small step from this to have completely orthogonal format/sink
&gt; separation, allowing for a user compromise between speed and flexibility in
&gt; their log file formats.
&gt; 
&gt; I would create a behavior lager\\_message\\_formatter with one function that
&gt; takes the trace attributes, the message, and returns an iolist for output.
&gt; The current one would simply be:
&gt; 
&gt; format(Config,Trace,Format,Args) -&gt;
&gt; Pid=proplists:get\\_value(pid,Trace),
&gt; % etc for Module, Function, Line, Level
&gt; [["[", atom\\_to\\_list(Level), "] "],
&gt; io\\_lib:format("~p@~p:~p:~p ", [Pid, Module, Function, Line]),
&gt; safe\\_format\\_chop(Format, Args, 4096)].
&gt; 
&gt; The backends would make this call rather than the lager:log or
&gt; lager:log\\_dest. This would allow for a configuration parameter on the
&gt; backends to set which formatter they use, with a reasonable default, and
&gt; different formats for each backend configuration.

I think that might be overkill, but I suppose it's acceptable.

&gt; 
&gt; \\*Concerns\\*
&gt; One drawback is that it significantly increases the size of the events,
&gt; especially if there is concern about run-away tuples being sent. I'm not
&gt; sure how this would impact the performance in the long haul.
&gt; 
&gt; The formatting change also pushes some of the workload from the user
&gt; process to the logging process. This can be an advantage if the workloads
&gt; aren't taxing the backend, but could penalize even simple logging
&gt; statements if the backend gets swamped and can't format/process fast
&gt; enough. The potentially large messages have impact this as well.

Technically, this won't happen because lager uses sync\\_notify, which
means the log call blocks until all the backends have handled it.
However, this \\*does\\* mean that long log formatting calls in the
gen\\_event will probably cause logging calls to block \\*more\\*.

What about doing the format string formatting in the calling process,
\\*once\\*, and then just sending along the rest of the data (timestamp,
callsite information, trace attributes, etc) with the output from doing
the string formatting? That should be the meat of the formatting anyway,
and I'd like to make sure we only do it once (we actually do it twice at
the moment, if a trace matches).

&gt; There are a couple ways to mitigate this-- additional checks on the log
&gt; statement, separate format processes from write processes and pool the
&gt; formatters, and other ideas that I wouldn't propose until I actually see
&gt; the bottleneck.
&gt; 
&gt; \\*Request For Comments\\*
&gt; Are these changes desirable in the direction of lager?
&gt; 
&gt; I've seen performance based changes in the recent history. Is performance
&gt; paramount over flexibility? How do you currently measure performance? Are
&gt; any scripts,scenarios,etc available?
&gt; 
&gt; Any historical lessons that I might be unaware in the vicinity of things
&gt; I'd be changing?

I think overall this is the path Lager is going to have to tread.

I'd rather balance Lager in the direction of flexibility and power over
performance, but egregious bottlenecks shouldn't be tolerated if there's
something that can be done to fix them. Lager is really about \\*safely\\*
logging messages, making them easy to read and being operationally
powerful. It already lags the competitors in performance, for the most
part, because of things it does to further these goals.

I have some simple performance testing code here:

https://github.com/Vagabond/logbench

But it's fairly unscientific right now, and needs some rewriting. I've
also got a half-finished benchmark blogpost comparing lager to the
alternatives, which also needs some rewriting.

So the TLDR is; I think you're on the right path, go ahead and make the
changes and I'll certainly review them for inclusion. If you don't I'll
probably end up doing something similar anyway, but it'll take longer
(I have other projects at basho to complete ATM).

Andrew

