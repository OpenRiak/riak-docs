---
title: "Re: Question: Object Not Saved After Save/Delete/Save"
description: ""
project: community
lastmod: 2011-06-06T09:20:06-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg03582"
mailinglist_parent_id: "msg03554"
author_name: "Keith Bennett"
project_section: "mailinglistitem"
sent_date: 2011-06-06T09:20:06-07:00
---


Sean and All -

In case it helps, the problem manifested on riak 0.14.0 on Mac OS but not on an 
Ubuntu VM.

The most recent version available for download at 
http://downloads.basho.com/riak/CURRENT/ for Mac OS was 0.14.0, so that's what 
I'm using. I realize that would have been helpful information I could have 
provided before, and apologize for not mentioning it -- I forgot that I had to 
use an earlier version to run it on the Mac. Are there any plans to provide 
more recent versions for the Mac? Or can I build from one of the other 
packages? 

Also, Is there a way within Riak::Client or somewhere else in the ruby riak 
client gem or riak executables or config files to get the server version number 
and possibly OS information? I do see this:

{ % }: ls -1 releases 
 
 6.Jun.11 12.18
0.14.0
start\\_erl.data

...is this the best way?

Thanks,
Keith

On Jun 4, 2011, at 11:26 AM, Sean Cribbs wrote:

&gt; I already have an issue open on the tracker to deal with some of the client 
&gt; semantics changes (https://github.com/seancribbs/ripple/issues/166); it might 
&gt; be broken out into separate issues so it can be completed.
&gt; 
&gt; Sean Cribbs 
&gt; Developer Advocate
&gt; Basho Technologies, Inc.
&gt; http://basho.com/
&gt; 
&gt; On Jun 3, 2011, at 6:19 PM, Andrew Thompson wrote:
&gt; 
&gt;&gt; On Fri, Jun 03, 2011 at 06:08:06PM -0400, Keith Bennett wrote:
&gt;&gt;&gt; Aphyr & Andrew -
&gt;&gt;&gt; 
&gt;&gt;&gt; Thanks for your responses. I'm trying to wrap my head around the issues 
&gt;&gt;&gt; you raised, and I must confess it's difficult. Anyway, some questions for 
&gt;&gt;&gt; you...
&gt;&gt;&gt; 
&gt;&gt;&gt; On Jun 3, 2011, at 5:12 PM, Andrew Thompson wrote:
&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; On Fri, Jun 03, 2011 at 02:00:23PM -0700, Aphyr wrote:
&gt;&gt;&gt;&gt;&gt; Riak can't use the vclock for conflict resolution on a fresh object,
&gt;&gt;&gt;&gt;&gt; i.e. one without a vclock. Deletes are writes. You should use get or
&gt;&gt;&gt;&gt;&gt; reload before writing to help Riak sequence your writes correctly.
&gt;&gt;&gt; 
&gt;&gt;&gt; If the caller doesn't have a handle to the RObject in the Ruby framework, 
&gt;&gt;&gt; or the metadata of an HTTP response, but is only accessing the data by 
&gt;&gt;&gt; bucket and key values, is there any way to use reload? And if the object 
&gt;&gt;&gt; has been deleted is there any way to use get?
&gt;&gt;&gt; 
&gt;&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt;&gt; On top of this, Riak has some weirdness around very quick sequences
&gt;&gt;&gt;&gt;&gt; of deletes/writes due, IIRC, to deletes not being tagged with a
&gt;&gt;&gt;&gt;&gt; vector clock. I... think... this will be addressed in an upcoming
&gt;&gt;&gt;&gt;&gt; release.
&gt;&gt;&gt; 
&gt;&gt;&gt; I tried inserting a 20 second pause between each read/write, but there was 
&gt;&gt;&gt; no change in the behavior. Should it be longer than that?
&gt;&gt; 
&gt;&gt; This is scary, it should not be possible to trigger this behaviour with
&gt;&gt; such a large gap. Even 10ms was enough to prevent it in my testing.
&gt;&gt;&gt; 
&gt;&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; Ah, my favorite bug. This is indeed mostly solved on master by exposing
&gt;&gt;&gt;&gt; the vclocks for tombstones so they can be cleanly overwritten by the new
&gt;&gt;&gt;&gt; object rather than merged into a frankenobject that has the metadata of
&gt;&gt;&gt;&gt; the tombstone but the value of the new object (which is then subject to
&gt;&gt;&gt;&gt; real deletion).
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; So the fix for the issue was to add a new type of return value for a get
&gt;&gt;&gt;&gt; that finds a tombstone, {error, {deleted, Vclock}} instead of always
&gt;&gt;&gt;&gt; returning {error, notfound} on a true notfound or when a tombstone is
&gt;&gt;&gt;&gt; encountered.
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt; That sounds like exactly what I need. Can I simulate that fix in my Ruby 
&gt;&gt;&gt; code? Any pointers about that? Any chance we could get that into the Ruby 
&gt;&gt;&gt; client? I'd be willing to put a little effort into that, but I don't 
&gt;&gt;&gt; really understand the issues well enough yet.
&gt;&gt; 
&gt;&gt; I suspect we will want to update the clients to support this, but I
&gt;&gt; don't know of a specific plan to do so yet. I don't know the details of
&gt;&gt; the ruby client enough (or at all) to advise on making changes to it.
&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; An example of how to safely delete for all 3 APIs can be found at
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; https://gist.github.com/965376
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; Note the new deletedvclock option. The REST API will always use this
&gt;&gt;&gt;&gt; option on gets and will return a X-Riak-Vclock header along with any 404
&gt;&gt;&gt;&gt; that is actually a tombstone.
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; Some further reading can be found here:
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; https://issues.basho.com/show\\_bug.cgi?id=260
&gt;&gt;&gt;&gt; https://issues.basho.com/show\\_bug.cgi?id=555
&gt;&gt;&gt;&gt; 
&gt;&gt;&gt;&gt; So, long story short; either upgrade to master and use the deletedvclock
&gt;&gt;&gt;&gt; option or avoid doing rapid put/delete/put cycles.
&gt;&gt;&gt; 
&gt;&gt;&gt; You're suggesting I use mercurial to pull down the HEAD and use that, right?
&gt;&gt;&gt; 
&gt;&gt; 
&gt;&gt; git, not mercurial. I don't think we maintain the bitbucket repos
&gt;&gt; anymore, everything has moved to github.
&gt;&gt; 
&gt;&gt; Andrew
&gt;&gt; 
&gt; 
&gt; 
