---
title: "Re: if_not_modified"
description: ""
project: community
lastmod: 2012-11-08T10:48:26-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg09249"
mailinglist_parent_id: "msg09248"
author_name: "Sean Cribbs"
project_section: "mailinglistitem"
sent_date: 2012-11-08T10:48:26-08:00
---


Elias,

The resulting strategy of allow\\_mult=false and last\\_write\\_wins=false
(which is a simplification for developer-friendliness mostly):

1) Resolve differences using the vector clock first.
2) If siblings still exist, return the one with the latest timestamp.

So in a sense, it's a combination of vector-clock resolution and
resolution by timestamp. This might be ok if your write rate is small,
meaning that writes are unlikely to conflict; the upshot is that you
don't have to worry about resolution. However, in general we suggest
developers think about resolution strategies during development and
then use allow\\_mult=true in production.

On Thu, Nov 8, 2012 at 10:09 AM, Elias Levy  wrote:
&gt; On Tue, Nov 6, 2012 at 9:57 PM, Elias Levy 
&gt; wrote:
&gt;&gt;
&gt;&gt; It's also not clear from the docs what Riak considers the latest value
&gt;&gt; to return if allow\\_mult is false and so is last\\_write\\_wins, when you
&gt;&gt; have a conflict.
&gt;
&gt;
&gt; Any Basho folks have an answer to this one? How does Riak resolve a conflict
&gt; on a object fetch when both allow\\_mult and last\\_write\\_wins are false (the
&gt; default)?
&gt;
&gt; Elias
&gt;


-- 
Sean Cribbs 
Software Engineer
Basho Technologies, Inc.
http://basho.com/

