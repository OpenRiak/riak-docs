---
title: "Re: Locking"
description: ""
project: community
lastmod: 2011-08-02T10:20:29-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg04180"
mailinglist_parent_id: "msg04178"
author_name: "Jon Meredith"
project_section: "mailinglistitem"
sent_date: 2011-08-02T10:20:29-07:00
---


Thanks for the explanation.

Does mongo provide any guarantees about the shipping of the transactional
logs to other nodes before returning a successful write to clients? Unless
it does (like chain replication), you can't trust the values on the new
master until the old node has come back up and completed shipping it's
transactional log. I don't think that would give you the level of
consistency required for a locking system.

BR, Jon.


On Tue, Aug 2, 2011 at 10:59 AM, Jeffrey Kesselman  wrote:

&gt; Replicas mirror the master. In a master/replica system changes are always
&gt; made to the mater. The replicas just follow behind implementing the
&gt; transaction log after commit. They only become directly adressabel if the
&gt; master dies, in which case one of the replicas is nominated as new master.
&gt;
&gt; You can implement a single lock on a single object because it exists for
&gt; update on only one shard (that shard's master.) To try to get transactional
&gt; syntax across multipel objects is going to take a
&gt; multi-phase locking protocol that you implement yourself.
&gt;
&gt;
&gt; On Tue, Aug 2, 2011 at 11:28 AM, Jon Meredith  wrote:
&gt;
&gt;&gt; Thanks for the info.
&gt;&gt;
&gt;&gt; I haven't analyzed mongo's replication model and only did a quick scan of
&gt;&gt; the doc. It isn't clear how would you use the atomic test and set operation
&gt;&gt; you mentioned with sharding and replication to implement locks.
&gt;&gt;
&gt;&gt; Does the atomic test and set coordinate with all members in a replica set
&gt;&gt; to ensure a consistent update. If not, would you restrict yourself to a
&gt;&gt; single node in each shard to do the locking? Then you have to deal with
&gt;&gt; failover (client 1 discovers the locking node somehow, acquires a lock, the
&gt;&gt; locking node dies before the other members of the replica set are updated,
&gt;&gt; client 2 somehow discovers the replacement locking node and as the update
&gt;&gt; didn't make it out of the original lock server it also grants a lock).
&gt;&gt;
&gt;&gt; I can see how it could work with a chain replication scheme like Hibari
&gt;&gt; uses, but I'm not sure that's what mongo is doing. You take a performance
&gt;&gt; hit to do so.
&gt;&gt;
&gt;&gt; BR,
&gt;&gt; Jon
&gt;&gt;
&gt;&gt; On Tue, Aug 2, 2011 at 9:04 AM, Jeffrey Kesselman wrote:
&gt;&gt;
&gt;&gt;&gt; Mongo does its clustering a bit differently then Riak.
&gt;&gt;&gt;
&gt;&gt;&gt; It clusters in two dimensions. It shards for scalability,
&gt;&gt;&gt; and replicates for reliability. In any group of shards, only one shard has
&gt;&gt;&gt; a given piece of data. But that shard can be replicated in a master/slave
&gt;&gt;&gt; ,manner for failover.
&gt;&gt;&gt;
&gt;&gt;&gt; See:
&gt;&gt;&gt;
&gt;&gt;&gt; http://www.mongodb.org/display/DOCS/Sharding+Introduction#ShardingIntroduction-ShardinginaNutshell
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; On Tue, Aug 2, 2011 at 10:50 AM, Jon Meredith wrote:
&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Hi Jeffrey,
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Do you know if Mongo provides locks that can be used on clusters of
&gt;&gt;&gt;&gt; machines and in the presence of network partitions/failures? Riak could
&gt;&gt;&gt;&gt; probably get close if you created a cluster with a single node and 
&gt;&gt;&gt;&gt; performed
&gt;&gt;&gt;&gt; all accesses with N=R=W=1 as updating a single vnode is atomic, it's only
&gt;&gt;&gt;&gt; when the order of vnode requests can be interleaved that you get problems.
&gt;&gt;&gt;&gt; Of course you'd have a single point of failure....
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Soren: It may be worth looking at a separate lock service along the
&gt;&gt;&gt;&gt; lines of Zookeeper - you could take a look at the work Joe Blomstedt did on
&gt;&gt;&gt;&gt; riak\\_zab https://github.com/jtuple/riak\\_zab but as the FAQ suggests do
&gt;&gt;&gt;&gt; not use it in production.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; BR,
&gt;&gt;&gt;&gt; Jon.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; On Tue, Aug 2, 2011 at 8:40 AM, Jeffrey Kesselman wrote:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; jon gave a much better and more detailed description,
&gt;&gt;&gt;&gt;&gt; but fundamentally no true lock is possible without an atomic test and
&gt;&gt;&gt;&gt;&gt; set operation.
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; So far, of all the No Sql DBs I've looked at, only Mongo has that
&gt;&gt;&gt;&gt;&gt; capability.
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; On Sun, Jul 31, 2011 at 4:55 PM, Soren Hansen wrote:
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt; I've seen a couple of posts here and there on the subject of a locking
&gt;&gt;&gt;&gt;&gt;&gt; mechanism for Riak, most notably:
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt; http://riak-users.197444.n3.nabble.com/Riak-and-Locks-td1866960.html
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt; While it would only serve as an advisory locking mechanism, wouldn't a
&gt;&gt;&gt;&gt;&gt;&gt; bucket with a reasonably high n, w and dw set equal to n, a
&gt;&gt;&gt;&gt;&gt;&gt; deterministic naming scheme for the object being locked, and a locking
&gt;&gt;&gt;&gt;&gt;&gt; algorithm such as:
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt; 1. PUT /locks/object\\_id
&gt;&gt;&gt;&gt;&gt;&gt; If-None-Match: \\*
&gt;&gt;&gt;&gt;&gt;&gt; Body: 
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt; 1a. If this fails, wait for a while, then try again.
&gt;&gt;&gt;&gt;&gt;&gt; 1b. If it succeeds, proceed to 2.
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt; 2. The doc for If-None-Match says "this does not prevent concurrent
&gt;&gt;&gt;&gt;&gt;&gt; writes; it is possible for the condition to evaluate to true for
&gt;&gt;&gt;&gt;&gt;&gt; multiple requests if the requests occur at the same time." I'm not
&gt;&gt;&gt;&gt;&gt;&gt; completely sure if n=w=dw protects me from concurrent writes (I'm not
&gt;&gt;&gt;&gt;&gt;&gt; familiar with the locking semantics of a single riak instance).
&gt;&gt;&gt;&gt;&gt;&gt; Anyway, if I'm in fact not protected, the next step is to read the
&gt;&gt;&gt;&gt;&gt;&gt; value back to make sure we're actually the ones holding the key. If
&gt;&gt;&gt;&gt;&gt;&gt; not, go back to step 1. If yes, proceed as planned.
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt; 3. Once you're done with the lock, just DELETE it.
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt; If this were really that simple, someone would have suggested it. So,
&gt;&gt;&gt;&gt;&gt;&gt; what is this Riak rookie (i.e. I) missing?
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt; --
&gt;&gt;&gt;&gt;&gt;&gt; Soren Hansen | http://linux2go.dk/
&gt;&gt;&gt;&gt;&gt;&gt; Ubuntu Developer | http://www.ubuntu.com/
&gt;&gt;&gt;&gt;&gt;&gt; OpenStack Developer | http://www.openstack.org/
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt;&gt;&gt;&gt;&gt; riak-users mailing list
&gt;&gt;&gt;&gt;&gt;&gt; riak-users@lists.basho.com
&gt;&gt;&gt;&gt;&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt;&gt;&gt;&gt; riak-users mailing list
&gt;&gt;&gt;&gt;&gt; riak-users@lists.basho.com
&gt;&gt;&gt;&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;
&gt;
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

