---
title: "Re: riak_multi_backend and bitcask"
description: ""
project: community
lastmod: 2010-06-23T12:21:06-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg00646"
mailinglist_parent_id: "msg00645"
author_name: "Jon Meredith"
project_section: "mailinglistitem"
sent_date: 2010-06-23T12:21:06-07:00
---


Thanks for the detailed explanation Tamas, I should have reviewed the 
changeset as well as the commit log.


I'll try and take a look at it this afternoon.

--Jon


On 6/23/10 1:09 PM, Tamas Nagy wrote:

Hi,

I feel that is not going to fix the issue. I can prove it without compiling. (I 
know He who enters... :) )
riak\\_kv\\_multi\\_backend is not a process only riak\\_kv\\_vnode is. Hence these 
messages ({riak\\_kv\\_bitcask\\_backend, merge\\_check} and {riak\\_kv\\_bitcask\\_backend, 
{sync, SyncIntervalMs}}):

riak\\_kv\\_bitcask\\_backend:
start(Partition, \\_Config) -&gt;
 %% Schedule sync (if necessary)
 case application:get\\_env(bitcask, sync\\_strategy) of
 {ok, {seconds, Seconds}} -&gt;
 SyncIntervalMs = timer:seconds(Seconds),
 erlang:send\\_after(SyncIntervalMs, self(),
 {?MODULE, {sync, SyncIntervalMs}});
 \\_ -&gt; ok end,
 %% Schedule merge checks
 erlang:send\\_after(?MERGE\\_CHECK\\_INTERVAL, self(), {?MODULE, merge\\_check}),

will be sent to riak\\_kv\\_node handle\\_info (this did not change in the changeset 
you've linked in):

%% @private
handle\\_info(vnode\\_shutdown, \\_StateName, StateData) -&gt;
 {stop,normal,StateData};
handle\\_info(ok, StateName, StateData) -&gt;
 {next\\_state, StateName, StateData, ?TIMEOUT};
handle\\_info({Mod, Msg}, StateName, #state { mod = Mod } = StateData) -&gt;
 Mod:handle\\_info(StateData#state.modstate, Msg),
 {next\\_state, StateName, StateData, ?TIMEOUT}.

So the Mod in handle\\_info will be riak\\_kv\\_bitcask\\_backend but Mod is going to 
be riak\\_kv\\_multi\\_backend, because of this:

init([VNodeIndex]) -&gt;
 Mod = app\\_helper:get\\_env(riak\\_kv, storage\\_backend),
 Configuration = app\\_helper:get\\_env(riak\\_kv),
 {ok, ModState} = Mod:start(VNodeIndex, Configuration),
 StateData0 = #state{idx=VNodeIndex,mod=Mod,modstate=ModState,
 handoff\\_q=not\\_in\\_handoff},
 case hometest(StateData0) of
 {next\\_state, StateName, StateData, Timeout} -&gt;
 {ok, StateName, StateData, Timeout};
 {stop,normal,StateData} -&gt;
 {ok, ModState1} = Mod:start(VNodeIndex, Configuration),
 {ok, active, StateData#state{mod=Mod, modstate=ModState1}, 
?TIMEOUT}
 end.

I hope this makes sense. So the linked changeset is a step toward the right 
direction, but there is still some work left.
All three of my possible solutions are based on tip. If I will have time today 
I will fork the code and show you what I mean.

Regards,
 Tamas

----- "Jon Meredith" wrote:

Hi Tamas,

Are you using the 0.11.0 release? We found an issue with the multi
backend a few days ago detailed here
http://issues.basho.com/show\\_bug.cgi?id=274 . It should be fixed in
tip
after this change
http://bitbucket.org/basho/riak/changeset/bf66258beaac

You'll have to build from source source and check if that resolves
your
issue?

--Jon Meredith
Basho Technologies

On 6/23/10 12:36 PM, Tamas Nagy wrote:


Hi,

Thanks for the link. Should I create a ticket there from this


thread?


Well the error I saw was this (actually a lot of these because of


the restarts):


=ERROR REPORT==== 23-Jun-2010::12:40:34 ===
\\*\\* State machine&lt;0.201.0&gt; terminating
\\*\\* Last message in was {riak\\_kv\\_bitcask\\_backend,merge\\_check}
\\*\\* When State == active
\\*\\* Data == {state,0,[],riak\\_kv\\_multi\\_backend,
 {state,

[{riak\\_ets,riak\\_kv\\_ets\\_backend,&lt;0.203.0&gt;},


 {riak\\_bitcask,riak\\_kv\\_bitcask\\_backend,

{#Ref&lt;0.0.0.762&gt;,"data/bitcask/0"}}],


 riak\\_ets},
 not\\_in\\_handoff,undefined}
\\*\\* Reason for termination =
\\*\\* {function\\_clause,
 [{riak\\_kv\\_vnode,handle\\_info,
 [{riak\\_kv\\_bitcask\\_backend,merge\\_check},
 active,
 {state,0,[],riak\\_kv\\_multi\\_backend,
 {state,
 [{riak\\_ets,riak\\_kv\\_ets\\_backend,&lt;0.203.0&gt;},
 {riak\\_bitcask,riak\\_kv\\_bitcask\\_backend,
 {#Ref&lt;0.0.0.762&gt;,"data/bitcask/0"}}],
 riak\\_ets},
 not\\_in\\_handoff,undefined}]},
 {gen\\_fsm,handle\\_msg,7},
 {proc\\_lib,init\\_p\\_do\\_apply,3}]}

So as you can see riak\\_kv\\_vnode cannot handle


riak\\_kv\\_bitcask\\_backend messages ({riak\\_kv\\_bitcask, Whatever}) if the
backend type is riak\\_kv\\_multi\\_backend. There is simply no case for it
in the handle\\_info callback of riak\\_kv\\_vnode module. In the current
handle\\_info cases the Mod tag of the message has to be the same as the
value of the state's mod element. One of the possible fixes relaxes
this check.


Regards,
 Tamas

----- "Dan Reverri" wrote:


Hi Tamas,


You can find the public bug tracker here:
https://issues.basho.com/


Regarding using Bitcask with multiple backends, the only issue


I've


seen is trying to setup multiple bitcask backends. Bitcask defines
options using the "bitcask" application specification which is
globally set for the node; this prevents multiple instances of the
bitcask backend from running on a single node:
https://issues.basho.com/show\\_bug.cgi?id=210


You should be able to run a bitcask backend along side other


backend


types such as dets.


I did not completely follow your description; what issues did you


see


after setting bitcask as a backend in the multibackend options?


Were


keys not stored? Did you see errors in the log files? Did you try


to


setup multiple bitcask backends?


Thanks,
Dan

Daniel Reverri
Developer Advocate
Basho Technologies, Inc.
d...@basho.com

On Wed, Jun 23, 2010 at 1:45 PM, Tamas Nagy&lt;
tamas.n...@erlang-solutions.com&gt; wrote:


Hi,

I'm pretty new to the list (and riak) so please forgive my


ignorance


but I didn't manage to find a public bugtracker for riak. Hence


I'm


posting my problem here. (Bitbucket and Internet Explorer(using it


not


by choice) do not mix well. So that might be the problem why I


didn't


find it).

I've tried to use riak\\_kv\\_multi\\_backend with one of the backends


being


the riak\\_kv\\_bitcask\\_backend. This does not seem to work with
riak-0.11.0. I checked tip as well, and I do not think it would


work


either. The problem boils to these few lines (code snippets from


tip):


riak\\_kv\\_vnode:

handle\\_info({Mod, Msg}, StateName, #state { mod = Mod } =


StateData)


-&gt;
 Mod:handle\\_info(StateData#state.modstate, Msg),
 {next\\_state, StateName, StateData, ?TIMEOUT}.

riak\\_kv\\_bitcask\\_backend:

start(Partition, \\_Config) -&gt;
 %% Schedule sync (if necessary)
 case application:get\\_env(bitcask, sync\\_strategy) of
 {ok, {seconds, Seconds}} -&gt;
 SyncIntervalMs = timer:seconds(Seconds),
 erlang:send\\_after(SyncIntervalMs, self(),
 {?MODULE, {sync, SyncIntervalMs}});
 \\_ -&gt; ok end,
 %% Schedule merge checks
 erlang:send\\_after(?MERGE\\_CHECK\\_INTERVAL, self(), {?MODULE,
merge\\_check}),


riak\\_kv\\_multi\\_backend:

handle\\_info(State, Msg) -&gt;
 F = fun(\\_Name, Module, SubState) -&gt;
 Module:handle\\_info(SubState, Msg)
 end, [F(X) || X&lt;- State#state.backends],
 ok.

If riak\\_kv\\_multi\\_backend is configured in riak\\_kv\\_vnode the


state's


mod is riak\\_kv\\_multi\\_backend but the messages scheduled in
riak\\_kv\\_bitcask\\_backend are going to have riak\\_kv\\_bitcask\\_backend


as


their Mod tag.

With my limited understanding about the rest of the sytem it seems


to


me that adding this case to riak\\_kv\\_vnode would fix the problem:
handle\\_info({Mod, Msg}, StateName, #state { mod =
riak\\_kv\\_multi\\_backend } = StateData) -&gt;
 riak\\_kv\\_multi\\_backend:handle\\_info(StateData#state.modstate,


Msg),


 {next\\_state, StateName, StateData, ?TIMEOUT};

It is a bit wasteful because all the configured backends will get
called with this message, but it is the best I can think of


without


leaking too much information about the specific backends into the
generic code.

Modifying the handle\\_info case would work as well however one


check


would need to disappear:

handle\\_info({\\_ModTag, Msg}, StateName, #state { mod = Mod } =
StateData) -&gt;
 Mod:handle\\_info(StateData#state.modstate, Msg),
 {next\\_state, StateName, StateData, ?TIMEOUT}.

There are a plethora of other ways to fix this like passing the


Mod


tag to riak\\_kv\\_multi\\_backend so that it can filter based on it


(this


is probably my favourite as it is not wasteful and there aren't


many


code changes needed either):
riak\\_kv\\_vnode:
handle\\_info({Mod, Msg}, StateName, #state { mod =
riak\\_kv\\_multi\\_backend } = StateData) -&gt;
 riak\\_kv\\_multi\\_backend:handle\\_info(StateData#state.modstate,


{Mod,


Msg}),
 {next\\_state, StateName, StateData, ?TIMEOUT};

riak\\_kv\\_multi\\_backend:
handle\\_info(State, {Mod, Msg}) -&gt;
 F = fun(\\_Name, Module, SubState) -&gt;
 Module:handle\\_info(SubState, Msg)
 end, [F(X) || X = {\\_, Module, \\_}&lt;-


State#state.backends,


Module =:= Mod],
 ok.

Code is not tested, but should compile. :)

Regards,
 Tamas

--
Tamas Nagy
Erlang Solutions Ltd.
http://www.erlang-solutions.com
---------------------------------------------------

---------------------------------------------------

WE'VE CHANGED NAMES!

Since January 1st 2010 Erlang Training and Consulting Ltd. has


become


ERLANG SOLUTIONS LTD.

www.erlang-solutions.com
