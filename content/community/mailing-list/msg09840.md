---
title: "Re: Security risk of clients having access to vector clocks"
description: ""
project: community
lastmod: 2013-01-18T10:16:24-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg09840"
mailinglist_parent_id: "msg09837"
author_name: "Brian Picciano"
project_section: "mailinglistitem"
sent_date: 2013-01-18T10:16:24-08:00
---


Awesome, thank you so much for the help everyone!

On Fri, Jan 18, 2013 at 9:35 AM, Jon Meredith  wrote:

&gt; There is no equivalent of an SQL injection attack on the vector clock.
&gt;
&gt; If the client is able to tamper with it the only three issues I can think
&gt; of are
&gt;
&gt; 1) deliberately corrupting it so that the put operation crashes which
&gt; would end up with a timeout. If the application required the store and did
&gt; not check before continuing it could be a problem.
&gt;
&gt; 2) a more sophisticated version would replace the vector clock with one
&gt; that was considered an ancestor which would generate a sibling if allow
&gt; mult is set yes. If you didn't resolve then you could make large objects.
&gt;
&gt; 3) similarly you could add fake entires to the clock which would make more
&gt; work for the resolution code and slow things down until the clock was
&gt; truncated by riak.
&gt;
&gt; If successfully decoded the information contained is a list of tuples with
&gt; an 8 byte vnode id, and update count and a last update fine for the vnode.
&gt; The only information leak I can see is an estimate of the number of
&gt; updates.
&gt;
&gt; Jon
&gt;
&gt; On Jan 17, 2013, at 7:29 PM, Gregory Haskins 
&gt; wrote:
&gt;
&gt; &gt;
&gt; &gt; On Jan 17, 2013, at 9:06 PM, Brian Picciano 
&gt; wrote:
&gt; &gt;
&gt; &gt;&gt; Are there any ways we could combat this?
&gt; &gt;
&gt; &gt; I can't comment on what might be at risk from a Riak perspective, but as
&gt; a general comment you could combat client-side tampering using crypto
&gt; (perhaps you have already considered this option, I am not sure).
&gt; &gt;
&gt; &gt; For instance, you could attach an HMAC to the vector clock before
&gt; returning it client side as a token, and then validate the HMAC when the
&gt; token is passed back to you in the future. This will add overhead for both
&gt; generating and validating the token, but it could alleviate exposure
&gt; against db tampering. (Note that an HMAC alone will not protect you from
&gt; replay of a previously issued vclock+HMAC, however. For that you will need
&gt; to be more clever). Generally, I prefer to handle this stuff server side
&gt; attached to the session, which I know isn't "RESTful", but it is easier to
&gt; solve the security problems this way.
&gt; &gt;
&gt; &gt; Good luck!
&gt; &gt; -Greg
&gt; &gt;
&gt; &gt;
&gt; &gt;
