---
title: "Re: Why is Riak Search using the leveldb backend?"
description: ""
project: community
lastmod: 2011-11-12T13:14:59-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg05562"
mailinglist_parent_id: "msg05559"
author_name: "Elias Levy"
project_section: "mailinglistitem"
sent_date: 2011-11-12T13:14:59-08:00
---


On Fri, Nov 11, 2011 at 5:57 PM, Ryan Zezeski  wrote:

&gt; This is an implementation detail of Search. It stores something we call a
&gt; "proxy object" under the bucket \\_rsid\\_ [1]. It does this so it
&gt; knows which entries to remove from the index when an object is
&gt; updated/deleted. To achieve your goal you should be able to set the
&gt; buckets `\\_rsid\\_bucket1` and `\\_rsid\\_bucket2` to use the `bucket1` and
&gt; `bucket2` backends, respectively.
&gt;

Ryan,

Thanks. That makes sense. I actually wondered how you took care of that.
 Fetching the objects before an update and retokenizing them, just so you
could delete the previous search index posting seemed very inefficient.

Its interesting that the proxy objects are taking about the same disk space
as the actually data, and significantly less than the search index itself
in the merge\\_index backend, which is about a third the size of the proxy
objects in leveldb. We do have lots of indexes with long keys, and while
merge\\_index compresses its data, from discussion on the list I believe you
turned off Snappy in leveldb because of portability issues.

Are there plans to enable Snappy some time in the future? It probably give
a good performance bump in environments like EC2 where the CPU to IO
tradeoff is so lopsided.

Elias
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

