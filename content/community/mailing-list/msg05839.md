---
title: "Re: Secondary Indexes - Feedback?"
description: ""
project: community
lastmod: 2011-12-01T10:50:30-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg05839"
mailinglist_parent_id: "msg05824"
author_name: "Greg Pascale"
project_section: "mailinglistitem"
sent_date: 2011-12-01T10:50:30-08:00
---


&gt; That's a concern, but you gain parallelism, compared to Search's single term 
&gt; index.
&gt; 
&gt; 
&gt; 
&gt; While they are more expensive in the sense that they require more nodes to 
&gt; participate, they split the load between the nodes, thus overall, the work 
&gt; should be about the same, and unless the nodes are busy with some other work, 
&gt; it should complete sooner, as each node has less work to do.
&gt; 
&gt; 
&gt; 


I think your logic is flawed. Each node has fewer keys to return, but that 
doesn't mean it has that much less work. Whether you're returning 1 key or 100, 
you still have to go to disk to read from the index, and I have to imagine 
that's much more expensive than reading the keys (if there isn't a huge number 
of them). In other words, I believe the latency dominates the cost here. It's 
the same idea as how downloading 100 1MB files is slower than 1 100MB file. For 
a simple query - the only kind 2I supports - I'd rather read the whole index 
with only one disk read.


And what if I don't have a lot of keys? In many cases, my 2I lookup may only 
ever return one result. For example, imagine a Person record with secondary 
indices over email address and username. Presumably, each email address and 
username is unique, so any 2I queries I do on those fields should return one 
result. I really hate the idea that I have to talk to 1/3 of the machines in my 
ring (and they probably all have to go to disk too) just so that one of them 
can ultimately return my one result.
&gt; Not sure why this would be a concern. Search's presort option must have the 
&gt; full result set before it can fully sort it, no? There is no reason why 
&gt; sorting the results of a a 2i query should be any slower. In addition, 2i is 
&gt; stored in leveldb, and leveldb, like merge\\_index if I recall correctly, 
&gt; stores keys and values sorted. Thus, the result set is already partially 
&gt; ordered.
&gt; 
&gt; 
&gt; 

No - presort is applied to keys before any index documents are retrieved, so 
it's quite fast. Yes, the results are ordered in the index, but that doesn't 
matter to the user. The API states result ordering is undefined.


-- 
Greg
Clipboard

On Wednesday, November 30, 2011 at 3:05 PM, Elias Levy wrote:

&gt; On Wed, Nov 30, 2011 at 1:32 PM,  (mailto:riak-users-requ...@lists.basho.com)&gt; wrote:
&gt; &gt; Here at Clipboard, we make very heavy use of Riak Search and a couple of 
&gt; &gt; manual indices here and there. I've wanted to use 2i a few times but have 
&gt; &gt; decided against it for a few reasons:
&gt; &gt; 
&gt; &gt; 1) Apprehension about the coverage set query, as Matt articulated.
&gt; 
&gt; That's a concern, but you gain parallelism, compared to Search's single term 
&gt; index.
&gt; 
&gt; &gt; 2) Lack of ordering of returned results. Generally I just want the top 10 
&gt; &gt; or so, and the ordering information is in the primary key. I can accomplish 
&gt; &gt; this with search via the presort parameter.
&gt; 
&gt; Not sure why this would be a concern. Search's presort option must have the 
&gt; full result set before it can fully sort it, no? There is no reason why 
&gt; sorting the results of a a 2i query should be any slower. In addition, 2i is 
&gt; stored in leveldb, and leveldb, like merge\\_index if I recall correctly, 
&gt; stores keys and values sorted. Thus, the result set is already partially 
&gt; ordered. 
&gt; 
&gt; &gt; To me, the implementations of search and 2I are backwards. Search has 
&gt; &gt; scalability issues because term-based partitioning optimizes for 
&gt; &gt; single-term queries, but creates huge hotspots making many AND queries 
&gt; &gt; prohibitively expensive. 2I's document-based partitioning makes single-term 
&gt; &gt; queries more expensive (coverage set) but should allow AND queries to 
&gt; &gt; scale. But 2i only supports single-term queries!
&gt; 
&gt; While they are more expensive in the sense that they require more nodes to 
&gt; participate, they split the load between the nodes, thus overall, the work 
&gt; should be about the same, and unless the nodes are busy with some other work, 
&gt; it should complete sooner, as each node has less work to do. 
&gt; 
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com (mailto:riak-users@lists.basho.com)
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

