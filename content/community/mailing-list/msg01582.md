---
title: "Re: MapReduce filtering question"
description: ""
project: community
lastmod: 2010-11-19T20:55:01-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg01582"
mailinglist_parent_id: "msg01580"
author_name: "Parker Thompson"
project_section: "mailinglistitem"
sent_date: 2010-11-19T20:55:01-08:00
---


Thanks, a few questions inline...

On Fri, Nov 19, 2010 at 2:43 PM, Sean Cribbs  wrote:

class Riak::Alternative
&gt; include Ripple::Document
&gt; many :visitors, :class\\_name =&gt; "Riak::Visitor"
&gt; property :alternative\\_id, Integer, :presence =&gt; true
&gt; key\\_on :alternative\\_id
&gt; end
&gt;

If I expect to be writing large numbers of visitor-&gt;alternatives links is it
performant to be writing them all as links on one object, as opposed to
creating many experience docs each with a link ? Na√Øvely I would assume
this might less evenly distribute write load or degrade as the size of the
Link data grows. Does this matter?


&gt; ########
&gt;
&gt; def visitors\\_who\\_shared
&gt; Riak::MapReduce.new(Ripple.client).
&gt; add("riak\\_alternatives", ar\\_id.to\\_s).
&gt; link(:bucket =&gt; 'riak\\_visitors').
&gt; map(link\\_to\\_events\\_forward\\_visitor).
&gt; map(map\\_share\\_events\\_to\\_visitor).
&gt; reduce(["riak\\_kv\\_mapreduce", "reduce\\_set\\_union"]).
&gt; map(map\\_identity, :keep =&gt; true).
&gt; run
&gt; end
&gt;

Ah, I was looking for a set\\_union. Is there a full list of these functions
hiding somewhere?

Thanks,

pt.
