---
title: "Re: Evolving data model"
description: ""
project: community
lastmod: 2012-09-19T12:30:35-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg08598"
mailinglist_parent_id: "msg08596"
author_name: "Deepak Balasubramanyam"
project_section: "mailinglistitem"
sent_date: 2012-09-19T12:30:35-07:00
---


It really depends on your use case. Guido's tips on not-null and
ignore-properties will help. With \\*JsonIgnoreProperties\\* you can also
specify which ones you would like to ignore. That helps check ignoring
properties that you know \\*should\\* exist.

Converting your documents to a new format is a lot of work. I assume your
buckets are filled with millions of keys that need to take on a new format.
The complexity depends on your Q / R / W values and the format of your keys
(are they sequential / random with a uniform distribution ?). You will need
to take into account the eventual consistency of the system and how the
migration should be done on a live environment. It can get messy.
Performance would be a concern too since you will be iterating through all
keys in a bucket which Riak frowns upon. Not to mention recreating indexes
/ links / metadata (if applicable).

It will be easier to just keep adding attributes and ignore the ones that
you know older models will not understand. Think of the model as a JSON
object that is like a protobuf message (a .proto file if you have come
across one) or a representation of a row on a table. It is easy to add
data, but when you delete something and someone's model was depending on
it, it can get ugly.

Thanks
Deepak Bala

On Wed, Sep 19, 2012 at 10:03 PM, Guido Medina wrote:

&gt; We have done similar things, but it always depends on the available
&gt; tools, your requirements and needs, I will give you a short example, our
&gt; main application uses a standard SQL, for historical data we use Riak, data
&gt; that is not changing, for example, audit trails, daily chunks from
&gt; different sources and so on.
&gt;
&gt; We make sure our data is 100% JSON compatible, and our tools are the
&gt; available JSON libraries, it is fair easy to add new "columns" to your data
&gt; (I know, columns right?), and keep your fetching still valid by ignoring
&gt; deprecated properties and when writing back just overwriting old data, that
&gt; way, your schema can change all the time without losing old data and
&gt; evolving at the same time.
&gt;
&gt; 2i is fine to stamp and migrate if you wish, since it makes your code
&gt; tedious if you need to be checking for nulls all the time, so for migration
&gt; you can simply use JSON transformers, from this property to another (from
&gt; old to new schema) without even coding, but it will be up to your tools.
&gt;
&gt; In Java for example all that can be aid with Jackson which happens to be
&gt; the defacto JSON Riak Java client provider, here is a list of few
&gt; annotations to accomplish most of the things are you worried about:
&gt;
&gt;
&gt; \\*@JsonIgnoreProperties(ignoreUnknown=true)\\* (Say an old property just got
&gt; deprecated and you want your POJO not to throw exceptions while converting
&gt; from JSON to your POJO)
&gt; \\*@JsonSerialize(include=JsonSerialize.Inclusion.NON\\_NULL)\\* (Saves lot of
&gt; space)
&gt;
&gt;
&gt; @Override
&gt; \\*@JsonProperty("ranges")\\* (Say, a property just changed its type, and
&gt; because of that, I need to map it to a new property, in this case, I don't
&gt; have a list of integers anymore but a list of ranges, so a transformation
&gt; is required...)
&gt; public List getEntries()
&gt; {
&gt; return intRangeCollection.getRangesAsArray();
&gt; }
&gt;
&gt; \\*@JsonProperty("ranges")\\*
&gt; public void setEntries(final List entries)
&gt; {
&gt;
&gt; this.intRangeCollection=IntRangeCollection.buildIntRangesCollectionFromArrays(entries);
&gt; }
&gt;
&gt; Well, there is so much I could show you, but, examples are limitless, so
&gt; depending on your use cases, you will figure your own ways to keep your
&gt; code kind of clean and your schema changing constantly.
&gt;
&gt; Hope that helps,
&gt;
&gt; Guido.
&gt;
&gt;
&gt; On 19/09/12 16:08, Pinney Colton wrote:
&gt;
&gt; Wow, that's a pretty big question.
&gt;
&gt; IMO, it depends upon what you're doing with your data. Personally, I'm
&gt; storing up to 4 different "versions" of the same data in Riak, each version
&gt; is optimized for different types of analytical operations.
&gt;
&gt; That's probably not ideal for everybody. Heck, storing 4 copies of my
&gt; data isn't even optimal for me from a storage perspective - but it does
&gt; help optimize performance of different queries. I care more about that
&gt; than disk or memory.
&gt;
&gt; On Tue, Sep 18, 2012 at 5:55 PM, Allen Johnson wrote:
&gt;
&gt;&gt; Hey everyone,
&gt;&gt;
&gt;&gt; I'm beginning to experiment with Riak and I'm trying to better
&gt;&gt; understand how to model my data. One question I have at the moment is
&gt;&gt; how to evolve my data with a data store such as Riak? I know that
&gt;&gt; it's schema-less and that I can add new fields as needed but I'm
&gt;&gt; thinking more about the existing documents.
&gt;&gt;
&gt;&gt; For example, say hypothetically, that I have a fairly successful
&gt;&gt; riak-based app. As the application code continues to evolve over
&gt;&gt; several versions I begin to find a "better" way to model my data. By
&gt;&gt; this time I have already stored many, many documents. What is the
&gt;&gt; appropriate path here? Do I version my documents with metadata and
&gt;&gt; rely on my application code to continue to deal with old-style
&gt;&gt; documents -- or do I perform some sort of bulk transformation on these
&gt;&gt; existing documents?
&gt;&gt;
&gt;&gt; Thanks,
&gt;&gt; Allen
&gt;&gt;
&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt; riak-users mailing list
&gt;&gt; riak-users@lists.basho.com
&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt;
&gt;
&gt;
&gt;
&gt; --
&gt; \\*Pinney H. Colton\\*
&gt; \\*Bitwise Data, LLC\\*
&gt; +1.763.220.0793 (o)
&gt; +1.651.492.0152 (m)
&gt; http://www.bitwisedata.com
&gt;
&gt;
&gt;
&gt;
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing 
&gt; listriak-users@lists.basho.comhttp://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;
&gt;
&gt;
&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;
&gt;
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

