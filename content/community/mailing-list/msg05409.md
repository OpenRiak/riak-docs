---
title: "Re: Indexing of intermediate nested fields in Riak search"
description: ""
project: community
lastmod: 2011-11-01T09:12:17-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg05409"
mailinglist_parent_id: "msg05398"
author_name: "Rusty Klophaus"
project_section: "mailinglistitem"
sent_date: 2011-11-01T09:12:17-07:00
---


Hi Elias,

Yes, your workaround should work, you should be able to index and query on
subobjects with the same field names. I've included two examples below that
work successfully for me locally. Please take a look, this may help uncover
what's going wrong.

Best,
Rusty

bin/search-cmd install mybucket

# Example 1

curl -v -X PUT \\
-H "Content-Type: application/json" \\
-d @- \\
http://127.0.0.1:8098/riak/mybucket/mykey1 \\
&lt;wrote:

&gt; Any ideas on this? Should indexing for sub-objects in an array with the
&gt; same field names in a JSON document work?
&gt;
&gt;
&gt;
&gt; On Sun, Oct 30, 2011 at 6:56 AM, Elias Levy 
&gt; wrote:
&gt;
&gt;&gt; On Sat, Oct 29, 2011 at 9:59 PM, Elias Levy 
&gt;&gt; wrote:
&gt;&gt;
&gt;&gt;&gt; I am wondering if Riak search can index intermediate nested fields.
&gt;&gt;&gt; When indexing json data through the KV precommit hook, the underscore is
&gt;&gt;&gt; understood in the schema as indicating nesting. Thus, foo\\_bar will index
&gt;&gt;&gt; the value "bah" of field "bar" in the json document { "foo" : { "bar" :
&gt;&gt;&gt; "bah" } }.
&gt;&gt;&gt;
&gt;&gt;&gt; What I'd like to know is if it can instead index the key "bar" in the
&gt;&gt;&gt; same json document. In my current use case I want to be able to find
&gt;&gt;&gt; documents with certain values for "bar" for these types of documents.
&gt;&gt;&gt;
&gt;&gt;&gt; Can this be done by simply indexing the field "foo"? Does search know
&gt;&gt;&gt; to index all keys in "foo" if foo is a hash, or all its values if it is an
&gt;&gt;&gt; array?
&gt;&gt;&gt;
&gt;&gt;
&gt;&gt; My testing on 1.0.0 shows that this appears not to work. Looking at the
&gt;&gt; source for the search kv extractor gives the impression that a workaround
&gt;&gt; would be to instead store { "foo" : [ { "x": "bar", "y": "bah"}, { "x":
&gt;&gt; "woo", "y": "zoo" }, ... ]} and index "foo\\_z" to be able to search for
&gt;&gt; "bar" and "woo". I.e. it appears the extractor will index each subdocument
&gt;&gt; in the array.
&gt;&gt;
&gt;&gt; At least that is what json\\_text() function implies with the tests:
&gt;&gt;
&gt;&gt; {&lt;&lt;"
&gt;&gt;
&gt;&gt; {\\"menu\\": {
&gt;&gt;
&gt;&gt; \\"id\\": \\"file\\",
&gt;&gt;
&gt;&gt; \\"value\\": \\"File\\",
&gt;&gt;
&gt;&gt; \\"popup\\": {
&gt;&gt;
&gt;&gt; \\"menuitem\\": [
&gt;&gt;
&gt;&gt; {\\"value\\": \\"New\\", \\"onclick\\": \\"CreateNewDoc()\\"},
&gt;&gt;
&gt;&gt; {\\"value\\": \\"Open\\", \\"onclick\\": \\"OpenDoc()\\"},
&gt;&gt;
&gt;&gt; {\\"value\\": \\"Close\\", \\"onclick\\": \\"CloseDoc()\\"}
&gt;&gt;
&gt;&gt; ]
&gt;&gt;
&gt;&gt; }
&gt;&gt;
&gt;&gt; }}"&gt;&gt;,
&gt;&gt;
&gt;&gt; [{&lt;&lt;"menu\\_id"&gt;&gt;, &lt;&lt;"file"&gt;&gt;},
&gt;&gt;
&gt;&gt; {&lt;&lt;"menu\\_value"&gt;&gt;, &lt;&lt;"File"&gt;&gt;},
&gt;&gt;
&gt;&gt; {&lt;&lt;"menu\\_popup\\_menuitem\\_value"&gt;&gt;, &lt;&lt;"New"&gt;&gt;},
&gt;&gt;
&gt;&gt; {&lt;&lt;"menu\\_popup\\_menuitem\\_onclick"&gt;&gt;, &lt;&lt;"CreateNewDoc()"&gt;&gt;},
&gt;&gt;
&gt;&gt; {&lt;&lt;"menu\\_popup\\_menuitem\\_value"&gt;&gt;, &lt;&lt;"Open"&gt;&gt;},
&gt;&gt;
&gt;&gt; {&lt;&lt;"menu\\_popup\\_menuitem\\_onclick"&gt;&gt;, &lt;&lt;"OpenDoc()"&gt;&gt;},
&gt;&gt;
&gt;&gt; {&lt;&lt;"menu\\_popup\\_menuitem\\_value"&gt;&gt;, &lt;&lt;"Close"&gt;&gt;},
&gt;&gt;
&gt;&gt; {&lt;&lt;"menu\\_popup\\_menuitem\\_onclick"&gt;&gt;, &lt;&lt;"CloseDoc()"&gt;&gt;}]},
&gt;&gt;
&gt;&gt; %% From 
&gt;&gt; http://www.ibm.com/developerworks/library/x-atom2json.html
&gt;&gt;
&gt;&gt;
&gt;&gt;&gt; The implication of the above code is that you can search for
&gt;&gt; menu\\_popup\\_menuitem\\_value:New or menu\\_popup\\_menuitem\\_value:Open and find
&gt;&gt; the doc. But my testing shows this not to work. If any of the documents
&gt;&gt; in the array have the same fields, those fields will not be indexed.
&gt;&gt;
&gt;&gt; E.g. if I set my schema to index foo\\_bar and insert {"foo": [ { "bar" :
&gt;&gt; "baz" }, {"xxx":"yyy"} ] }, I can search for foo\\_bar:baz and receive a
&gt;&gt; match. If I instead insert '{"foo": [ { "bar" : "baz" }, {"bar":"yyy"} ]
&gt;&gt; }' and search for foo\\_bar:baz I receive no match.
&gt;&gt;
&gt;&gt; Is this expected behavior or a bug?
&gt;&gt;
&gt;&gt; Elias
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;

-- 
Rusty Klophaus (@rustyio)
\\*Basho Technologies, Inc.\\*
www.basho.com
