---
title: "Re: How to make Riak work faster (writing)"
description: ""
project: community
lastmod: 2012-11-05T09:10:06-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg09198"
mailinglist_parent_id: "msg09169"
author_name: "Uruka Dark"
project_section: "mailinglistitem"
sent_date: 2012-11-05T09:10:06-08:00
---


Just an update.

I ran the benchmark again, but now, using Memory backend:
https://dl.dropbox.com/u/308392/memory\\_summary.png

This was the result using Bitcask backend:
https://dl.dropbox.com/u/308392/bitcask\\_summary.png

The difference is not that big in my environment. I was expecting much
better results, but I don't know if it was supposed to happen.
Anyway, your results are still much better, even when I'm using memory only
backend (50% of yours).

Maybe it can help to understand what is happening.

On Sat, Nov 3, 2012 at 7:31 PM, Uruka Dark  wrote:

&gt; Jared,
&gt;
&gt; Again, thank you very much.
&gt; You helped me a lot.
&gt;
&gt; I perfectly understand your point. I'm just starting to know Riak and I
&gt; want to go much deeper. But, before I keep going, I want make sure that I'm
&gt; starting with the right foot :)
&gt; I double/triple-checked and I still have no additional clues about what is
&gt; happening.
&gt;
&gt; You've reached much better results than mine using your default settings,
&gt; and, given my numbers, I'm still missing something. I would like at least
&gt; to get closer to your results. If you think that I'll not make any better
&gt; than this with my default settings, please, let me know.
&gt;
&gt; Anyway, this is my app.config:
&gt;
&gt; %% -\\*- mode: erlang;erlang-indent-level: 4;indent-tabs-mode: nil -\\*-
&gt; %% ex: ft=erlang ts=4 sw=4 et
&gt; [
&gt; %% Riak Client APIs config
&gt; {riak\\_api, [
&gt; %% pb\\_backlog is the maximum length to which the queue of
&gt; pending
&gt; %% connections may grow. If set, it must be an integer &gt;= 0.
&gt; %% By default the value is 5. If you anticipate a huge number
&gt; of
&gt; %% connections being initialised \\*simultaneously\\*, set this
&gt; number
&gt; %% higher.
&gt; %% {pb\\_backlog, 64},
&gt;
&gt; %% pb\\_ip is the IP address that the Riak Protocol Buffers
&gt; interface
&gt; %% will bind to. If this is undefined, the interface will not
&gt; run.
&gt; {pb\\_ip, "10.1.1.221" },
&gt;
&gt; %% pb\\_port is the TCP port that the Riak Protocol Buffers
&gt; interface
&gt; %% will bind to
&gt; {pb\\_port, 8087 }
&gt; ]},
&gt;
&gt; %% Riak Core config
&gt; {riak\\_core, [
&gt; %% Default location of ringstate
&gt; {ring\\_state\\_dir, "/var/lib/riak/ring"},
&gt;
&gt; %% Default ring creation size. Make sure it is a power of 2,
&gt; %% e.g. 16, 32, 64, 128, 256, 512 etc
&gt; %{ring\\_creation\\_size, 64},
&gt;
&gt; %% http is a list of IP addresses and TCP ports that the Riak
&gt; %% HTTP interface will bind.
&gt; {http, [ {"10.1.1.221", 8098 } ]},
&gt;
&gt; %% https is a list of IP addresses and TCP ports that the
&gt; Riak
&gt; %% HTTPS interface will bind.
&gt; {https, [{ "10.1.1.221", 8069 }]},
&gt;
&gt; %% Default cert and key locations for https can be overridden
&gt; %% with the ssl config variable, for example:
&gt; {ssl, [
&gt; {certfile, "/etc/riak/server.crt"},
&gt; {keyfile, "/etc/riak/server.key"}
&gt; ]},
&gt;
&gt; %% riak\\_handoff\\_port is the TCP port that Riak uses for
&gt; %% intra-cluster data handoff.
&gt; {handoff\\_port, 8099 },
&gt;
&gt; %% To encrypt riak\\_core intra-cluster data handoff traffic,
&gt; %% uncomment the following line and edit its path to an
&gt; %% appropriate certfile and keyfile. (This example uses a
&gt; %% single file with both items concatenated together.)
&gt; %{handoff\\_ssl\\_options, [{certfile, "/tmp/erlserver.pem"}]},
&gt;
&gt; %% DTrace support
&gt; %% Do not enable 'dtrace\\_support' unless your Erlang/OTP
&gt; %% runtime is compiled to support DTrace. DTrace is
&gt; %% available in R15B01 (supported by the Erlang/OTP
&gt; %% official source package) and in R14B04 via a custom
&gt; %% source repository & branch.
&gt; {dtrace\\_support, false},
&gt;
&gt; %% Platform-specific installation paths (substituted by
&gt; rebar)
&gt; {platform\\_bin\\_dir, "/usr/sbin"},
&gt; {platform\\_data\\_dir, "/var/lib/riak"},
&gt; {platform\\_etc\\_dir, "/etc/riak"},
&gt; {platform\\_lib\\_dir, "/usr/lib/riak/lib"},
&gt; {platform\\_log\\_dir, "/var/log/riak"}
&gt; ]},
&gt;
&gt; %% Riak KV config
&gt; {riak\\_kv, [
&gt; %% Storage\\_backend specifies the Erlang module defining the
&gt; storage
&gt; %% mechanism that will be used on this node.
&gt; %{storage\\_backend, riak\\_kv\\_memory\\_backend},
&gt; {storage\\_backend, riak\\_kv\\_bitcask\\_backend},
&gt; %{storage\\_backend, riak\\_kv\\_eleveldb\\_backend},
&gt;
&gt; %% raw\\_name is the first part of all URLS used by the Riak raw
&gt; HTTP
&gt; %% interface. See riak\\_web.erl and raw\\_http\\_resource.erl for
&gt; %% details.
&gt; %{raw\\_name, "riak"},
&gt;
&gt; %% mapred\\_name is URL used to submit map/reduce requests to
&gt; Riak.
&gt; {mapred\\_name, "mapred"},
&gt;
&gt; %% mapred\\_system indicates which version of the MapReduce
&gt; %% system should be used: 'pipe' means riak\\_pipe will
&gt; %% power MapReduce queries, while 'legacy' means that luke
&gt; %% will be used
&gt; {mapred\\_system, pipe},
&gt;
&gt; %% mapred\\_2i\\_pipe indicates whether secondary-index
&gt; %% MapReduce inputs are queued in parallel via their own
&gt; %% pipe ('true'), or serially via a helper process
&gt; %% ('false' or undefined). Set to 'false' or leave
&gt; %% undefined during a rolling upgrade from 1.0.
&gt; {mapred\\_2i\\_pipe, true},
&gt;
&gt; %% directory used to store a transient queue for pending
&gt; %% map tasks
&gt; %% Only valid when mapred\\_system == legacy
&gt; %% {mapred\\_queue\\_dir, "/var/lib/riak/mr\\_queue" },
&gt;
&gt; %% Each of the following entries control how many Javascript
&gt; %% virtual machines are available for executing map, reduce,
&gt; %% pre- and post-commit hook functions.
&gt; {map\\_js\\_vm\\_count, 8 },
&gt; {reduce\\_js\\_vm\\_count, 6 },
&gt; {hook\\_js\\_vm\\_count, 2 },
&gt;
&gt; %% Number of items the mapper will fetch in one request.
&gt; %% Larger values can impact read/write performance for
&gt; %% non-MapReduce requests.
&gt; %% Only valid when mapred\\_system == legacy
&gt; %% {mapper\\_batch\\_size, 5},
&gt;
&gt; %% js\\_max\\_vm\\_mem is the maximum amount of memory, in megabytes,
&gt; %% allocated to the Javascript VMs. If unset, the default is
&gt; %% 8MB.
&gt; {js\\_max\\_vm\\_mem, 8},
&gt;
&gt; %% js\\_thread\\_stack is the maximum amount of thread stack, in
&gt; megabyes,
&gt; %% allocate to the Javascript VMs. If unset, the default is
&gt; 16MB.
&gt; %% NOTE: This is not the same as the C thread stack.
&gt; {js\\_thread\\_stack, 16},
&gt;
&gt; %% Number of objects held in the MapReduce cache. These will be
&gt; %% ejected when the cache runs out of room or the bucket/key
&gt; %% pair for that entry changes
&gt; %% Only valid when mapred\\_system == legacy
&gt; %% {map\\_cache\\_size, 10000},
&gt;
&gt; %% js\\_source\\_dir should point to a directory containing
&gt; Javascript
&gt; %% source files which will be loaded by Riak when it
&gt; initializes
&gt; %% Javascript VMs.
&gt; %{js\\_source\\_dir, "/tmp/js\\_source"},
&gt;
&gt; %% http\\_url\\_encoding determines how Riak treats URL encoded
&gt; %% buckets, keys, and links over the REST API. When set to 'on'
&gt; %% Riak always decodes encoded values sent as URLs and Headers.
&gt; %% Otherwise, Riak defaults to compatibility mode where links
&gt; %% are decoded, but buckets and keys are not. The compatibility
&gt; %% mode will be removed in a future release.
&gt; {http\\_url\\_encoding, on},
&gt;
&gt; %% Switch to vnode-based vclocks rather than client ids. This
&gt; %% significantly reduces the number of vclock entries.
&gt; %% Only set true if \\*all\\* nodes in the cluster are upgraded to
&gt; 1.0
&gt; {vnode\\_vclocks, true},
&gt;
&gt; %% This option enables compatability of bucket and key listing
&gt; %% with 0.14 and earlier versions. Once a rolling upgrade to
&gt; %% a version &gt; 0.14 is completed for a cluster, this should be
&gt; %% set to false for improved performance for bucket and key
&gt; %% listing operations.
&gt; {legacy\\_keylisting, false},
&gt;
&gt; %% This option toggles compatibility of keylisting with 1.0
&gt; %% and earlier versions. Once a rolling upgrade to a version
&gt; %% &gt; 1.0 is completed for a cluster, this should be set to
&gt; %% true for better control of memory usage during key listing
&gt; %% operations
&gt; {listkeys\\_backpressure, true}
&gt; ]},
&gt;
&gt; %% Riak Search Config
&gt; {riak\\_search, [
&gt; %% To enable Search functionality set this 'true'.
&gt; {enabled, false}
&gt; ]},
&gt;
&gt; %% Merge Index Config
&gt; {merge\\_index, [
&gt; %% The root dir to store search merge\\_index data
&gt; {data\\_root, "/var/lib/riak/merge\\_index"},
&gt;
&gt; %% Size, in bytes, of the in-memory buffer. When this
&gt; %% threshold has been reached the data is transformed
&gt; %% into a segment file which resides on disk.
&gt; {buffer\\_rollover\\_size, 1048576},
&gt;
&gt; %% Overtime the segment files need to be compacted.
&gt; %% This is the maximum number of segments that will be
&gt; %% compacted at once. A lower value will lead to
&gt; %% quicker but more frequent compactions.
&gt; {max\\_compact\\_segments, 20}
&gt; ]},
&gt;
&gt; %% Bitcask Config
&gt; {bitcask, [
&gt; {data\\_root, "/var/lib/riak/bitcask"}
&gt; ]},
&gt;
&gt; %% eLevelDB Config
&gt; {eleveldb, [
&gt; {data\\_root, "/var/lib/riak/leveldb"},
&gt; {write\\_buffer\\_size\\_min, 31457280}, %% 30 MB in bytes
&gt; {write\\_buffer\\_size\\_max, 62914560} %% 60 MB in bytes
&gt; ]},
&gt;
&gt; %% Lager Config
&gt; {lager, [
&gt; %% What handlers to install with what arguments
&gt; %% The defaults for the logfiles are to rotate the files when
&gt; %% they reach 10Mb or at midnight, whichever comes first, and
&gt; keep
&gt; %% the last 5 rotations. See the lager README for a
&gt; description of
&gt; %% the time rotation format:
&gt; %% https://github.com/basho/lager/blob/master/README.org
&gt; %%
&gt; %% If you wish to disable rotation, you can either set the
&gt; size to 0
&gt; %% and the rotation time to "", or instead specify a 2-tuple
&gt; that only
&gt; %% consists of {Logfile, Level}.
&gt; {handlers, [
&gt; {lager\\_console\\_backend, info},
&gt; {lager\\_file\\_backend, [
&gt; {"/var/log/riak/error.log", error, 10485760, "$D0", 5},
&gt; {"/var/log/riak/console.log", info, 10485760, "$D0", 5}
&gt; ]}
&gt; ]},
&gt;
&gt; %% Whether to write a crash log, and where.
&gt; %% Commented/omitted/undefined means no crash logger.
&gt; {crash\\_log, "/var/log/riak/crash.log"},
&gt;
&gt; %% Maximum size in bytes of events in the crash log - defaults
&gt; to 65536
&gt; {crash\\_log\\_msg\\_size, 65536},
&gt;
&gt; %% Maximum size of the crash log in bytes, before its rotated,
&gt; set
&gt; %% to 0 to disable rotation - default is 0
&gt; {crash\\_log\\_size, 10485760},
&gt;
&gt; %% What time to rotate the crash log - default is no time
&gt; %% rotation. See the lager README for a description of this
&gt; format:
&gt; %% https://github.com/basho/lager/blob/master/README.org
&gt; {crash\\_log\\_date, "$D0"},
&gt;
&gt; %% Number of rotated crash logs to keep, 0 means keep only the
&gt; %% current one - default is 0
&gt; {crash\\_log\\_count, 5},
&gt;
&gt; %% Whether to redirect error\\_logger messages into lager -
&gt; defaults to true
&gt; {error\\_logger\\_redirect, true}
&gt; ]},
&gt;
&gt; %% riak\\_sysmon config
&gt; {riak\\_sysmon, [
&gt; %% To disable forwarding events of a particular type, use a
&gt; %% limit of 0.
&gt; {process\\_limit, 30},
&gt; {port\\_limit, 2},
&gt;
&gt; %% Finding reasonable limits for a given workload is a matter
&gt; %% of experimentation.
&gt; {gc\\_ms\\_limit, 100},
&gt; {heap\\_word\\_limit, 40111000},
&gt;
&gt; %% Configure the following items to 'false' to disable logging
&gt; %% of that event type.
&gt; {busy\\_port, true},
&gt; {busy\\_dist\\_port, true}
&gt; ]},
&gt;
&gt; %% SASL config
&gt; {sasl, [
&gt; {sasl\\_error\\_logger, false}
&gt; ]},
&gt;
&gt; %% riak\\_control config
&gt; {riak\\_control, [
&gt; %% Set to false to disable the admin panel.
&gt; {enabled, true},
&gt;
&gt; %% Authentication style used for access to the admin
&gt; %% panel. Valid styles are 'userlist' .
&gt; {auth, none},
&gt;
&gt; %% If auth is set to 'userlist' then this is the
&gt; %% list of usernames and passwords for access to the
&gt; %% admin panel.
&gt; {userlist, [{"user", "pass"}
&gt; ]},
&gt;
&gt; %% The admin panel is broken up into multiple
&gt; %% components, each of which is enabled or disabled
&gt; %% by one of these settings.
&gt; {admin, true}
&gt; ]}
&gt; ].
&gt;
&gt; ------
&gt; I have two machines with those settings: 10.1.1.221 and 10.1.1.222. They
&gt; are working together.
&gt; Do you see any problem on that?
&gt;
&gt; Again, if you think I can't go any further with those default settings
&gt; (without tuning FS, etc), please, let me know.
&gt;
&gt; Thank you.
&gt;
&gt; On Sat, Nov 3, 2012 at 4:43 PM, Jared Morrow  wrote:
&gt;
&gt;&gt; Uruka,
&gt;&gt;
&gt;&gt; Now that you got some somewhat reasonable numbers, it is probably time to
&gt;&gt; discuss what you are trying to get out of Riak. We typically recommend 4
&gt;&gt; or 5 nodes minimum for a Riak install because that is the point where the
&gt;&gt; distribution becomes a performance benefit rather than a hindrance. I know
&gt;&gt; you were just load testing, but I'd recommend considering a test with 4 or
&gt;&gt; 5 nodes, with default N values. During the test, remove a node (power it
&gt;&gt; off, or 'riak stop' it). Or like someone else mentioned start with a 3 or
&gt;&gt; 4 node cluster and add a node to see how the performance goes up and no
&gt;&gt; further operations work is needed to rebalance the data around the cluster.
&gt;&gt; This is really where Riak shines over some alternative databases, the ease
&gt;&gt; of scaling and dealing with failures. SIngle node performance although fun
&gt;&gt; to try and tune to get the most out of it, isn't as interesting on a long
&gt;&gt; timeline when trying to scale the system. Obviously single node
&gt;&gt; performance is still important, dont' get me wrong. Riak isn't always the
&gt;&gt; best choice, but when it comes with staying available and performance while
&gt;&gt; systems are failing no other system has a better real-world story than Riak.
&gt;&gt;
&gt;&gt; If you still want to get your single node performance up, we have several
&gt;&gt; pages on our docs page based around tuning. A good place to start is the
&gt;&gt; file system tuning page
&gt;&gt; http://docs.basho.com/riak/latest/cookbooks/File-System-Tuning/ .
&gt;&gt; Reading that and other pages in the Operations section might be helpful in
&gt;&gt; squeezing out those last bits of speed.
&gt;&gt;
&gt;&gt; I am glad to see your initial 60 writes/sec has gone up to 800
&gt;&gt; writes/sec, but we definitely can do better once you start utilizing our
&gt;&gt; strengths.
&gt;&gt;
&gt;&gt; Hope my rambling helped,
&gt;&gt; -Jared
&gt;&gt;
&gt;&gt; On Sat, Nov 3, 2012 at 4:55 AM, Uruka Dark  wrote:
&gt;&gt;
&gt;&gt;&gt; Jared,
&gt;&gt;&gt;
&gt;&gt;&gt; Thank you for you time and reply.
&gt;&gt;&gt;
&gt;&gt;&gt; I got impressed by your numbers and I started to double check my
&gt;&gt;&gt; settings. I found a big problem here, my third machine (the one out of the
&gt;&gt;&gt; cluster, making the load), was not talking to Riak in gigabit speed, it was
&gt;&gt;&gt; 100 Mbs. I changed the network cable and it's working fine now.
&gt;&gt;&gt; I ran my python script again and I already could see better results: 252
&gt;&gt;&gt; ops/sec (before the fix it was 175 ops/sec).
&gt;&gt;&gt;
&gt;&gt;&gt; I also ran your benchmark .config, and these are my numbers:
&gt;&gt;&gt; https://dl.dropbox.com/u/308392/summary.png
&gt;&gt;&gt;
&gt;&gt;&gt; As you can see, even so, I'm still far from your results.. not even
&gt;&gt;&gt; close, and now I'm using Bitcask.
&gt;&gt;&gt; Anyway, my current position is much better than at the beggining. I'll
&gt;&gt;&gt; double-check all over again, cause now I have a confirmation that there is
&gt;&gt;&gt; something wrong.
&gt;&gt;&gt;
&gt;&gt;&gt; If you have any suggestion, please, let me know.
&gt;&gt;&gt; Once again, thank you.
&gt;&gt;&gt;
&gt;&gt;&gt; On Sat, Nov 3, 2012 at 3:08 AM, Jared Morrow  wrote:
&gt;&gt;&gt;
&gt;&gt;&gt;&gt; I forgot to mention that 2000 ops/sec was on bitcask, not memory. I
&gt;&gt;&gt;&gt; didn't bother with the memory backend.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; -Jared
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; On Sat, Nov 3, 2012 at 12:05 AM, Jared Morrow  wrote:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; Uruka,
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; So looking at your results something is really wrong with your setup.
&gt;&gt;&gt;&gt;&gt; I was surprised by your numbers, so I made two VM's each with only 1gb of
&gt;&gt;&gt;&gt;&gt; RAM on two different boxes also on a 1gb switch.
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; I ran a put of 100,000 keys at 10kb in size.
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; I didn't do any tuning at all on the VM's and these were quick Ubuntu
&gt;&gt;&gt;&gt;&gt; 10.04 VM's with 2 virtual CPU's and 1 gig of ram. I also didn't change 
&gt;&gt;&gt;&gt;&gt; any
&gt;&gt;&gt;&gt;&gt; settings in Riak, except for the IP address and listening ports.
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; Here is the summary of the results showing around 2000 ops/sec
&gt;&gt;&gt;&gt;&gt; https://dl.dropbox.com/u/183971/summary.png
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; So my main thought is that you weren't actually using N=1 for your
&gt;&gt;&gt;&gt;&gt; puts and you were using the default N value of 3, meaning you were writing
&gt;&gt;&gt;&gt;&gt; each key/value 3 times, and with 2 nodes this is doing a lot of writes to
&gt;&gt;&gt;&gt;&gt; the same disk multiple times.
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; To be sure you have N=1, you can use 'riak attach' on each node and
&gt;&gt;&gt;&gt;&gt; enter the following command:
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; riak\\_core\\_bucket:set\\_bucket(&lt;&lt;"pop1"&gt;&gt;,[{n\\_val,1}]).
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; If you bucket name is "pop1" as in my case. That name is completely
&gt;&gt;&gt;&gt;&gt; arbitrary.
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; Sorry I'm late to this thread, I had to find some time to setup the
&gt;&gt;&gt;&gt;&gt; test.
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; For reference I used https://github.com/basho/basho\\_bench for the
&gt;&gt;&gt;&gt;&gt; benchmark. With the following .config file
&gt;&gt;&gt;&gt;&gt; https://gist.github.com/e630b63f4a025a0fb634
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; Hope this helps,
&gt;&gt;&gt;&gt;&gt; Jared
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;
&gt;
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

