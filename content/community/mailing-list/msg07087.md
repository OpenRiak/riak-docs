---
title: "Re: riak java pb client does not let go of bad sockets"
description: ""
project: community
lastmod: 2012-03-29T14:42:21-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg07087"
mailinglist_parent_id: "msg07071"
author_name: "Brian Roach"
project_section: "mailinglistitem"
sent_date: 2012-03-29T14:42:21-07:00
---


Thanks (and Sorry!) for reporting this Will.

This was a bug in the underlying Protocol Buffers RiakClient where Socket 
objects were not being closed when IOExceptions were received from their 
streams. This is now fixed in the 1.0.5 release, available today.

Thanks again,
Brian Roach


On Mar 28, 2012, at 12:09 PM, Will Gage wrote:

&gt; Hello,
&gt; 
&gt; 
&gt; I have run into a production issue that I think stems from either a defect in 
&gt; the com.basho.riak:riak-client:jar:1.0.4 library, or a misunderstanding in my 
&gt; use of it. I'm actively trying to fix the issue, but I thought I'd put a 
&gt; feeler out to this list to see if others have encountered the issue, or 
&gt; whether there's a clear problem in our use of the library.
&gt; 
&gt; Environment:
&gt; ---------------------
&gt; \\* Java web application running in Tomcat:
&gt; \\*\\* JDK: jdk1.6.0\\_24-jce6
&gt; \\*\\* Tomcat: apache-tomcat-7.0.23
&gt; \\*\\* Basho Riak Client version: com.basho.riak:riak-client:jar:1.0.4
&gt; \\* 6 node Riak cluster running Riak 1.0.1
&gt; 
&gt; Error sequence:
&gt; -----------------------
&gt; The production issue has happened a few times, and it follows this sequence:
&gt; 
&gt; 1. We get a rash of SocketException: Connection Reset errors
&gt; 
&gt; java.net.SocketException: Connection reset
&gt; at java.net.SocketInputStream.read(SocketInputStream.java:168)
&gt; at java.io.BufferedInputStream.fill(BufferedInputStream.java:218)
&gt; at java.io.BufferedInputStream.read(BufferedInputStream.java:237)
&gt; at java.io.DataInputStream.readInt(DataInputStream.java:370)
&gt; at com.basho.riak.pbc.RiakConnection.receive(RiakConnection.java:92)
&gt; at com.basho.riak.pbc.RiakClient.processFetchReply(RiakClient.java:278)
&gt; at com.basho.riak.pbc.RiakClient.fetch(RiakClient.java:252)
&gt; at com.basho.riak.pbc.RiakClient.fetch(RiakClient.java:241)
&gt; at 
&gt; com.basho.riak.client.raw.pbc.PBClientAdapter.fetch(PBClientAdapter.java:156)
&gt; at 
&gt; com.basho.riak.client.raw.pbc.PBClientAdapter.fetch(PBClientAdapter.java:139)
&gt; at com.basho.riak.client.raw.ClusterClient.fetch(ClusterClient.java:107)
&gt; 
&gt; 2. Followed 50 milliseconds later by a steady stream of SocketException: 
&gt; Broken pipe messages, until we restart the Tomcat container.
&gt; 
&gt; java.net.SocketException: Broken pipe
&gt; at java.net.SocketOutputStream.socketWrite0(Native Method)
&gt; at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:92)
&gt; at java.net.SocketOutputStream.write(SocketOutputStream.java:136)
&gt; at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:65)
&gt; at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:123)
&gt; at java.io.DataOutputStream.flush(DataOutputStream.java:106)
&gt; at com.basho.riak.pbc.RiakConnection.send(RiakConnection.java:82)
&gt; at com.basho.riak.pbc.RiakClient.fetch(RiakClient.java:251)
&gt; at com.basho.riak.pbc.RiakClient.fetch(RiakClient.java:241)
&gt; at 
&gt; com.basho.riak.client.raw.pbc.PBClientAdapter.fetch(PBClientAdapter.java:156)
&gt; at 
&gt; com.basho.riak.client.raw.pbc.PBClientAdapter.fetch(PBClientAdapter.java:139)
&gt; at com.basho.riak.client.raw.ClusterClient.fetch(ClusterClient.java:107)
&gt; 
&gt; 3. Within our 6-node Riak cluster, almost exactly 1 minute after the initial 
&gt; connection reset errors, one node emits a crash log:
&gt; 
&gt; 2012-03-27 14:56:51 =ERROR REPORT====
&gt; \\*\\* Generic server &lt;0.289.0&gt; terminating 
&gt; \\*\\* Last message in was {inet\\_async,#Port&lt;0.3319&gt;,41462,{ok,#Port&lt;0.73913715&gt;}}
&gt; \\*\\* When Server state == {state,riak\\_kv\\_pb\\_listener,#Port&lt;0.3319&gt;,{state,8087}}
&gt; \\*\\* Reason for termination == 
&gt; \\*\\* 
&gt; {timeout,{'gen\\_server2',call,[&lt;0.1838.1574&gt;,{set\\_socket,#Port&lt;0.73913715&gt;}]}}
&gt; 2012-03-27 14:57:08 =CRASH REPORT====
&gt; crasher:
&gt; initial call: gen\\_nb\\_server:init/1
&gt; pid: &lt;0.289.0&gt;
&gt; registered\\_name: []
&gt; exception exit: 
&gt; {timeout,{'gen\\_server2',call,[&lt;0.1838.1574&gt;,{set\\_socket,#Port&lt;0.73913715&gt;}]}}
&gt; in function gen\\_server:terminate/6
&gt; in call from proc\\_lib:init\\_p\\_do\\_apply/3
&gt; ancestors: [riak\\_kv\\_sup,&lt;0.194.0&gt;]
&gt; messages: [{#Ref&lt;0.0.704.111074&gt;,ok}]
&gt; links: [&lt;0.200.0&gt;]
&gt; dictionary: []
&gt; trap\\_exit: false
&gt; status: running
&gt; heap\\_size: 377
&gt; stack\\_size: 24
&gt; reductions: 117962
&gt; neighbours:
&gt; 2012-03-27 14:57:09 =SUPERVISOR REPORT====
&gt; Supervisor: {local,riak\\_kv\\_sup}
&gt; Context: child\\_terminated
&gt; Reason: 
&gt; {timeout,{'gen\\_server2',call,[&lt;0.1838.1574&gt;,{set\\_socket,#Port&lt;0.73913715&gt;}]}}
&gt; Offender: 
&gt; [{pid,&lt;0.289.0&gt;},{name,riak\\_kv\\_pb\\_listener},{mfargs,{riak\\_kv\\_pb\\_listener,start\\_link,[]}},{restart\\_type,permanent},{shutdown,5000},{child\\_type,worker}]
&gt; 
&gt; 
&gt; The Riak cluster seems to bounce back to health (all nodes connected and 
&gt; responding) by the time we see the errors and check it, but the clients (the 
&gt; Tomcat application) never recover until we restart them. It seems pretty 
&gt; clear that a process within the Riak cluster is dying and taking its sockets 
&gt; with it, after which the clients are not recovering.
&gt; 
&gt; 
&gt; Theory
&gt; ----------
&gt; The working theory is that the client library is never flushing out bad 
&gt; connections. You can see here that connections are always returned to the 
&gt; pool. I have not yet seen any evidence that connections are ever tested for 
&gt; health once allocated.
&gt; 
&gt; From com.basho.riak.pbc.RiakClient, line 224-237:
&gt; 
&gt; public RiakObject[] fetch(ByteString bucket, ByteString key, int 
&gt; readQuorum)
&gt; throws IOException {
&gt; RpbGetReq req = RPB.RpbGetReq.newBuilder().setBucket(bucket)
&gt; .setKey(key).setR(readQuorum).build();
&gt; 
&gt; RiakConnection c = getConnection();
&gt; try {
&gt; c.send(MSG\\_GetReq, req);
&gt; return processFetchReply(c, bucket, key).getObjects();
&gt; } finally {
&gt; release(c);
&gt; }
&gt; 
&gt; }
&gt; 
&gt; And this is how our reference to the client is created, using client-side 
&gt; cluster configs:
&gt; 
&gt; // set up a PBClientConfig per host
&gt; for(String host : hosts) {
&gt; 
&gt; PBClientConfig pbcConfig = new PBClientConfig.Builder()
&gt; .withInitialPoolSize(config.getInitialPoolSize())
&gt; .withPort(config.getRiakPort())
&gt; .withHost(host.trim())
&gt; 
&gt; .withConnectionTimeoutMillis(config.getConnectionWaitTimeoutMillis())
&gt; 
&gt; .withIdleConnectionTTLMillis(config.getIdleConnectionTTLMillis())
&gt; .withSocketBufferSizeKb(config.getBufferSizeKb())
&gt; .withPoolSize(config.getMaximunPoolSize())
&gt; .build();
&gt; 
&gt; clusterConfig.addClient(pbcConfig);
&gt; 
&gt; }
&gt; 
&gt; // Connection pooling is done internally in the PBClusterClient 
&gt; created by the factory
&gt; RawClient rawClient = 
&gt; PBClusterClientFactory.getInstance().newClient(clusterConfig);
&gt; 
&gt; this.client = rawClient;
&gt; 
&gt; Is the expectation within the client library that our own application code 
&gt; would detect bad connections and recreate the pool / client once we've 
&gt; detected them?
&gt; 
&gt; 
&gt; Thanks,
&gt; Will
