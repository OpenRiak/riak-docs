---
title: "Re: Removing properties in Ripple"
description: ""
project: community
lastmod: 2011-02-09T06:45:14-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg02244"
mailinglist_parent_id: "msg02241"
author_name: "Duff OMelia"
project_section: "mailinglistitem"
sent_date: 2011-02-09T06:45:14-08:00
---


&gt; A little git history helps. It seems you added that spec back in November, I 
&gt; think
&gt; around the time we were discussing how to properly deal with the "\\_type"
&gt; property in #instantiate.

That's hilarious! Ouch! I'm lame. Hopefully next time I'll remember
to ask myself for the motivation behind the test I added. Ridiculous!


&gt; Without remembering too much of the original context, the question seems to 
&gt; be: should it
&gt; silently ignore attributes that no longer exist on the model or should it 
&gt; warn the
&gt; programmer in some way that a property doesn't exist?

Perhaps when we're instantiating/reloading, we could iterate over the
robject.data (like we're doing), and then call the setter if the
property's been declared. If it hasn't been declared, then maybe we
could put it on @attributes.

This could allow us to access unmapped properties and potentially do
some migrating, etc.

When we save an object out to Riak, we'd want to ensure that any
attributes which don't map to properties get saved out.

I think when we're saving now, we're eventually calling:

 def attributes
 self.class.properties.values.inject({}) do |hash, prop|
 hash[prop.key] = attribute(prop.key)
 hash
 end.with\\_indifferent\\_access
 end

which may need to change. I'm not sure if that could use the
@attributes to give the copy. It looks like the property values are
kept in sync with the @attributes' values.

All in all, it seems useful to be able to have our Ripple Document
declaration of properties not necessarily be in sync with the actual
Riak document underneath.

Whatcha think?


------------------------------------------------------------
Duff OMelia

