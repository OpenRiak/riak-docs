---
title: "Re: Inconsistent map/reduce results"
description: ""
project: community
lastmod: 2011-03-29T18:16:37-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg02790"
mailinglist_parent_id: "msg02607"
author_name: "Keith Dreibelbis"
project_section: "mailinglistitem"
sent_date: 2011-03-29T18:16:37-07:00
---


Followup to this (somewhat old) thread...

I had resolved my problem by putting the vnode\\_cache\\_entries=0 thing in
app.config, doing what Grant said. But sometime later it began failing
again. I was getting misses of 25%-50% on records that should have been
found by map reduce but weren't. At that point I tried Rohman's suggestion
of using a random seed, and that worked around the problem successfully.
 But this isn't a very satisfying fix.

So the vnode\\_cache\\_entries=0 thing doesn't really fix it after all? Is
there something else to put in the config that would make this work
properly, without the random seed hack? BTW since the original thread I
have upgraded from 0.13 to 0.14, and the bug is still there.


Keith


On Thu, Mar 10, 2011 at 6:56 PM, Antonio Rohman Fernandez &lt;
roh...@mahalostudio.com&gt; wrote:

&gt; if you want to avoid caching ( without configuration ), you can put some
&gt; random variable in your map or reduce or both... that does the trick for me
&gt; as the query will be always different:
&gt;
&gt; $seed = randomStringHere;
&gt;
&gt; {"map":{"language":"javascript","source":"function(v,k,a) { seed='.$seed.';
&gt; x=Riak.mapValuesJson(v)[0]; return [v.values[0].data]; }"}
&gt;
&gt; Rohman
&gt;
&gt; On Thu, 10 Mar 2011 17:47:49 -0800, Keith Dreibelbis 
&gt; wrote:
&gt;
&gt; Thanks for the prompt response, Grant. I made the configuration change you
&gt; suggested, and it fixed my problem.
&gt; Some followup questions:
&gt; - is it possible to configure this dynamically on a per-bucket basis, or
&gt; just per-server like it is now?
&gt; - is this fixed in a newer version?
&gt;
&gt; On Thu, Mar 10, 2011 at 2:56 PM, Grant Schofield  wrote:
&gt;
&gt;&gt; There are currently some bugs in the mapreduce caching system. The best
&gt;&gt; thing to do would be to disable the feature, on 0.13 you can do this by
&gt;&gt; editing or adding the vnode\\_cache\\_entries to the riak\\_kv section of your
&gt;&gt; app.config. The entry would look like:
&gt;&gt; {vnode\\_cache\\_entries, 0},
&gt;&gt;
&gt;&gt; Grant Schofield
&gt;&gt; Developer Advocate
&gt;&gt; Basho Technologies
&gt;&gt;
&gt;&gt; On Mar 10, 2011, at 4:16 PM, Keith Dreibelbis wrote:
&gt;&gt;
&gt;&gt; Hi riak-users,
&gt;&gt; I'm trying to do a map/reduce query from java on a 0.13 server, and get
&gt;&gt; inconsistent results. What I'm doing should be pretty simple. I'm hoping
&gt;&gt; someone will notice an obvious error in here, or have some insight:
&gt;&gt; This is an automated test. I'm doing a simple query where I'm trying to
&gt;&gt; get the keys for records with a certain field value. In SQL it would look
&gt;&gt; like "SELECT id FROM table WHERE age = '32'". In java I'm invoking it like
&gt;&gt; this:
&gt;&gt; MapReduceResponse r = riak.mapReduceOverBucket(getBucket())
&gt;&gt; .map(JavascriptFunction.anon(func), true)
&gt;&gt; .submit();
&gt;&gt; where riak is a RiakClient, getBucket() returns the name of the bucket,
&gt;&gt; and func is a string that looks like:
&gt;&gt; function(value, keyData, arg) {
&gt;&gt; var data = Riak.mapValuesJson(value)[0];
&gt;&gt; if(data.age == "32")
&gt;&gt; return [value.key];
&gt;&gt; else
&gt;&gt; return [];
&gt;&gt; }
&gt;&gt; No reduce phase. All entries in the example bucket are json and have an
&gt;&gt; age field. This initially works correctly, it gets back the matching
&gt;&gt; records as expected. It also works in curl. It's an automated test, so
&gt;&gt; each time I run this, it is using a different bucket. After about a dozen
&gt;&gt; queries, this starts to fail. It returns an empty result, when it should
&gt;&gt; have found records. It fails in curl at the same time.
&gt;&gt; I initially suspected this might have something to do with doing map
&gt;&gt; reduce too soon after writing, and the write not being available on all
&gt;&gt; nodes. However, I changed the bucket schema entries for w,r,rw,dw from
&gt;&gt; "quorum" to "all", and this still happens (is there another bucket setting I
&gt;&gt; missed?). In addition, I only have 3 nodes (I'm using the dev123 example),
&gt;&gt; and am running curl long enough afterwards.
&gt;&gt; Here's the strange part that makes me suspicious. If I make
&gt;&gt; insignificant changes to the query, for example change the double quotes to
&gt;&gt; single quotes, add whitespace or extra parentheses, etc, then it suddenly
&gt;&gt; works again. It will work on an existing bucket, and on subsequent tests,
&gt;&gt; but again only about a dozen times before it starts failing again. Same
&gt;&gt; behavior in curl. This makes me suspect that the server is doing some
&gt;&gt; incorrect caching around this js function, based on the function string.
&gt;&gt; Any explanation about what's going on?
&gt;&gt; Keith
&gt;&gt;
&gt;&gt; --
&gt;
&gt; [image: line][image: logo]  \\*Antonio Rohman 
&gt; Fernandez\\*
&gt; CEO, Founder & Lead Engineer
&gt; roh...@mahalostudio.com \\*Projects\\*
&gt; MaruBatsu.es 
&gt; PupCloud.com 
&gt; Wedding Album [image: line]
&gt;
&gt;
