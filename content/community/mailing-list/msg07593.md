---
title: "Re: Writing a reduce phase with reduce_phase_only_1 and additional	parameters"
description: ""
project: community
lastmod: 2012-06-01T06:57:57-07:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg07593"
mailinglist_parent_id: "msg07516"
author_name: "Bryan Fink"
project_section: "mailinglistitem"
sent_date: 2012-06-01T06:57:57-07:00
---


On Wed, May 23, 2012 at 3:03 PM, Manuel Gomez  wrote:
&gt; This is my function so far:
&gt;
&gt; reduce\\_slice(WList,{Page,PageSize}) -&gt;
&gt;   lager:info("Page and PageSize ~p - ~p",[Page,PageSize]),
&gt;   lists:sublist(WList, Page, PageSize).
&gt;
&gt;
&gt; This "works". The problem is that because the reduce phase gets executed
&gt; with whatever it has at any given moment, the end result is always
&gt; different. So I need to call this phase with reduce\\_phase\\_only\\_1 as a param,
&gt; and here is where I'm a bit lost, this is how I call the function now:
&gt;
&gt; {reduce,{modfun,whisper\\_db,reduce\\_slice},{Page,PageSize},true}])
&gt;
&gt; I see that in the Riak's MapReduce documentation you can call a function
&gt; with "reduce\\_phase\\_only\\_1" like so:
&gt;
&gt; {reduce, FunSpec, [reduce\\_phase\\_only\\_1], Keep}
&gt;
&gt; So I tried:
&gt;
&gt; {reduce,{modfun,whisper\\_db,reduce\\_slice},[reduce\\_phase\\_only\\_1,{Page,PageSize}],true}])
&gt;
&gt; Which throws (of course because of the the function definition is not
&gt; expecting a list):
&gt;
&gt; Supervisor riak\\_pipe\\_vnode\\_worker\\_sup had child undefined started with
&gt; {riak\\_pipe\\_vnode\\_worker,start\\_link,undefined} at &lt;0.2927.0&gt; exit with reason
&gt; no function clause matching whisper\\_db:reduce\\_slice([

Hi, Manuel. You were headed in exactly the right direction. This is
just a matter of getting the match spec right in your function clause.
 The key thing to know is that third element of your phase spec is
passed, in its entirety, to your reduce function as its second
argument.

So, when you changed from

 {reduce, {modfun, whisper\\_db, reduce\\_slice}, {Page, PageSize}, true}

to

 {reduce, {modfun, whisper\\_db, reduce\\_slice}, [reduce\\_phase\\_only\\_1,
{Page, PageSize}], true}

the argument that was passed to your reduce phase changed from

 {Page, PageSize}

to

 [reduce\\_phase\\_only\\_1, {Page, PageSize}]

The easiest way to figure this out would have been to modify your
function to accept anything and do some "printf" debugging, like so:

 %% just print out Arg so we can see what we're dealing with
 reduce\\_slice\\_debug(\\_Input, Arg) -&gt;
 lager:info("Arg: ~p", [Arg]),
 []. %% just return nothing for now while we debug

Running the MapReduce again with [reduce\\_phase\\_only\\_1, {1, 10}] will
cause this to print out on the Riak console:

 09:43:02.125 [info] Arg: [reduce\\_phase\\_only\\_1,{1,10}]

So, all that needs to be done is to modify that Arg to match the whole
list, instead of just the page-size tuple. The most direct option is:

 %% Most direct: just match the expected option list
 reduce\\_slice(WList, [reduce\\_phase\\_only\\_1, {Page, PageSize}]) -&gt;
 lager:info("Page and PageSize ~p - ~p", [Page, PageSize]),
 lists:sublist(WList, Page, PageSize).

This is also the most brittle option, however, as it will break if you
leave reduce\\_phase\\_only\\_1 out of the list, or if you put it at the end
instead. A slightly more flexible solution is to match the whole
argument, and then look through it to find the page-size option:

 %% Slightly more flexible: look for a tuple that is correctly shaped
 reduce\\_slice(WList, Options) -&gt;
 {Page, PageSize} = find\\_page\\_option(Options),
 lager:info("Page and PageSize ~p - ~p", [Page, PageSize]),
 lists:sublist(WList, Page, PageSize).

 find\\_page\\_option([{Page, PageSize}|\\_])
 when is\\_integer(Page), is\\_integer(PageSize) -&gt;
 {Page, PageSize};
 find\\_page\\_option([\\_|Rest]) -&gt;
 find\\_page\\_option(Rest);
 find\\_page\\_option([]) -&gt;
 %% without this clause, the reduce evaluation will error out if
 %% the page/size option is omitted or incorrectly formed
 DefaultPage = 1,
 DefaultPageSize = 100,
 {DefaultPage, DefaultPageSize}.

This allows you to leave reduce\\_phase\\_only\\_1 out, or put it elsewhere
in the list. It also allows you to leave the page-size option out,
and have a default value filled in, or even to add other options at
will.

I'll also offer you one additional version, which demonstrates an
extremely common way to pass around many options in Erlang, known as
"tagged tuples" or "proplists":

 %% Most flexible: tagged tuples
 reduce\\_slice(WList, Options) -&gt;
 DefaultPage = 1,
 DefaultPageSize = 100,
 Page = proplists:get\\_value(page, Options, DefaultPage),
 PageSize = proplists:get\\_value(page\\_size, Options, DefaultPageSize),
 lager:info("Page and PageSize ~p - ~p", [Page, PageSize]),
 lists:sublist(WList, Page, PageSize).

This version expects a slightly different argument. Instead of a
{Page, PageSize} tuple, it expects to find two tuples: {page, Page}
and {page\\_size, PageSize}. The MapReduce spec would look like this
(to start at 1 and grab 10 results):

 {reduce, {modfun, whisper\\_db, reduce\\_slice3}, [{page, 1},
{page\\_size, 10}, reduce\\_phase\\_only\\_1], true}

I hope that helps.

-Bryan

